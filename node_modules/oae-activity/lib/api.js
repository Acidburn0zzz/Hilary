/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-activity-api');
var MQ = require('oae-util/lib/mq');
var Validator = require('oae-authz/lib/validator').Validator;

var ActivityAggregator = require('./internal/aggregator');
var ActivityConfig = require('./internal/config');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./internal/dao');
var ActivityRouter = require('./internal/router');
var ActivityStream = require('oae-activity/lib/model').ActivityStream;
var ActivityTransformer = require('./internal/transformer');

var boundWorker = false;
var collectionPollingTimer = null;

/**
 * Refresh the activities configuration.
 *
 * @param   {Object}        [config]                            The object containing the configuration properties
 * @param   {Boolean}       [config.processActivityJobs]        Whether or not this server node should produce and route activities. Defaults to `true`
 * @param   {Number}        [config.activityTtl]                The time-to-live (in seconds) for generated activities. Defaults to 2 weeks
 * @param   {Number}        [config.aggregateIdleExpiry]        The amount of time (in milliseconds) an aggregate can be idle until it expires. Defaults to 3 hours
 * @param   {Number}        [config.aggregateMaxExpiry]         An upper-bound on the amount of time (in milliseconds) for which an aggregate can live. Defaults to 1 day
 * @param   {Number}        [config.numberOfProcessingBuckets]  The number of buckets available for parallel processing of activities. Defaults to 5
 * @param   {Number}        [config.collectionExpiry]           The maximum amount of time (in milliseconds) a processing bucket can be locked for at one time. Defaults to 1 minute
 * @param   {Number}        [config.maxConcurrentCollections]   The maximum number of concurrent collection cycles that can be active on a process at once. Defaults to 3
 * @param   {Number}        [config.collectionPollingFrequency] How often (in milliseconds) the processing buckets are polled for new activities. If -1, polling will be disabled. Defaults to 5 seconds
 * @param   {Number}        [config.collectionBatchSize]        The number of items to process at a time when collecting bucketed activities. Defaults to 500
 * @param   {Boolean}       [config.allowAnonCollection]        Determines whether or not an anonymous user can invoke a collection. Defaults to false.
 * @param   {Function}      [callback]                          Invoked when the configuration has been refreshed
 * @param   {Object}        [callback.err]                      An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(config, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    config = ActivityConfig.refreshConfiguration(config);

    log().trace({'config': config}, 'Refreshing activity configuration.');

    // Reset the collection polling interval
    clearInterval(collectionPollingTimer);
    if (config.processActivityJobs && config.collectionPollingFrequency > 0) {
        // Delegate to the aggregator to collect/aggregate all buckets
        collectionPollingTimer = setInterval(ActivityAggregator.collectAllBuckets, config.collectionPollingFrequency);
    }

    // Enable / Disable the worker binding, if necessary
    if (config.processActivityJobs && !boundWorker) {
        boundWorker = true;
        // Bind directly to the `routeActivity` router method
        return MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, ActivityRouter.routeActivity, callback);
    } else if (!config.processActivityJobs && boundWorker) {
        boundWorker = false;
        return MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        return callback();
    }
};

/**
 * Registers an activity type with the application. While not all activities that are posted are required to be registered here,
 * this is how special activity behaviour, such as aggregation pivot points, may be specified.
 *
 * # `options.groupBy`
 *
 * The groupBy option allows the ability control how an activity is aggregated in an activity feed. It takes an array of objects
 * that specify all the "pivot points" on which activity entities will be collected. If an activity has no pivot points configured
 * for it with this option, then the activity will never aggregate and collect. However it will still be protected from duplicates
 * that occur within the aggregation window, by updating the existing activity and moving it to the top of the feed as the most
 * recent activity. Following are some configuration examples.
 *
 * ## Example 1
 *
 * ```javascript
 *  options.groupBy = [
 *      {
 *          'actor': true,
 *          'object': true
 *      }
 *  ];
 * ```
 *
 * This option specifies that if multiple activities of this type are delivered to a route that share the same "actor" and "object"
 * entity, they will be rolled up into one activity, where the "target" is a collection of the different targets involves in the
 * two activities. For example:
 *
 * Activity #1: Branden shared Syllabus with GroupA
 * Activity #2: Branden shared Syllabus with UserB
 *
 * If those activities are delivered to the same route within a configurable window of time, they will be grouped together as
 * something like "Branden shared syllabus with 2 users and groups".
 *
 * ## Example 2
 *
 * ```javascript
 *  options.groupBy = [
 *      {
 *          'actor': true,
 *          'object': true
 *      },
 *      {
 *          'actor': true,
 *          'target': true
 *      }
 *  ];
 * ```
 *
 * In this scenario, an activity will be pivoted on TWO different combinations of entities: actor+object and actor+target. This
 * enables the ability to maintain 2 separate aggregation branches for the activity. For example:
 *
 * Activity #1: Branden shared Syllabus with GroupA
 * Activity #2: Branden shared Syllabus with GroupB
 * Activity #3: Branden shared Introduction with Group A
 *
 * If those activities are delivered to the same route within a configurable window of time, they will be grouped together and
 * delivered as 2 separate aggregate activities (instead of the 3 activities):
 *
 * Aggregate #1: Branden shared 2 items with Group A
 * Aggregate #2: Branden shared Syllabus with 2 users and groups
 *
 * @param   {String}    activityType    The type of activity to register
 * @param   {Object}    options         The options which specify how the activities of this type behave
 * @param   {Object[]}  options.groupBy An array of objects which specify on which entities to pivot to activate activity aggregates
 */
var registerActivityType = module.exports.registerActivityType = function(activityType, options) {
    ActivityAggregator.registerActivityType(activityType, options);
};

/**
 * Register an activity router. The activity router is responsible for determining where a set of activity entity data (as
 * produced by the entity producer) and determining to which feeds it should be routed. Additionally, it specifies how the
 * the entity data can be propagated to other streams to which the activity is delivered.
 *
 * The `propagation` rule specifies how the activity entity information should be propagated across the different activity
 * routes. The propagation `type` values signify the following:
 *
 * * `ActivityConstants.entityPropagation.ALL`: The data in the activity entity will be propagated to *all* routes that are generated for the activity, including all other entity routes that are part of the activity. This is suitable for public entities.
 * * `ActivityConstants.entityPropagation.ROUTES`: The data in the activity entity will be propagated to only the routes that are produced for the entity. This is the default propagation if no propagation is specified by the router.
 * * `ActivityConstants.entityPropagation.SPECIFY`: The data in the activity entity will be propgated to only the feeds that are specified by the additional `specify` parameter. This differs from `ROUTES` in that it provides the ability to propagate to feeds that are not in the entities direct set of routes.
 *
 * @param   {String}         resourceType                           The type of resource this router is meant to route (e.g., content, comment, user...)
 * @param   {Function}       router                                 The function that determine the routes and propagation of the entity
 * @param   {String}         router.activityType                    The type of activity being routed
 * @param   {String}         router.entityType                      The entity type for which this object is being routed. One of actor, object or target
 * @param   {ActivityEntity} router.persistentEntity                The activity entity data that was produced for the resource
 * @param   {Function}       router.callback                        The function to invoke when the object has been produced
 * @param   {Object}         router.callback.err                    An error that occurred, if any
 * @param   {String[]}       router.callback.routes                 The routes to which the activity should be delivered
 * @param   {Object}         [router.callback.propagation]          How the entity data should be propagated among activity routes
 * @param   {String}         [router.callback.propagation.type]     The propagation behaviour, as enumerated by `ActivityConstants.entityPropagation`. Defaults to `ROUTES`.
 * @param   {String[]}       [router.callback.propagation.specify]  The routes to which to propagate if the propagation `type` is `SPECIFY`.
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    ActivityRouter.registerActivityRouter(resourceType, router);
};

/**
 * Register an activity producer for a type of resource. The activity entity producer is responsible for gathering the data that
 * will be necessary to transform it into an ActivityEntity when an activity feed is requested. This model is persisted into the
 * stream, and the `entityTransformer` will be responsible for taking this data and converting it into the ActivityEntity object
 * that is suitable to be displayed in the activity stream.
 *
 * @param   {String}        resourceType                        The type of resource this producer is meant to produce activity objects for (e.g., content, comment, user...)
 * @param   {Function}      producer                            The function that will convert the resource object into entity data
 * @param   {String}        producer.activityType               The type of activity being generated
 * @param   {String}        producer.entityType                 The entity type for which this entity is being produced. One of actor, object or target
 * @param   {String}        producer.resource                   The resource seed object that describes the resource to use to generate the entity data
 * @param   {Function}      producer.callback                   Invoked when the process has completed
 * @param   {Object}        producer.callback.err               An error that occurred, if any
 * @param   {Object}        producer.callback.persistentEntity  The activity entity data that was produced
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    ActivityRouter.registerActivityEntityProducer(resourceType, producer);
};

/**
 * Register an activity entity transformer for a type of resource. The entity transformer is responsible for taking the entity
 * data that produced by the activity entity producer, and generating the ActivityEntity for the current request. Since this
 * transformer is invoked for every entity for every activity stream request, it is important to do as little heavy-lifting
 * here as possible, and rather defer as much work to the producer as possible, as the data is only produced once per activity.
 *
 * The `activityEntities` parameter is a breakdown of all the entities of the appropriate `resourceType` in the current set of
 * activities being transformed. This object is structured like so:
 *
 * ```javascript
 * {
 *      'activityId0': {
 *          'resourceId0': { <Produced Entity Data> },
 *          'resourceId1': { <Produced Entity Data> }
 *      },
 *      'activityId1': {
 *          'resourceId0': { <Produced Entity Data> },
 *          'resourceId2': { <Produced Entity Data> },
 *          'resourceId3': { <Produced Entity Data> }
 *      }
 * }
 * ```
 *
 * Similarly, the `transformedActivityEntities` that are returned by the transformer are in the same format, except the
 * <Produced Entity Data> would be replaced with the <Transformed Entity>.
 *
 * Why is the entity data discriminated by activity id *and* resource id? It is technically possible for an entity to be
 * generated with different data depending on the activty type and its context. Therefore, if we assume one collection of
 * entities will be the same for all activities, then we could have invalid transformations in some activities. That said,
 * it is important to keep transformed entities keyed by the activity to which they belong.
 *
 * @param   {String}        resourceType                                     The type of resource this transformer is transforming for the UI
 * @param   {Function}      transformer                                      The function that will transform the entity data to an `ActivityEntity` for the UI
 * @param   {Context}       transformer.ctx                                  The context of the request that is accessing the activity feed
 * @param   {Object}        transformer.activityEntities                     An object representing the activity entity data that should be transformed. See summary for more information
 * @param   {Function}      transformer.callback                             Invoked when the process completes
 * @param   {Object}        transformer.callback.err                         An error that occurred, if any
 * @param   {Object}        transformer.callback.transformedActivityEntities The transformed activity entities, suitable to be delivered to the user in the activity stream. See summary for more information
 */
var registerActivityEntityTransformer = module.exports.registerActivityEntityTransformer = function(resourceType, transformer) {
    ActivityTransformer.registerActivityEntityTransformer(resourceType, transformer);
};


////////////////////////////////
// GETTING AN ACTIVITY STREAM //
////////////////////////////////

/**
 * Get the activity stream by the specified id.
 *
 * @param   {Context}       ctx                 The context of the current session
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(ctx, activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    }

    // If we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Internal function to get an activity stream by its ID. This bypasses permission checks.
 *
 * @param   {Context}           ctx                     The context of the current request
 * @param   {String}            activityStreamId        The ID of the activity stream to fetch
 * @param   {Number}            start                   The starting timestamp of the activities to fetch
 * @param   {Number}            limit                   The number of activities to fetch
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {ActivityStream}    callback.activityStream The activity stream
 * @api private
 */
var _getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities) {
        if (err) {
            return callback(err);
        }

        ActivityTransformer.transformActivities(ctx, activities, function(err) {
            if (err) {
                return callback(err);
            }

            // Wrap the transformed activities in a stream
            return callback(null, new ActivityStream(activities));
        });
    });
};

///////////////////////////////////////
// POSTING ACTIVITIES FOR COLLECTION //
///////////////////////////////////////

/**
 * Post an activity in the system to be routed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param   {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param   {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity.');
        }
    };

    var validator = new Validator();

    // Validate top-level activity properties
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    if (activitySeed) {
        validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
        validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();
        validator.check(activitySeed.published, {'code': 400, 'msg': 'Activity seed did not have a valid publish date.'}).isNumeric();

        // Validate the actor resource
        validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
        if (activitySeed.actorResource) {
            validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();
        }
        
        // Validate the object resource
        if (activitySeed.objectResource) {
            validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
        }

        // Validate the target resource
        if (activitySeed.targetResource) {
            validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
            validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
        }
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

/**
 * Perform a full collection of all activity buckets. If any bucket is already locked by another process, it will be skipped. When
 * this process completes and the callback is invoked, it will guarantee that:
 *
 * a) This process was not allowed to start another collection cycle, as there were too many occuring; or
 * b) for every bucket that wasn't locked, it was collected until it was empty.
 *
 * This is most useful for unit tests to ensure that all activities up until a point in time have been aggregated and delivered.
 *
 * @param   {Context}   ctx             The context of the request.
 * @param   {Function}  callback        Invoked when collection is complete.
 * @param   {Object}    callback.err    An error that occurred, if any.
 */
var collect = module.exports.collect = function(ctx, callback) {
    if (ActivityConfig.getConfig().allowAnonCollection) {
        return ActivityAggregator.collectAllBuckets(callback);
    }

    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        return ActivityAggregator.collectAllBuckets(callback);
    }

    return callback({'code': 401, 'msg': 'Only admin can manually trigger a collection'});
};

