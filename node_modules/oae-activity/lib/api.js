/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var crypto = require('crypto');
var events = require('events');
var log = require('oae-logger').logger('oae-activity');
var MQ = require('oae-util/lib/mq');
var OaeUtil = require('oae-util/lib/util');
var ShortId = require('shortid');
var Telemetry = require('oae-telemetry').telemetry('activity');
var util = require('util');
var Validator = require('oae-authz/lib/validator').Validator;

var Activity = require('oae-activity/lib/model').Activity;
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityCluster = require('./internal/cluster');
var ActivityDAO = require('./internal/dao');
var ActivityEntity = require('oae-activity/lib/model').ActivityEntity;
var ActivityStream = require('oae-activity/lib/model').ActivityStream;

var DEFAULT_ACTIVITY_TTL = 2 * 7 * 24 * 60 * 60;
var DEFAULT_AGGREGATE_IDLE_EXPIRY = 3 * 60 * 60 * 1000;
var DEFAULT_AGGREGATE_MAX_EXPIRY = 24 * 60 * 60 * 1000;
var DEFAULT_NUMBER_OF_PROCESSING_BUCKETS = 5;
var DEFAULT_COLLECTION_EXPIRY = 60 * 1000;
var DEFAULT_MAX_CONCURRENT_COLLECTIONS = 3;
var DEFAULT_COLLECTION_POLLING_FREQUENCY = 5 * 1000;
var DEFAULT_COLLECTION_BATCH_SIZE = 500;
var DEFAULT_ALLOW_ANON_COLLECTION = false;
var ENTITY_KEY_EMPTY = '__null__';

var activityTypes = {};
var activityProducers = {};
var activityTransformers = {};
var activityRouters = {};

var boundWorker = false;
var numberOfProcessingBuckets = DEFAULT_NUMBER_OF_PROCESSING_BUCKETS;
var aggregateIdleExpiry = DEFAULT_AGGREGATE_IDLE_EXPIRY;
var aggregateMaxExpiry = DEFAULT_AGGREGATE_MAX_EXPIRY;
var collectionExpiry = DEFAULT_COLLECTION_EXPIRY;
var maxConcurrentCollections = DEFAULT_MAX_CONCURRENT_COLLECTIONS;
var collectionPollingFrequency = DEFAULT_COLLECTION_POLLING_FREQUENCY;
var collectionBatchSize = DEFAULT_COLLECTION_BATCH_SIZE;
var allowAnonCollection = DEFAULT_ALLOW_ANON_COLLECTION;

var collectionPollingTimer = null;

var currentConcurrentCollectionCount = 0;

var emitter = module.exports = new events.EventEmitter();

/**
 * Refresh the activities configuration.
 *
 * @param   {Object}        [config]                            The object containing the configuration properties
 * @param   {Boolean}       [config.processActivityJobs]        Whether or not this server node should produce and route activities. Defaults to `true`
 * @param   {Number}        [config.activityTtl]                The time-to-live (in seconds) for generated activities. Defaults to 2 weeks
 * @param   {Number}        [config.aggregateIdleExpiry]        The amount of time (in milliseconds) an aggregate can be idle until it expires. Defaults to 3 hours
 * @param   {Number}        [config.aggregateMaxExpiry]         An upper-bound on the amount of time (in milliseconds) for which an aggregate can live. Defaults to 1 day
 * @param   {Number}        [config.numberOfProcessingBuckets]  The number of buckets available for parallel processing of activities. Defaults to 5
 * @param   {Number}        [config.collectionExpiry]           The maximum amount of time (in milliseconds) a processing bucket can be locked for at one time. Defaults to 1 minute
 * @param   {Number}        [config.maxConcurrentCollections]   The maximum number of concurrent collection cycles that can be active on a process at once. Defaults to 3
 * @param   {Number}        [config.collectionPollingFrequency] How often (in milliseconds) the processing buckets are polled for new activities. If -1, polling will be disabled. Defaults to 5 seconds
 * @param   {Number}        [config.collectionBatchSize]        The number of items to process at a time when collecting bucketed activities. Defaults to 500
 * @param   {Boolean}       [config.allowAnonCollection]        Determines whether or not an anonymous user can invoke a collection. Defaults to false.
 * @param   {Function}      [callback]                          Invoked when the configuration has been refreshed
 * @param   {Object}        [callback.err]                      An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(config, callback) {
    config = config || {};
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    var processActivityJobs = (config.processActivityJobs !== false);
    var activityTtl = OaeUtil.getIntParam(config.activityTtl, DEFAULT_ACTIVITY_TTL);
    numberOfProcessingBuckets = OaeUtil.getIntParam(config.numberOfProcessingBuckets, DEFAULT_NUMBER_OF_PROCESSING_BUCKETS);
    aggregateIdleExpiry = OaeUtil.getIntParam(config.aggregateIdleExpiry, DEFAULT_AGGREGATE_IDLE_EXPIRY);
    aggregateMaxExpiry = OaeUtil.getIntParam(config.aggregateMaxExpiry, DEFAULT_AGGREGATE_MAX_EXPIRY);
    collectionExpiry = OaeUtil.getIntParam(config.collectionExpiry, DEFAULT_COLLECTION_EXPIRY);
    maxConcurrentCollections = OaeUtil.getIntParam(config.maxConcurrentCollections, DEFAULT_MAX_CONCURRENT_COLLECTIONS);
    collectionPollingFrequency = OaeUtil.getIntParam(config.collectionPollingFrequency, DEFAULT_COLLECTION_POLLING_FREQUENCY);
    collectionBatchSize = OaeUtil.getIntParam(config.collectionBatchSize, DEFAULT_COLLECTION_BATCH_SIZE);
    allowAnonCollection = (config.allowAnonCollection === true);

    log().trace({
        'processActivityJobs': processActivityJobs,
        'activityTtl': activityTtl,
        'numberOfProcessingBuckets': numberOfProcessingBuckets,
        'aggregateIdleExpiry': aggregateIdleExpiry,
        'aggregateMaxExpiry': aggregateMaxExpiry,
        'collectionExpiry': collectionExpiry,
        'maxConcurrentCollections': maxConcurrentCollections,
        'collectionPollingFrequency': collectionPollingFrequency,
        'allowAnonCollection': allowAnonCollection
    }, 'Refreshing activity configuration.');

    // Push the TTL into the DAO
    ActivityDAO.refreshConfiguration(activityTtl);

    clearInterval(collectionPollingTimer);

    // Enable / Disable the worker binding, if necessary
    if (processActivityJobs && !boundWorker) {
        boundWorker = true;

        // Only restart the collection interval if polling frequency is above 0
        if (collectionPollingFrequency > 0) {
            collectionPollingTimer = setInterval(_collect, collectionPollingFrequency);
        }

        return MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, _handleActivityTask, callback);
    } else if (!processActivityJobs && boundWorker) {
        boundWorker = false;
        return MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        return callback();
    }
};

var registerActivityType = module.exports.registerActivityType = function(activityType, groupBy) {
    if (activityTypes[activityType]) {
        throw new Error('Attempted to register duplicate activity type');
    }
    activityTypes[activityType] = {'groupBy': groupBy};
};

/**
 * Register an activity producer. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityEntity that can be used in an activity.
 *
 * The activity entity `propagation` rule specifies how the activity entity information should be propagated across the different
 * routes. The values signify the following:
 *
 * * `ActivityConstants.entityPropagation.ALL`: The data in the activity entity will be propagated to *all* routes that are generated for the current entity, and all other entity routes that are part of the activity
 * * `ActivityConstants.entityPropagation.OWN`: The data in the activity entity will be propagated to only the routes that are produced for the entity
 *
 * @param   {String}         resourceType                     The type of resource this producer is meant to produce activity objects for (e.g., content, comment, user...)
 * @param   {Function}       producer                         The function that will convert the resource object into an activity object
 * @param   {String}         producer.activityType            The type of activity being generated
 * @param   {String}         producer.entityType              The entity type for which this entity is being produced. One of actor, object, target
 * @param   {String}         producer.resource                The resource seed object that describes the resource to use to generate the activity object
 * @param   {Function}       producer.callback                The function to invoke when the object has been produced
 * @param   {Object}         producer.callback.err            An error that occurred, if any
 * @param   {ActivityEntity} producer.callback.activityEntity The activity object that was produced
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    if (activityProducers[resourceType]) {
        throw new Error('Attempted to register duplicate activity producer');
    }
    activityProducers[resourceType] = producer;
};

var registerActivityEntityTransformer = module.exports.registerActivityEntityTransformer = function(resourceType, transformer) {
    if (activityTransformers[resourceType]) {
        throw new Error('Attempted to register duplicate activity transformer');
    }
    activityTransformers[resourceType] = transformer;
};

/**
 * Register an activity router. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityEntity that can be used in an activity.
 *
 * @param   {String}         resourceType                           The type of resource this router is meant to route (e.g., content, comment, user...)
 * @param   {Function}       router                                 The function that will convert the resource object into an activity object
 * @param   {String}         router.activityType                    The type of activity being routed
 * @param   {String}         router.entityType                      The entity type for which this object is being routed. One of actor, object, target
 * @param   {ActivityEntity} router.activityEntity                  The activity object model that was produced for the resource
 * @param   {Function}       router.callback                        The function to invoke when the object has been produced
 * @param   {Object}         router.callback.err                    An error that occurred, if any
 * @param   {String[]}       router.callback.routes                 The routes to which the activity should be delivered
 * @param   {Object}         [router.callback.propagation]          How the entity should be propagated among activity routes.
 * @param   {String}         [router.callback.propagation.type]     One of the options enumerated by `ActivityConstants.entityPropagation`. Defaults to `ROUTES`.
 * @param   {String[]}       [router.callback.propagation.specify]  The routes to which to propagate if the propagation `type` is `SPECIFY`.
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    if (activityRouters[resourceType]) {
        throw new Error('Attempted to register duplicate activity router');
    }
    activityRouters[resourceType] = router;
};



////////////////////////////////
// GETTING AN ACTIVITY STREAM //
////////////////////////////////

/**
 * Get the activity stream by the specified id.
 *
 * @param   {Context}       ctx                 The context of the current session
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(ctx, activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(ctx, activityStreamId, start, limit, callback);
    }

    // If we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Internal function to get an activity stream by its ID. This bypasses permission checks.
 *
 * @param   {Context}           ctx                     The context of the current request
 * @param   {String}            activityStreamId        The ID of the activity stream to fetch
 * @param   {Number}            start                   The starting timestamp of the activities to fetch
 * @param   {Number}            limit                   The number of activities to fetch
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {ActivityStream}    callback.activityStream The activity stream
 * @api private
 */
var _getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities) {
        if (err) {
            return callback(err);
        }

        var activityEntitiesByObjectType = {};
        var transformedActivityEntitiesByObjectType = {};

        // Collect and index all the entities to be transformed by objectType -> activityId -> entityId
        activities.forEach(function(activity) {
            var activityId = activity[ActivityConstants.properties.OAE_ACTIVITY_ID];
            _collectActivityEntitiesByObjectType(activityId, activity.actor, activityEntitiesByObjectType);
            _collectActivityEntitiesByObjectType(activityId, activity.object, activityEntitiesByObjectType);
            _collectActivityEntitiesByObjectType(activityId, activity.target, activityEntitiesByObjectType);
        });

        var objectTypes = _.keys(activityEntitiesByObjectType);
        var errOccurred = null;
        var numProcessed = 0;

        /*!
         * Handles the callback for when a set of entities for an object type have been transformed.
         */
        var _handleTransform = function(err, objectType, transformedActivityEntities) {
            if (errOccurred) {
                // Do nothing because we've already err'd
                return;
            } else if (err) {
                errOccurred = err;
                return callback(err);
            }

            // Record the transformed entities
            transformedActivityEntitiesByObjectType[objectType] = transformedActivityEntities;

            numProcessed++;
            if (numProcessed === objectTypes.length) {
                _transformActivities(transformedActivityEntitiesByObjectType, activities);
                return callback(null, new ActivityStream(activities));
            }
        };

        // Transform all entities of each object type and activity
        if (objectTypes.length > 0) {
            objectTypes.forEach(function(objectType) {
                if (!activityTransformers[objectType]) {
                    log().warn('No activity transformer found for objectType "%s"', objectType);
                    return _handleTransform(null, objectType, {});
                }

                activityTransformers[objectType](ctx, activityEntitiesByObjectType[objectType], function(err, transformedActivityEntities) {
                    if (err) {
                        return callback(err);
                    }

                    // Ensure all transformed entities have at least the objectType and the oae:id
                    _.keys(transformedActivityEntities).forEach(function(activityId) {
                        _.keys(transformedActivityEntities[activityId]).forEach(function(entityId) {
                            transformedActivityEntities[activityId][entityId].objectType = objectType;
                            transformedActivityEntities[activityId][entityId][ActivityConstants.properties.OAE_ID] = entityId;
                        });
                    });

                    return _handleTransform(err, objectType, transformedActivityEntities);
                });
            });
        } else {
            return callback(null, new ActivityStream(activities));
        }
    });
};

var _collectActivityEntitiesByObjectType = function(activityId, entity, activityEntitiesByObjectType) {
    if (entity && entity.objectType !== 'collection') {
        activityEntitiesByObjectType[entity.objectType] = activityEntitiesByObjectType[entity.objectType] || {};
        activityEntitiesByObjectType[entity.objectType][activityId] = activityEntitiesByObjectType[entity.objectType][activityId] || {};
        activityEntitiesByObjectType[entity.objectType][activityId][entity[ActivityConstants.properties.OAE_ID]] = entity;
    } else if (entity) {
        // This is actually a collection of more entities. Iterate and collect them.
        entity[ActivityConstants.properties.OAE_COLLECTION].forEach(function(entity) {
            activityEntitiesByObjectType[entity.objectType] = activityEntitiesByObjectType[entity.objectType] || {};
            activityEntitiesByObjectType[entity.objectType][activityId] = activityEntitiesByObjectType[entity.objectType][activityId] || {};
            activityEntitiesByObjectType[entity.objectType][activityId][entity[ActivityConstants.properties.OAE_ID]] = entity;
        });
    }
};

var _transformActivities = function(transformedActivityEntitiesByObjectType, activities) {
    activities.forEach(function(activity) {
        var activityId = activity[ActivityConstants.properties.OAE_ACTIVITY_ID];
        activity.actor = _transformEntity(transformedActivityEntitiesByObjectType, activityId, activity.actor);
        activity.object = _transformEntity(transformedActivityEntitiesByObjectType, activityId, activity.object);
        activity.target = _transformEntity(transformedActivityEntitiesByObjectType, activityId, activity.target);
    });
};

var _transformEntity = function(transformedActivityEntitiesByObjectType, activityId, entity) {
    if (!entity) {
        return entity;
    }

    var entityId = entity[ActivityConstants.properties.OAE_ID];
    if (entity.objectType !== 'collection') {
        return transformedActivityEntitiesByObjectType[entity.objectType][activityId][entityId];
    } else {
        var transformedCollection = [];
        entity[ActivityConstants.properties.OAE_COLLECTION].forEach(function(collectionEntity) {
            var transformedEntity = _transformEntity(transformedActivityEntitiesByObjectType, activityId, collectionEntity);
            if (transformedEntity) {
                transformedCollection.push(transformedEntity);
            }
        });
        entity[ActivityConstants.properties.OAE_COLLECTION] = transformedCollection;
        return entity;
    }

    return undefined;
};

////////////////////////////////////
// POSTING AND ROUTING ACTIVITIES //
////////////////////////////////////

/**
 * Post an activity in the system to be routed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param   {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param   {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity.');
        }
    };

    var validator = new Validator();

    // Validate top-level activity properties
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
    validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();

    // Validate the actor resource
    validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
    validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
    validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();

    // Validate the object resource
    if (activitySeed.objectResource) {
        validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    // Validate the target resource
    if (activitySeed.targetResource) {
        validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

/**
 * Task handler to generate, route and queue activities when activity tasks are sent.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed that was used to post the activity
 * @param   {Function}      [callback]          Invoked when the process completes
 * @param   {Object}        [callback.err]      An error that occurred, if any
 * @api private
 */
var _handleActivityTask = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error handling activity.');
        }
    };

    log().trace({'activitySeed': activitySeed}, 'Handling activity task.');

    // Will aggregate all the activityStreamId (i.e., route) -> activity pairings that will be delivered
    var routedActivities = {};
    var activityId = _createActivityId(activitySeed.published);
    var routingStart = Date.now();

    // Produce all of the activity entities
    _produceAllEntities(activitySeed, function(err, actor, object, target) {
        if (err) {
            return callback(err);
        }

        // Produce the routes for the actor, object and target entities
        _produceAllRoutes(activitySeed, actor, object, target, function(err, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation) {
            if (err) {
                return callback(err);
            }

            // 1. Create all routes and apply the "ROUTES" propagation entities, also apply minimum data for entities that may not be propagated
            for (var i = 0; i < actorRoutes.length; i++) {
                var actorRoute = actorRoutes[i];
                routedActivities[actorRoute] = routedActivities[actorRoute] || {};
                if (actorPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[actorRoute].actor = actor;
                }
            }

            for (i = 0; i < objectRoutes.length; i++) {
                var objectRoute = objectRoutes[i];
                routedActivities[objectRoute] = routedActivities[objectRoute] || {};
                if (objectPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[objectRoute].object = object;
                }
            }

            for (i = 0; i < targetRoutes.length; i++) {
                var targetRoute = targetRoutes[i];
                routedActivities[targetRoute] = routedActivities[targetRoute] || {};
                if (targetPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[targetRoute].target = target;
                }
            }

            // 2. Fill activity data, including the "ALL" propagation entities, as well as minimum data for entities that are not routed
            _.values(routedActivities).forEach(function(activity) {

                // Also use this loop to put all the activity-level properties onto each activity
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activitySeed.activityType;
                activity[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                activity.verb = activitySeed.verb;
                activity.published = activitySeed.published;

                // Backfill the appropriate actor data (there should always be an actor associated to the activity)
                if (activitySeed.actorResource && actorPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.actor = actor;
                } else if (activitySeed.actorResource) {
                    activity.actor = {};
                    activity.actor.objectType = activitySeed.actorResource.resourceType;
                    activity.actor[ActivityConstants.properties.OAE_ID] = activitySeed.actorResource.resourceId;
                }

                // Backfill the appropriate object data if there was an object associated to the activity
                if (activitySeed.objectResource && objectPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.object = object;
                } else if (activitySeed.objectResource) {
                    activity.object = {};
                    activity.object.objectType = activitySeed.objectResource.resourceType;
                    activity.object[ActivityConstants.properties.OAE_ID] = activitySeed.objectResource.resourceId;
                }

                // Backfill the appropriate target data if there was a target associated to the activity
                if (activitySeed.targetResource && targetPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.target = target;
                } else if (activitySeed.targetResource) {
                    activity.target = {};
                    activity.target.objectType = activitySeed.targetResource.resourceType;
                    activity.target[ActivityConstants.properties.OAE_ID] = activitySeed.targetResource.resourceId;
                }
            });

            // 3. Apply the "SPECIFY" propagation entities where possible
            if (activitySeed.actorResource && actorPropagation.type === ActivityConstants.entityPropagation.SPECIFY && actorPropagation.specify) {
                actorPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].actor = actor;
                    }
                });
            }

            if (activitySeed.objectResource && objectPropagation.type === ActivityConstants.entityPropagation.SPECIFY && objectPropagation.specify) {
                objectPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].object = object;
                    }
                });
            }

            if (activitySeed.targetResource && targetPropagation.type === ActivityConstants.entityPropagation.SPECIFY && targetPropagation.specify) {
                targetPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].target = target;
                    }
                });
            }

            log().trace({
                'activitySeed': activitySeed,
                'routedActivities': routedActivities
            }, 'Queueing activities to be routed.');

            // Queue the activity entities to be collected and aggregated
            _queueActivities(activitySeed, routedActivities, function(err, buckets) {
                if (err) {
                    return callback(err);
                }

                Telemetry.appendDuration('activity.routing.time', routingStart);
                return callback();
            });
        });
    });
};


/**
 * Produce activity entities based on the actor, object and target resources of the given activity seed.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed from which to extract the actor, object and target resource information
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {ActivityEntity}    callback.actor              The actor activity entity
 * @param   {String}            callback.actorPropagation   The actor entity propagation rule
 * @param   {ActivityEntity}    callback.object             The object activity entity
 * @param   {String}            callback.objectPropagation  The object entity propagation rule
 * @param   {ActivityEntity}    callback.target             The actor activity entity
 * @param   {String}            callback.targetPropagation  The actor entity propagation rule
 * @api private
 */
var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, object, target);
            });
        });
    });
};

/**
 * Produce an activity entity with the given seed resource information.
 *
 * @param   {String}                activityType            The type of activity for which the entity is being produced
 * @param   {String}                entityType              The type of entity for which the entity is being produced (i.e., actor, object or target)
 * @param   {ActivitySeedResource}  resource                The activity resource that was used to seed the activity
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {ActivityEntity}        callback.activityEntity The activity entity that was produced
 * @param   {String}                callback.propagation    A rule specifying how the activity entity should be propagated across the routes. The possible values are enumerated by `ActivityConstants.entityPropagation`
 * @api private
 */
var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    var producer = activityProducers[resource.resourceType];
    if (!producer) {
        log().error({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource
        }, 'No activity producer found for activity entity.');
        return callback({'code': 500, 'msg': 'No activity producer found for resource type "' + resource.resourceType + '"'});
    }

    producer(activityType, entityType, resource, function(err, entity, propagation) {
        if (err) {
            return callback(err);
        }

        // Ensure a valid resource id and resource type
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity);
    });
};

/**
 * Produce the routes for the given actor, object and target activity entities.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed that was used to post the activity
 * @param   {ActivityEntity}    actor                       The actor entity that was produced for the activity
 * @param   {ActivityEntity}    object                      The object entity that was produced for the activity
 * @param   {ActivityEntity}    target                      The target entity that was produced for the activity
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {String[]}          callback.actorRoutes        The routes to which to route the activity for the actor
 * @param   {Object}            callback.actorPropagation   How to propagate the actor entity among activity routes
 * @param   {String[]}          callback.objectRoutes       The routes to which to route the activity for the object
 * @param   {Object}            callback.objectPropagation  How to propagate the object entity among activity routes
 * @param   {String[]}          callback.targetRoutes       The routes to which to route the activity for the target
 * @param   {Object}            callback.targetPropagation  How to propagate the target entity among activity routes
 * @api private
 */
var _produceAllRoutes = function(activitySeed, actor, object, target, callback) {
    log().trace({'activitySeed': activitySeed}, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, actor, function(err, actorRoutes, actorPropagation) {
        if (err) {
            return callback(err);
        }

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, object, function(err, objectRoutes, objectPropagation) {
            if (err) {
                return callback(err);
            }

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, target, function(err, targetRoutes, targetPropagation) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation);
            });
        });
    });
};

/**
 * Produce the routes for the activity entity.
 *
 * @param   {String}                activityType            The type of activity being routed
 * @param   {String}                entityType              The type of entity for which activities are being routed (e.g., actor, object, target)
 * @param   {ActivityEntity}        entity                  The entity for which to produce the routes
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {String[]}              callback.routes         The routes to which to route the activity
 * @param   {Object}                callback.propagation    How to propagate the entity among the activity routes
 * @api private
 */
var _produceRoutes = function(activityType, entityType, entity, callback) {
    if (!entity) {
        return callback(null, []);
    }

    var router = activityRouters[entity.objectType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, entity, function(err, routes, propagation) {
        if (err) {
            return callback(err);
        }

        routes = routes || [];

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity,
            'routes': routes,
            'propagation': propagation
        }, 'Generated routes for activity entity.');
        
        propagation = propagation || {'type': ActivityConstants.entityPropagation.ROUTES};

        return callback(null, routes, propagation);
    });
};

/**
 * Queue the given set of routed activities for collection.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed from which the activities were generated.
 * @param   {Object}        routedActivities    A hash whose value is the activity to deliver, where the key is the route to which the activity should be delivered.
 * @param   {Function}      callback            Invoked when the routed activities have been queued
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Number[]}      callback.buckets    The collection buckets that received activities as a result of this invocation
 * @api private
 */
var _queueActivities = function(activitySeed, routedActivities, callback) {
    var allRoutes = _.keys(routedActivities);
    var activityBuckets = [];

    allRoutes.forEach(function(route) {
        // Assign all activities to their processing buckets to support safe concurrency
        var bucketNumber = _getBucketNumber(route, activitySeed);
        activityBuckets[bucketNumber] = activityBuckets[bucketNumber] || [];
        activityBuckets[bucketNumber].push({
            'route': route,
            'activity': routedActivities[route]
        });
    });

    // Queue the aggregates into their associated buckets to indicate they need to be collected and delivered
    ActivityDAO.saveQueuedActivities(activityBuckets, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.keys(activityBuckets));
    });
};




///////////////////////////////////////////
// COLLECTING AND AGGREGATING ACTIVITIES //
///////////////////////////////////////////

/**
 * Perform a full collection of all activity buckets. If any bucket is already locked by another process, it will be skipped. When
 * this process completes and the callback is invoked, it will guarantee that:
 *
 * a) This process was not allowed to start another collection cycle, as there were too many occuring; or
 * b) for every bucket that wasn't locked, it was collected until it was empty.
 *
 * This is most useful for unit tests to ensure that all activities up until a point in time have been aggregated and delivered.
 *
 * @param   {Context}   ctx             The context of the request.
 * @param   {Function}  callback        Invoked when collection is complete.
 * @param   {Object}    callback.err    An error that occurred, if any.
 */
var collect = module.exports.collect = function(ctx, callback) {
    if (allowAnonCollection) {
        return _collect(callback);
    }

    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        return _collect(callback);
    }

    return callback({'code': 401, 'msg': 'Only admin can manually trigger a collection'});
};

/**
 * Perform a full collection of all activity buckets. If any bucket is already locked by another process, it will be skipped. When
 * this process completes and the callback is invoked, it will guarantee that:
 *
 * a) This process was not allowed to start another collection cycle, as there were too many occuring; or
 * b) for every bucket that wasn't locked, it was collected until it was empty.
 *
 * This is most useful for unit tests to ensure that all activities up until a point in time have been aggregated and delivered.
 *
 * @param   {Function}  callback        Invoked when collection is complete.
 * @api private
 */
var _collect = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error collecting aggregates.');
        }
    };

    // Ensure we don't surpass the configured number of concurrent collections
    if (currentConcurrentCollectionCount >= maxConcurrentCollections) {
        log().trace('Aborting collection due to max concurrent collections count reached.');
        return callback();
    }
    currentConcurrentCollectionCount++;

    // Fill all the possible bucket numbers to collect
    var bucketNumbers = [];
    for (var i = 0; i < numberOfProcessingBuckets; i++) {
        bucketNumbers.push(i);
    }

    log().trace('Beginning collection of %s buckets.', bucketNumbers.length);

    // Perform a collection cycle on the bucket numbers
    _collectBuckets(bucketNumbers, function() {
        log().trace('Completed collection cycle.');

        // Mark that this collection cycle has completed, whether or not there was an error
        currentConcurrentCollectionCount--;
        return callback();
    });
};

/**
 * Collects the given array of bucket numbers until they are empty, or "stolen". This process will skip over buckets that are
 * in the process of being collected. Therefore, if all buckets in the array are currently undergoing collection, this will not
 * actually perform any collections.
 *
 * @param   {Number[]}      bucketNumbers   The buckets that should be collected by this cycle.
 * @param   {Function}      callback        Invoked when the collection cycle completes.
 * @api private
 */
var _collectBuckets = function(bucketNumbers, callback) {
    if (bucketNumbers.length === 0) {
        return callback();
    }

    var bucketNumber = bucketNumbers.shift();
    _collectBucket(bucketNumber, function(err) {
        if (err) {
            log().warn({'err': err, 'bucketNumber': bucketNumber}, 'Error collecting aggregate bucket.');
            Telemetry.incr('collection.error.count');
        }

        _collectBuckets(bucketNumbers, callback);
    });
};

/**
 * Collect the provided bucket number until it is empty (or "stolen"). If the bucket is already being collected, this will
 * effectively do nothing.
 *
 * @param   {Number}    bucketNumber        The number of the bucket to collect.
 * @param   {Function}  callback            Invoked when collection is complete.
 * @param   {Object}    callback.err        An error that occurred, if any.
 * @api private
 */
var _collectBucket = function(bucketNumber, callback) {
    log().trace('Attempting collection of bucket number %s', bucketNumber);
    // Try and acquire a lock on the bucket to collect the next batch
    ActivityCluster.acquireBucket(bucketNumber, collectionExpiry, function(err, lockId) {
        if (lockId) {
            // We acquired the lock, perform a collection iteration
            _collectBucketBatch(bucketNumber, collectionBatchSize, function(collectionErr, empty) {
                // We want to ensure we release the bucket, whether we received an error or not
                ActivityCluster.releaseBucket(bucketNumber, lockId, function(releaseErr) {
                    if (collectionErr) {
                        return callback(collectionErr);
                    } else if (releaseErr) {
                        // If there was an error releasing the lock, worst case scenario would be that the lock eventually expires
                        // and a cluster node picks it up soon after that and continues processing.
                        return callback(releaseErr);
                    } else if (empty) {
                        // The bucket is now empty, return to the caller
                        return callback();
                    }

                    // The bucket isn't empty, try another collection iteration
                    return _collectBucket(bucketNumber, callback);
                });
            });
        } else {
            // We could not acquire a lock, someone else came around and managed to snag the bucket
            return callback();
        }
    });
};

/**
 * Collect and process a certain amount of routed activities from the given bucket. This method is *not safe* in the sense
 * that it does not try and first acquire a lock on the bucket. Do not use this directly, instead use `_collectBucket` which
 * in turn uses this method with locks.
 *
 * @param   {Number}    bucketNumber        The bucket to process.
 * @param   {Number}    limit               The number of routed activities to collect, process and deliver.
 * @param   {Function}  callback            Invoked when the batch has been processed.
 * @param   {Object}    callback.err        An error that occurred, if any.
 * @api private
 */
var _collectBucketBatch = function(bucketNumber, limit, callback) {
    var collectionStart = Date.now();
    log().trace('Collecting batch of %s entries from bucket number %s.', limit, bucketNumber);

    // Get the next batch of queued activities to process
    ActivityDAO.getQueuedActivities(bucketNumber, limit, function(err, routedActivities) {
        if (err) {
            return callback(err);
        }

        // These routed activities will be deleted by the internal id after they've been processed
        var queuedActivitiesToDelete = _.keys(routedActivities);
        var numCollected = queuedActivitiesToDelete.length;
        if (numCollected === 0) {
            // No more to process, so stop and report that we're empty.
            return callback(null, true);
        }

        // Explode the routed activities into their potential aggregates, according to their configured pivot points
        var allAggregates = _createAggregates(_.values(routedActivities));
        var allAggregateKeys = _.keys(allAggregates);

        // Get all aggregate statuses to determine which ones are expired and which are active
        // Expired aggregates should be deleted, while active aggregates should be merged and redelivered
        ActivityDAO.getAggregateStatus(allAggregateKeys, function(err, statusByAggregateKey) {
            if (err) {
                return callback(err);
            }

            // Figure out which aggregates are "active" (have an activity in its aggregate) and "expired" (no new activities in the aggregate before expiry time)
            var activeAggregates = {};
            var expiredAggregates = {};
            allAggregateKeys.forEach(function(aggregateKey) {
                var aggregate = allAggregates[aggregateKey];
                var status = statusByAggregateKey[aggregateKey];
                if (status && _isExpired(status, allAggregates[aggregateKey].published)) {
                    expiredAggregates[aggregateKey] = true;
                } else if (status) {
                    activeAggregates[aggregateKey] = true;
                }
            });

            // Note: We need to delete aggregated entities and save them here within the collection chain to avoid nuking undelivered
            // entities. If we saved aggregated entities during the routing phase and only deleted them here, it would save us a write
            // as we wouldn't have to write them to the queue, but it exposes a race condition where entities that are saved between
            // getAggregateStatus (above) and deleteAggregatedEntities (below) will be deleted before delivery.

            // Delete all the expired aggregates before aggregating new stuff
            ActivityDAO.deleteAggregates(_.keys(expiredAggregates), function(err) {
                if (err) {
                    return callback(err);
                }

                // Retrieve all entities that are aggregated within the live aggregates so they can be collected into redelivered activities
                ActivityDAO.getAggregatedEntities(_.keys(activeAggregates), function(err, fetchedEntities) {
                    if (err) {
                        return callback(err);
                    }

                    /*!
                     * Here we choose which aggregates need to be wrapped up into an activity and delivered to the activity stream. This is
                     * rather difficult to get right. These are the rules implemented below:
                     *
                     *  For a given activity (keyed by activityId):
                     *
                     * 1.   If an aggregate was previously active for it, it will always be re-delivered to the stream. If there was a previous
                     *      activity delivered for the aggregate, that activity is deleted.
                     *
                     * 2.   If there are multiple active aggregates for the activity, all should be delivered as they all have been updated this
                     *      means that if an activity has multiple aggregates, you could update the branched activities for *both* aggregates
                     *      (e.g., content-share). "Branching" means that 2 separate aggregations have started and are tracking two separate
                     *      activities in a feed.
                     *
                     *      How can an activity fall into two branches? For example, we have 2 live aggregates:
                     *
                     *          "Branden shared 5 content items with OAE Team" AND "Branden shared Syllabus with 5 Users and Groups"
                     *
                     *      Now, if Branden shares "Syllabus" with "OAE Team", you have triggered both of these "branches", and both activity
                     *      branches will be updated and moved to the top of the feed.
                     *
                     * 3.   An activity is only delivered for an inactive aggregate if the activity was not "claimed" for the route by an
                     *      active aggregate. This would make sure that we don't update a live aggregate, AND deliver the single activity
                     *      (e.g., "Branden shared Syllabus with OAE Team") in the same route.
                     *
                     * 4.   If no active aggregates claim an activity, and there are multiple inactive aggregates (e.g., the activity type has
                     *      multiple "pivot points"), then one activity is delivered for all of them. This is necessary to ensure that the
                     *      "lastActivityId" is recorded properly, and if one of those inactive aggregates becomes active later, the previous
                     *      activity can be properly deleted by either of the aggregates.
                     *
                     * 5.   If an activity gets "duplicated", it should not result in multiple activities, it should instead just update the
                     *      publish date and the content entities of the original activities.
                     */

                    // Mark all active aggregates to be delivered and
                    var aggregatesToDeliver = {};
                    var activitiesToDelete = {};
                    var claimedRouteActivities = {};
                    allAggregateKeys.forEach(function(aggregateKey) {
                        var aggregate = allAggregates[aggregateKey];
                        if (activeAggregates[aggregateKey] || aggregate.activityIds.length > 1) {
                            var status = statusByAggregateKey[aggregateKey];
                            
                            // Mark this to be delivered and assign it an activity id
                            aggregatesToDeliver[aggregateKey] = true;
                            aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID] = _createActivityId(aggregate.published);

                            // Mark these activities for this route as being claimed by an active aggregate
                            claimedRouteActivities[aggregate.route] = claimedRouteActivities[aggregate.route] || {};
                            aggregate.activityIds.forEach(function(activityId) {
                                claimedRouteActivities[aggregate.route][activityId] = true;
                            });

                            // If this was previously delivered, delete the previous activity
                            if (status && status.lastActivity) {
                                activitiesToDelete[aggregate.route] = activitiesToDelete[aggregate.route] || {};
                                activitiesToDelete[aggregate.route][status.lastActivity] = true;
                            }
                        }
                    });

                    // Second, for aggregates that are not active, determine if they can be delivered
                    allAggregateKeys.forEach(function(aggregateKey) {
                        var aggregate = allAggregates[aggregateKey];
                        // Any aggregate that had more than 1 activityId was claimed as active. We can safely just use the first
                        // activityId to get the activityId that represents this aggregate
                        var activityId = aggregate.activityIds[0];
                        var isActivityClaimed = (claimedRouteActivities[aggregate.route] && claimedRouteActivities[aggregate.route][activityId]);
                        if (!activeAggregates[aggregateKey] && !isActivityClaimed) {
                            // If this route has not received an aggregate, then we deliver the non-active one(s). In the event that
                            // there are multiple non-active aggregates, a duplicate activity will not be fired because we flatten and
                            // maintain a set while generating activities later.
                            aggregatesToDeliver[aggregateKey] = true;
                            aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                        }
                    });

                    // Save the aggregated entities stored in the current batch of aggregates
                    ActivityDAO.saveAggregatedEntities(allAggregates, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Create the actual activities to route
                        var visitedActivities = {};
                        var activityStreamUpdates = {};
                        _.keys(aggregatesToDeliver).forEach(function(aggregateKey) {
                            var aggregate = allAggregates[aggregateKey];

                            // Construct the activities to deliver
                            var activityType = aggregate[ActivityConstants.properties.OAE_ACTIVITY_TYPE];
                            var verb = aggregate.verb;
                            var published = aggregate.published;
                            var actors = aggregate.actors;
                            var objects = aggregate.objects;
                            var targets = aggregate.targets;

                            // Refresh the entities with the freshly fetched set, which has all the entities, not those just in this collection
                            // We need to make sure we override with the queued entities and not the freshly fetched ones since they may have been
                            // updated since original aggregation.
                            if (fetchedEntities[aggregateKey]) {
                                actors = _.extend(fetchedEntities[aggregateKey].actors, actors);
                                objects = _.extend(fetchedEntities[aggregateKey].objects, objects);
                                targets = _.extend(fetchedEntities[aggregateKey].targets, targets);
                            }

                            // Make sure that we don't deliver an identical activity to the same stream twice. This can potentially
                            // happen when an activity type has multiple pivots that were inactive prior to this activity (e.g., content-share)
                            var activityId = null;
                            var flattenedActivity = _flattenActivity(aggregate);
                            if (visitedActivities[flattenedActivity]) {
                                // We assign the previous activity id to the aggregate so that we can update the aggregate status to know that
                                // any new activities for this aggregate should replace its existing activity
                                aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID] = visitedActivities[flattenedActivity];
                                return;
                            } else {
                                // This activity is not a duplicate, assign and record a new activityId
                                activityId = _createActivityId(aggregate.published);
                                aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                                visitedActivities[flattenedActivity] = activityId;
                            }

                            // Create the entities for the delivered activity
                            var actor = _createActivityEntity(_.values(actors));
                            var object = _createActivityEntity(_.values(objects));
                            var target = _createActivityEntity(_.values(targets));

                            activityStreamUpdates[aggregate.route] = activityStreamUpdates[aggregate.route] || {};
                            activityStreamUpdates[aggregate.route][activityId] = new Activity(activityType, activityId, verb, published, actor, object, target);
                        });

                        // Deliver the new activities to the streams
                        ActivityDAO.deliverActivities(activityStreamUpdates, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            // Collection date is marked as the date/time that the aggregate gets delivered
                            var collectionDate = Date.now();

                            // Record how long it took for these to be delivered
                            _.keys(activityStreamUpdates).forEach(function(route) {
                                _.keys(activityStreamUpdates[route]).forEach(function(activityId) {
                                    var activity = activityStreamUpdates[route][activityId];
                                    Telemetry.appendDuration('activity.queue.time', activity.published);
                                });
                            });

                            // The activitiesToDelete hash values should actually be arrays of unique activity ids, not "<activity id>: true" pairs.
                            _.keys(activitiesToDelete).forEach(function(route) {
                                activitiesToDelete[route] = _.keys(activitiesToDelete[route]);
                            });

                            // Delete the old activities that were replaced by aggregates
                            ActivityDAO.deleteActivities(activitiesToDelete, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                // Determine how to update all the aggregate statuses
                                var statusUpdates = {};
                                allAggregateKeys.forEach(function(aggregateKey) {
                                    var aggregate = allAggregates[aggregateKey];
                                    statusUpdates[aggregateKey] = {
                                        'lastUpdated': aggregate.published,
                                        'lastCollected': collectionDate
                                    };

                                    if (!activeAggregates[aggregateKey]) {
                                        // This aggregate was not previously active, so mark its creation date at the beginning of the first activity
                                        statusUpdates[aggregateKey].created = aggregate.published;
                                    }

                                    // Mark the last activity for each aggregate. This ensures that when a new activity gets added to the aggregate, we can
                                    // delete the previous one.
                                    if (aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID]) {
                                        statusUpdates[aggregateKey].lastActivity = aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID];
                                    }
                                });

                                // Update the activity statuses, indicating they have just been updated and collected, where applicable
                                ActivityDAO.updateAggregateStatus(statusUpdates, function(err) {
                                    if (err) {
                                        return callback(err);
                                    }

                                    // Remove the queued routed activities that were just delivered / aggregated so they don't get re-processed
                                    ActivityDAO.deleteQueuedActivities(bucketNumber, queuedActivitiesToDelete, function(err) {
                                        if (err) {
                                            return callback(err);
                                        }

                                        // activitiesCollected marks the number of activities collected, and how long it took
                                        Telemetry.incr('collection.count');
                                        Telemetry.appendDuration('collection.time', collectionStart);
                                        Telemetry.append('activitiesCollected.count', numCollected);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Given an array of activity entities, return a new top-level activity entity representing how it should be modeled in an activity
 * stream.
 *
 * @param   {ActivityEntity[]}  entities        The activity entities to transform.
 * @return  {ActivityEntity}                    An individual activity entity that represents the collection of entities.
 */
var _createActivityEntity = function(entities) {
    if (!entities) {
        return undefined;
    } else if (!entities.length) {
        return undefined;
    } else if (entities.length === 1) {
        return entities[0];
    }

    var ext = {};
    ext[ActivityConstants.properties.OAE_COLLECTION] = entities;
    return new ActivityEntity('collection', undefined, {'ext': ext});
};

/**
 * Explode the given routed activities into all potential aggregates. An aggregate is a permutation of a routed activity that
 * further keys each by the pivot points by which the activity can be aggregated over a period of time.
 *
 * The routed activities are an array of following form:
 *
 * [
 *  {
 *      'route': <route>,
 *      'activity': <Activity>
 *  },
 *  { ... }
 * ]
 *
 * Where the route specifies the route to which the activity should be delivered, and the activity is the activity to deliver.
 *
 * The result will be an object representing the aggregation of all the routed activities in the list, keyed by the aggregate key. An
 * example aggregation of an activity that pivots on actor and had 3 matching aggregates in the array would be:
 *
 *  {
 *       '<aggregateKey>': {
 *           'route': '...',
 *           'numberOfActivities': 3,
 *           'oae:activityType': '...',
 *           'activityIds': {
 *              '<activityId0>': true,
 *              ...
 *           },
 *           'verb': '...',
 *           'published': '...',
 *           'actors': {
 *               '<actorKey0>': <ActivityEntity (actor)>
 *           },
 *           'objects': {
 *               '<objectKey0>': <ActivityEntity (object)>,
 *               '<objectKey1>': <ActivityEntity (object)>,
 *               '<objectKey2>': <ActivityEntity (object)>
 *           },
 *           'targets': {}
 *       }
 *  }
 *
 * @param   {Object[]}  routedActivities    An array of activities along with the route to which they should be delivered. See summary for more information.
 * @return  {Object}                        An object representing the potential aggregates of the collected batch of activities.
 */
var _createAggregates = function(routedActivities) {
    var aggregates = {};
    routedActivities.forEach(function(routedActivity) {
        var route = routedActivity.route;
        var activity = routedActivity.activity;
        var activityType = activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE];
        var activityId = activity[ActivityConstants.properties.OAE_ACTIVITY_ID];

        // Build the entity keys which will be used to create the aggregate key
        var actorKey = _createEntityKey(activity.actor);
        var objectKey = _createEntityKey(activity.object);
        var targetKey = _createEntityKey(activity.target);

        // Determine how this activity will be grouped (a.k.a., pivot points) for aggregation
        var groupBy = (activityTypes[activityType]) ? activityTypes[activityType].groupBy : [];

        // Ensure we atleast have the "all" aggregate, which means we don't get duplicate activities within the same aggregation
        // period.
        if (groupBy.length === 0) {
            groupBy = [{
                'actor': true,
                'object': true,
                'target': true
            }];
        }

        groupBy.forEach(function(pivot) {
            var pivotActorKey = (pivot.actor) ? actorKey : '';
            var pivotObjectKey = (pivot.object) ? objectKey : '';
            var pivotTargetKey = (pivot.target) ? targetKey : '';
            var aggregateKey = util.format('%s#%s#%s#%s#%s', activityType, route, pivotActorKey, pivotObjectKey, pivotTargetKey);

            if (!aggregates[aggregateKey]) {
                aggregates[aggregateKey] = {
                    'route': route,
                    'activityIds': [],
                    'verb': activity.verb,
                    'published': activity.published,
                    'actors': {},
                    'objects': {},
                    'targets': {}
                };
                aggregates[aggregateKey][ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activityType;
            }

            var aggregate = aggregates[aggregateKey];
            var suppressAggregate = true;

            if (activity.actor && !aggregate.actors[actorKey]) {
                suppressAggregate = false;
                aggregate.actors[actorKey] = activity.actor;
            }

            if (activity.object) {
                suppressAggregate = false;
                aggregate.objects[objectKey] = activity.object;
            }

            if (activity.target) {
                suppressAggregate = false;
                aggregate.targets[targetKey] = activity.target;
            }

            if (!suppressAggregate) {
                // We suppress the aggregate if it is a duplicate. If it is not a duplicate we honour the activity id
                aggregate.published = activity.published;
                aggregate.activityIds.push(activity[ActivityConstants.properties.OAE_ACTIVITY_ID]);
            }
        });
    });

    return aggregates;
};

/**
 * Create a unique string identifier for an activity that was posted at the given publishing date.
 *
 * @param   {Number}    published   The time (millis since the epoch) that the activity was published.
 * @return  {String}                A unique identifier for the activity.
 */
var _createActivityId = function(published) {
    return util.format('%s:%s', published, ShortId.generate());
};

var _flattenActivity = function(aggregate) {
    var route = aggregate.route;
    var activityType = aggregate[ActivityConstants.properties.OAE_ACTIVITY_TYPE];

    // Create a multi-key of all the actors, objects and targets so they are deterministic
    var actorsKeys = [];
    _.values(aggregate.actors).forEach(function(actor) {
        actorsKeys.push(_createEntityKey(actor));
    });
    actorsKeys = actorsKeys.sort().join(',');

    var objectsKeys = [];
    _.values(aggregate.objects).forEach(function(object) {
        objectsKeys.push(_createEntityKey(object));
    });
    objectsKeys = objectsKeys.sort().join(',');

    var targetsKeys = [];
    _.values(aggregate.targets).forEach(function(target) {
        targetsKeys.push(_createEntityKey(target));
    });
    targetsKeys = targetsKeys.sort().join(',');

    // Generate the identity key for the activity described by the aggregate
    return util.format('%s#%s#%s#%s#%s', activityType, route, actorsKeys, objectsKeys, targetsKeys);
};

/**
 * Create a unique string representation from the given entity. If the entity is not specified, returns `ENTITY_KEY_EMPTY`
 * as a placeholder for the entity key.
 *
 * @param   {ActivityEntity}    entity      The entity for which to create an entity key.
 * @return  {String}                        A unique string representation of the entity.
 */
var _createEntityKey = function(entity) {
    return (entity) ? util.format('%s:%s', entity.objectType, entity[ActivityConstants.properties.OAE_ID]) : ENTITY_KEY_EMPTY;
};

/**
 * Get the bucket number in which an activity should be queued.
 *
 * @param   {String}        route           The string of the route.
 * @param   {ActivitySeed}  activitySeed    The activity seed from which the activity seed is being generated.
 * @return  {Number}                        The bucket number in which to queue the activity for processing.
 */
var _getBucketNumber = function(route, activitySeed) {
    var sum = crypto.createHash('md5');
    // Concurrency considerations in activity aggregation / replacement require us to store, at the least, all aggregates of a
    // particular route in one bucket. The reason we include the activity type is because it is still concurrency-safe, and
    // also avoids "hot buckets" when you take into consideration something like a "public" or "loggedin" activity stream.
    // Having "hot buckets" would essentially translate into a hot Cassandra row, since each bucket is a row, which is bad.
    sum.update(route);
    sum.update(activitySeed.activityType);
    return parseInt(sum.digest('hex'), 16) % numberOfProcessingBuckets;
};

/**
 * Given an aggregate status entry and the publish date of the next activity, determine if the aggregate is considered to be
 * expired.
 *
 * @param   {Object}    aggregateStatus         The aggregate status entry.
 * @param   {Number}    published               The published date (in millis since the epoch) that the next activity occurred.
 * @param   {Boolean}                           Whether or not the aggregate is expired.
 */
var _isExpired = function(aggregateStatus, published) {
    var lastUpdateWasCollected = (aggregateStatus.lastCollected && aggregateStatus.lastCollected > aggregateStatus.lastUpdated);
    var lastUpdateIsIdleExpired = ((published - aggregateStatus.lastUpdated) > aggregateIdleExpiry);
    var createdMaxIsExpired = ((published - aggregateStatus.created) > aggregateMaxExpiry);
    return (lastUpdateWasCollected && (lastUpdateIsIdleExpired || createdMaxIsExpired));
};

