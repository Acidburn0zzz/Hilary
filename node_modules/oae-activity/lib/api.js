/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var crypto = require('crypto');
var events = require('events');
var log = require('oae-logger').logger('oae-activity');
var MQ = require('oae-util/lib/mq');
var OaeUtil = require('oae-util/lib/util');
var ShortId = require('shortid');
var util = require('util');
var Validator = require('oae-authz/lib/validator').Validator;

var Activity = require('oae-activity/lib/model').Activity;
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityCluster = require('./internal/cluster');
var ActivityDAO = require('./internal/dao');
var ActivityEntity = require('oae-activity/lib/model').ActivityEntity;
var ActivityStream = require('oae-activity/lib/model').ActivityStream;

var DEFAULT_ACTIVITY_TTL = 2 * 7 * 24 * 60 * 60;
var DEFAULT_AGGREGATE_IDLE_EXPIRY = 3 * 60 * 60 * 1000;
var DEFAULT_AGGREGATE_MAX_EXPIRY = 24 * 60 * 60 * 1000;
var DEFAULT_NUMBER_OF_PROCESSING_BUCKETS = 5;
var DEFAULT_COLLECTION_EXPIRY = 60 * 1000;
var DEFAULT_MAX_CONCURRENT_COLLECTIONS = 3;
var DEFAULT_COLLECTION_POLLING_FREQUENCY = 5 * 1000;
var DEFAULT_COLLECTION_BATCH_SIZE = 500;
var DEFAULT_ALLOW_ANON_COLLECTION = false;
var ENTITY_KEY_EMPTY = '__null__';

var activityTypes = {};
var activityProducers = {};
var activityRouters = {};

var boundWorker = false;
var numberOfProcessingBuckets = DEFAULT_NUMBER_OF_PROCESSING_BUCKETS;
var aggregateIdleExpiry = DEFAULT_AGGREGATE_IDLE_EXPIRY;
var aggregateMaxExpiry = DEFAULT_AGGREGATE_MAX_EXPIRY;
var collectionExpiry = DEFAULT_COLLECTION_EXPIRY;
var maxConcurrentCollections = DEFAULT_MAX_CONCURRENT_COLLECTIONS;
var collectionPollingFrequency = DEFAULT_COLLECTION_POLLING_FREQUENCY;
var collectionBatchSize = DEFAULT_COLLECTION_BATCH_SIZE;
var allowAnonCollection = DEFAULT_ALLOW_ANON_COLLECTION;

var collectionPollingTimer = null;

var currentConcurrentCollectionCount = 0;

var emitter = module.exports = new events.EventEmitter();

/**
 * Refresh the activities configuration.
 *
 * @param   {Object}        [config]                            The object containing the configuration properties
 * @param   {Boolean}       [config.processActivityJobs]        Whether or not this server node should produce and route activities. Defaults to `true`
 * @param   {Number}        [config.activityTtl]                The time-to-live (in seconds) for generated activities. Defaults to 2 weeks
 * @param   {Number}        [config.aggregateIdleExpiry]        The amount of time (in milliseconds) an aggregate can be idle until it expires. Defaults to 3 hours
 * @param   {Number}        [config.aggregateMaxExpiry]         An upper-bound on the amount of time (in milliseconds) for which an aggregate can live. Defaults to 1 day
 * @param   {Number}        [config.numberOfProcessingBuckets]  The number of buckets available for parallel processing of activities. Defaults to 5
 * @param   {Number}        [config.collectionExpiry]           The maximum amount of time (in milliseconds) a processing bucket can be locked for at one time. Defaults to 1 minute
 * @param   {Number}        [config.maxConcurrentCollections]   The maximum number of concurrent collection cycles that can be active on a process at once. Defaults to 3
 * @param   {Number}        [config.collectionPollingFrequency] How often (in milliseconds) the processing buckets are polled for new activities. If -1, polling will be disabled. Defaults to 5 seconds
 * @param   {Number}        [config.collectionBatchSize]        The number of items to process at a time when collecting bucketed activities. Defaults to 500
 * @param   {Boolean}       [config.allowAnonCollection]        Determines whether or not an anonymous user can invoke a collection. Defaults to false.
 * @param   {Function}      [callback]                          Invoked when the configuration has been refreshed
 * @param   {Object}        [callback.err]                      An error that occurred, if any
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(config, callback) {
    config = config || {};
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error refreshing activities configuration.');
        }
    };

    var processActivityJobs = (config.processActivityJobs !== false);
    var activityTtl = OaeUtil.getIntParam(config.activityTtl, DEFAULT_ACTIVITY_TTL);
    numberOfProcessingBuckets = OaeUtil.getIntParam(config.numberOfProcessingBuckets, DEFAULT_NUMBER_OF_PROCESSING_BUCKETS);
    aggregateIdleExpiry = OaeUtil.getIntParam(config.aggregateIdleExpiry, DEFAULT_AGGREGATE_IDLE_EXPIRY);
    aggregateMaxExpiry = OaeUtil.getIntParam(config.aggregateMaxExpiry, DEFAULT_AGGREGATE_MAX_EXPIRY);
    collectionExpiry = OaeUtil.getIntParam(config.collectionExpiry, DEFAULT_COLLECTION_EXPIRY);
    maxConcurrentCollections = OaeUtil.getIntParam(config.maxConcurrentCollections, DEFAULT_MAX_CONCURRENT_COLLECTIONS);
    collectionPollingFrequency = OaeUtil.getIntParam(config.collectionPollingFrequency, DEFAULT_COLLECTION_POLLING_FREQUENCY);
    collectionBatchSize = OaeUtil.getIntParam(config.collectionBatchSize, DEFAULT_COLLECTION_BATCH_SIZE);
    allowAnonCollection = (config.allowAnonCollection === true);

    log().trace({
        'processActivityJobs': processActivityJobs,
        'activityTtl': activityTtl,
        'numberOfProcessingBuckets': numberOfProcessingBuckets,
        'aggregateIdleExpiry': aggregateIdleExpiry,
        'aggregateMaxExpiry': aggregateMaxExpiry,
        'collectionExpiry': collectionExpiry,
        'maxConcurrentCollections': maxConcurrentCollections,
        'collectionPollingFrequency': collectionPollingFrequency,
        'allowAnonCollection': allowAnonCollection
    }, 'Refreshing activity configuration.');

    // Push the TTL into the DAO
    ActivityDAO.refreshConfiguration(activityTtl);

    clearInterval(collectionPollingTimer);

    // Enable / Disable the worker binding, if necessary
    if (processActivityJobs && !boundWorker) {
        boundWorker = true;

        // Only restart the collection interval if polling frequency is above 0
        if (collectionPollingFrequency > 0) {
            collectionPollingTimer = setInterval(_collect, collectionPollingFrequency);
        }

        return MQ.bind(ActivityConstants.mq.TASK_ACTIVITY, _handleActivityTask, callback);
    } else if (!processActivityJobs && boundWorker) {
        boundWorker = false;
        return MQ.unbind(ActivityConstants.mq.TASK_ACTIVITY, callback);
    } else {
        return callback();
    }
};

var registerActivityType = module.exports.registerActivityType = function(activityType, groupBy) {
    if (activityTypes[activityType]) {
        throw new Error('Attempted to register duplicate activity type');
    }
    activityTypes[activityType] = {'groupBy': groupBy};
};

/**
 * Register an activity producer. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityEntity that can be used in an activity.
 *
 * The activity entity `propagation` rule specifies how the activity entity information should be propagated across the different
 * routes. The values signify the following:
 *
 * * `ActivityConstants.entityPropagation.ALL`: The data in the activity entity will be propagated to *all* routes that are generated for the current entity, and all other entity routes that are part of the activity
 * * `ActivityConstants.entityPropagation.OWN`: The data in the activity entity will be propagated to only the routes that are produced for the entity
 *
 * @param   {String}         resourceType                     The type of resource this producer is meant to produce activity objects for (e.g., content, comment, user...)
 * @param   {Function}       producer                         The function that will convert the resource object into an activity object
 * @param   {String}         producer.activityType            The type of activity being generated
 * @param   {String}         producer.entityType              The entity type for which this entity is being produced. One of actor, object, target
 * @param   {String}         producer.resource                The resource seed object that describes the resource to use to generate the activity object
 * @param   {Function}       producer.callback                The function to invoke when the object has been produced
 * @param   {Object}         producer.callback.err            An error that occurred, if any
 * @param   {ActivityEntity} producer.callback.activityEntity The activity object that was produced
 * @param   {String}         producer.callback.propagation    How the activity object should be propagated across other routes. The valid values are enumerated by `ActivityConstants.entityPropagation`
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    if (activityProducers[resourceType]) {
        throw new Error('Attempted to register duplicate activity producer');
    }
    activityProducers[resourceType] = producer;
};

/**
 * Register an activity router. The activity producer is responsible for taking a single resource object from the activity seed
 * and converting it into an ActivityEntity that can be used in an activity.
 *
 * @param   {String}         resourceType               The type of resource this router is meant to route (e.g., content, comment, user...)
 * @param   {Function}       router                     The function that will convert the resource object into an activity object
 * @param   {String}         router.activityType        The type of activity being routed
 * @param   {String}         router.entityType          The entity type for which this object is being routed. One of actor, object, target
 * @param   {ActivityEntity} router.activityEntity      The activity object model that was produced for the resource
 * @param   {Function}       router.callback            The function to invoke when the object has been produced
 * @param   {Object}         router.callback.err        An error that occurred, if any
 * @param   {ActivityEntity} router.callback.routes     The routes to which the activity should be delivered
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    if (activityRouters[resourceType]) {
        throw new Error('Attempted to register duplicate activity router');
    }
    activityRouters[resourceType] = router;
};

/**
 * Get the activity stream by the specified id.
 *
 * @param   {Context}       ctx                 The context of the current session
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivityStream = module.exports.getActivityStream = function(ctx, activityStreamId, start, limit, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Must be logged in to see an activity stream'}).isLoggedInUser(ctx);
    validator.check(activityStreamId, {'code': 400, 'msg': 'Must specify an activity stream'}).notEmpty();
    validator.check(activityStreamId, {'code': 400, 'msg': 'You can only view activity streams for a principal'}).isPrincipalId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var userId = ctx.user().id;
    var targetAuthzPrincipal = AuthzUtil.getPrincipalFromId(activityStreamId);
    if (ctx.user().isAdmin(targetAuthzPrincipal.tenantAlias)) {
        // Admin of the target tenant can always see the stream
        return _getActivityStream(activityStreamId, start, limit, callback);
    } else if (AuthzUtil.isGroupId(activityStreamId)) {
        // You can only view a group's activity stream if you are a member of that group
        return AuthzAPI.hasAnyRole(userId, activityStreamId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback({'code': 401, 'msg': 'Must be a member of a group to see its activity stream'});
            }

            return _getActivityStream(activityStreamId, start, limit, callback);
        });
    } else if (activityStreamId === userId) {
        // You can only view a user's activity stream if it is yourself. No peeking at other user streams.
        return _getActivityStream(activityStreamId, start, limit, callback);
    }

    // If we're here, we were trying to view another user's activity stream, not allowed!
    return callback({'code': 401, 'msg': 'You are not authorized to see this user\'s activity stream'});
};

/**
 * Post an activity in the system to be routed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity "seed" object, which represents the smallest amount of information necessary to generate an activity
 * @param   {Function}      callback            Invoked when the activity has been posted (but has not been routed yet)
 * @param   {Object}        callback.err        An error that occurred, if any
 */
var postActivity = module.exports.postActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'activitySeed': activitySeed}, 'Error posting activity.');
        }
    };

    var validator = new Validator();

    // Validate top-level activity properties
    validator.check(null, {'code': 400, 'msg': 'No activity seed provided.'}).isObject(activitySeed);
    validator.check(activitySeed.activityType, {'code': 400, 'msg': 'Activity seed did not have an activity type.'}).notEmpty();
    validator.check(activitySeed.verb, {'code': 400, 'msg': 'Activity seed did not have a verb.'}).notEmpty();

    // Validate the actor resource
    validator.check(null, {'code': 400, 'msg': 'Activity seed did not have an actor resource'}).isObject(activitySeed.actorResource);
    validator.check(activitySeed.actorResource.resourceId, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceId'}).notEmpty();
    validator.check(activitySeed.actorResource.resourceType, {'code': 400, 'msg': 'Actor of activity seed did not have a resourceType'}).notEmpty();

    // Validate the object resource
    if (activitySeed.objectResource) {
        validator.check(activitySeed.objectResource.resourceId, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.objectResource.resourceType, {'code': 400, 'msg': 'Object of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    // Validate the target resource
    if (activitySeed.targetResource) {
        validator.check(activitySeed.targetResource.resourceId, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceId'}).notEmpty();
        validator.check(activitySeed.targetResource.resourceType, {'code': 400, 'msg': 'Target of activity seed was specified and did not have a resourceType'}).notEmpty();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    MQ.submit(ActivityConstants.mq.TASK_ACTIVITY, activitySeed, callback);
};

/**
 * Internal function to get an activity stream by its ID. This bypasses permission checks.
 *
 * @param   {String}            activityStreamId        The ID of the activity stream to fetch
 * @param   {Number}            start                   The starting timestamp of the activities to fetch
 * @param   {Number}            limit                   The number of activities to fetch
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {ActivityStream}    callback.activityStream The activity stream
 * @api private
 */
var _getActivityStream = function(activityStreamId, start, limit, callback) {
    ActivityDAO.getActivities(activityStreamId, start, limit, function(err, activities) {
        if (err) {
            return callback(err);
        }

        // Wrap the activities into an activity stream
        return callback(null, new ActivityStream(activities));
    });
};

/**
 * Task handler to generate and route the activities when a task is sent.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed that was used to post the activity
 * @param   {Function}      [callback]          Invoked when the process completes
 * @param   {Object}        [callback.err]      An error that occurred, if any
 * @api private
 */
var _handleActivityTask = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error handling activity.');
        }
    };

    log().trace({'activitySeed': activitySeed}, 'Handling activity task.');

    // Will aggregate all the activityStreamId (i.e., route) -> activity pairings that will be delivered
    var routedActivities = {};
    var activityId = _createActivityId(activitySeed.published);

    // Produce the routes for the actor, object and target entities
    _produceAllRoutes(activitySeed, function(err, actorRoutes, objectRoutes, targetRoutes) {
        if (err) {
            return callback(err);
        }

        // Produce all of the activity entities
        _produceAllEntities(activitySeed, function(err, actor, actorPropagation, object, objectPropagation, target, targetPropagation) {
            if (err) {
                return callback(err);
            }

            // 1. Create all routes and apply the "OWN" propagation entities. this is how private entities get delivered to feeds
            for (var i = 0; i < actorRoutes.length; i++) {
                var actorRoute = actorRoutes[i];
                routedActivities[actorRoute] = routedActivities[actorRoute] || {};
                if (actorPropagation === ActivityConstants.entityPropagation.OWN) {
                    routedActivities[actorRoute].actor = routedActivities[actorRoute].actor || actor;
                }
            }

            for (i = 0; i < objectRoutes.length; i++) {
                var objectRoute = objectRoutes[i];
                routedActivities[objectRoute] = routedActivities[objectRoute] || {};
                if (objectPropagation === ActivityConstants.entityPropagation.OWN) {
                    routedActivities[objectRoute].object = routedActivities[objectRoute].object || object;
                }
            }

            for (i = 0; i < targetRoutes.length; i++) {
                var targetRoute = targetRoutes[i];
                routedActivities[targetRoute] = routedActivities[targetRoute] || {};
                if (targetPropagation === ActivityConstants.entityPropagation.OWN) {
                    routedActivities[targetRoute].target = routedActivities[targetRoute].target || target;
                }
            }

            // 2. Back-fill all entities that are set to propagate on "all". Also apply the minimum data (i.e., the resource type and id) where necessary.
            _.values(routedActivities).forEach(function(activity) {

                // Also use this loop to put all the activity-level properties onto each activity
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activitySeed.activityType;
                activity[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                activity.verb = activitySeed.verb;
                activity.published = activitySeed.published;

                // Backfill the appropriate actor data (there should always be an actor associated to the activity)
                if (activitySeed.actorResource) {
                    if (!activity.actor && actorPropagation === ActivityConstants.entityPropagation.ALL) {
                        activity.actor = actor;
                    } else if (!activity.actor) {
                        // This activity will not receive the actor. Instead, fill in the minimum amount of data that we can (resourceType and resourceId)
                        activity.actor = {};
                        activity.actor.objectType = activitySeed.actorResource.resourceType;
                        activity.actor[ActivityConstants.properties.OAE_ID] = activitySeed.actorResource.resourceId;
                    }
                }

                // Backfill the appropriate object data if there was an object associated to the activity
                if (activitySeed.objectResource) {
                    if (!activity.object && objectPropagation === ActivityConstants.entityPropagation.ALL) {
                        activity.object = object;
                    } else if (!activity.object) {
                        // This activity will not receive the object. Instead, fill in the minimum amount of data that we can (resourceType and resourceId)
                        activity.object = {};
                        activity.object.objectType = activitySeed.objectResource.resourceType;
                        activity.object[ActivityConstants.properties.OAE_ID] = activitySeed.objectResource.resourceId;
                    }
                }

                // Backfill the appropriate target data if there was a target associated to the activity
                if (activitySeed.targetResource) {
                    if (!activity.target && targetPropagation === ActivityConstants.entityPropagation.ALL) {
                        activity.target = target;
                    } else if (!activity.target) {
                        // This activity will not receive the target. Instead, fill in the minimum amount of data that we can (resourceType and resourceId)
                        activity.target = {};
                        activity.target.objectType = activitySeed.targetResource.targetType;
                        activity.target[ActivityConstants.properties.OAE_ID] = activitySeed.targetResource.resourceId;
                    }
                }
            });

            log().trace({
                'activitySeed': activitySeed,
                'routedActivities': routedActivities
            }, 'Queueing activities to be routed.');

            // Queue the activity entities to be collected and aggregated
            _queueActivities(activitySeed, routedActivities, callback);
        });
    });
};

var _queueActivities = function(activitySeed, routedActivities, callback) {
    var allRoutes = _.keys(routedActivities);
    var activityBuckets = [];

    allRoutes.forEach(function(route) {
        // Assign all activities to their processing buckets to support safe concurrency
        var bucketNumber = _getBucketNumber(route, activitySeed);
        activityBuckets[bucketNumber] = activityBuckets[bucketNumber] || [];
        activityBuckets[bucketNumber].push({
            'route': route,
            'activity': routedActivities[route]
        });
    });

    // Queue the aggregates into their associated buckets to indicate they need to be collected and delivered
    ActivityDAO.saveQueuedActivities(activitySeed, activityBuckets, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.keys(activityBuckets));
    });
};

var collect = module.exports.collect = function(ctx, callback) {
    if (allowAnonCollection) {
        return _collect(callback);
    }

    if (ctx.user() && ctx.user().isGlobalAdmin()) {
        return _collect(callback);
    }

    return callback({'code': 401, 'msg': 'Only admin can manually trigger a collection'});
};

var _collect = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error collecting aggregates.');
        }
    };

    if (currentConcurrentCollectionCount >= maxConcurrentCollections) {
        log().trace('Aborting collection due to max concurrent collections count reached.');
        return callback();
    }
    currentConcurrentCollectionCount++;

    // Fill all the possible bucket numbers
    var bucketNumbers = [];
    for (var i = 0; i < numberOfProcessingBuckets; i++) {
        bucketNumbers.push(i);
    }

    log().trace('Beginning collection of %s buckets.', bucketNumbers.length);

    _collectBuckets(bucketNumbers, function(err) {
        // Mark that this collection cycle has completed
        currentConcurrentCollectionCount--;
        log().trace('Completed collection cycle.');
        return callback(err);
    });
};

var _collectBuckets = function(bucketNumbers, callback) {
    if (bucketNumbers.length === 0) {
        return callback();
    }

    var bucketNumber = bucketNumbers.shift();
    _collectBucket(bucketNumber, function(err) {
        if (err) {
            log().warn({'err': err, 'bucketNumber': bucketNumber}, 'Error collecting aggregate bucket.');
        }

        _collectBuckets(bucketNumbers, callback);
    });
};

var _collectBucket = function(bucketNumber, callback) {
    log().trace('Beginning collection of bucket number %s.', bucketNumber);
    // Try and acquire a lock on the bucket to collect the next batch
    ActivityCluster.acquireBucket(bucketNumber, collectionExpiry, function(err, lockId) {
        if (lockId) {
            // We acquired the lock, perform a collection iteration
            _collectBucketBatch(bucketNumber, collectionBatchSize, function(collectionErr, empty) {
                // We want to ensure we release the bucket, regardless if we err'd out
                ActivityCluster.releaseBucket(bucketNumber, lockId, function(releaseErr) {
                    if (collectionErr) {
                        return callback(collectionErr);
                    } else if (releaseErr) {
                        // If there was an error releasing the lock, worst case scenario would be that the lock eventually expires
                        // and a cluster node picks it up soon after that and continues processing.
                        return callback(releaseErr);
                    } else if (empty) {
                        // The bucket is now empty, return to the caller
                        return callback();
                    }

                    // The bucket isn't empty, try another collection iteration
                    return _collectBucket(bucketNumber, callback);
                });
            });
        } else {
            // We could not acquire a lock, someone else came around and managed to snag the bucket
            return callback();
        }
    });
};

var _collectBucketBatch = function(bucketNumber, limit, callback) {
    log().trace('Collecting batch of %s entries from bucket number %s.', limit, bucketNumber);
    // Get the next batch of queued activities to process
    ActivityDAO.getQueuedActivities(bucketNumber, limit, function(err, routedActivities) {
        if (err) {
            return callback(err);
        }

        // These will be deleted by the internal id after they've been processed
        var queuedActivitiesToDelete = _.keys(routedActivities);

        if (queuedActivitiesToDelete.length === 0) {
            // None more to process, so stop
            return callback(null, true);
        }

        routedActivities = _.values(routedActivities);

        // Explode the routed activities into their aggregates
        var allAggregates = _createAggregates(routedActivities);
        /*
        allAggregates = {
            '<aggregateKey>': {
                'route': '...',
                'numberOfActivities': 3,
                'oae:activityType': '...',
                'verb': '...',
                'published': '...',
                'actors': [ ... ],
                'objects': [ ... ],
                'targets': [ ... ]
            }, ...
        }
        */

        var allAggregateKeys = _.keys(allAggregates);

        // Get all aggregate statuses to determine which ones are expired
        ActivityDAO.getAggregateStatus(allAggregateKeys, function(err, statusByAggregateKey) {
            if (err) {
                return callback(err);
            }

            // Figure out which aggregates are "active" (have an activity in its aggregate) and "expired" (no new activities in the aggregate before expiry time)
            var activeAggregates = {};
            var expiredAggregates = {};
            allAggregateKeys.forEach(function(aggregateKey) {
                var status = statusByAggregateKey[aggregateKey];
                if (status && _isExpired(status, allAggregates[aggregateKey].published)) {
                    expiredAggregates[aggregateKey] = true;
                } else if (status) {
                    activeAggregates[aggregateKey] = true;
                }
            });

            // Note: We need to delete aggregated entities and save them here within the collection chain to avoid nuking undelivered
            // entities. If we saved aggregated entities during the Routing/Production phase, then only deleted them here, it would
            // save writing those entities once, but exposes a race condition where entities that are saved between getAggregateStatus
            // and deleteAggregatedEntities will be deleted before delivery.

            // Delete all the expired aggregates before aggregating new stuff
            ActivityDAO.deleteAggregates(_.keys(expiredAggregates), function(err) {
                if (err) {
                    return callback(err);
                }

                // Save the aggregated entities stored in the current batch of aggregates
                ActivityDAO.saveAggregatedEntities(allAggregates, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Key by route, which will help us assign activities to routes
                    var routeAggregates = {};
                    allAggregateKeys.forEach(function(aggregateKey) {
                        var aggregate = allAggregates[aggregateKey];
                        var route = aggregate.route;
                        routeAggregates[route] = routeAggregates[route] || {};
                        routeAggregates[route][aggregateKey] = aggregate;
                    });

                    var routes = _.keys(routeAggregates);
                    var aggregatesToDeliver = {};

                    // Assign activityIds to aggregates
                    routes.forEach(function(route) {
                        var routeAggregateKeys = _.keys(routeAggregates[route]);
                        var branchedActivities = {};
                        routeAggregateKeys.forEach(function(aggregateKey) {
                            var aggregate = allAggregates[aggregateKey];
                            var activityId = aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID];

                            branchedActivities[aggregate.route] = branchedActivities[aggregate.route] || {};

                            // If the aggregate key is active (it recently had a match from another activity), then the activity
                            // will always be "claimed" for the aggregate and a new activity will be generated for it
                            if (activeAggregates[aggregateKey] || aggregate.numberOfActivities > 1) {
                                log().trace({
                                    'activeAggregates': activeAggregates,
                                    'aggregate': aggregate,
                                    'aggregateKey': aggregateKey
                                }, 'Branching activity.');

                                // Mark the original activity id that it was consumed by an aggregate for a route
                                branchedActivities[aggregate.route][activityId] = true;

                                // Create a new ID for the activity since it branches into a new activity (an "aggregation")
                                aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID] = _createActivityId(aggregate.published);
                            }
                        });

                        // Add the deliverable aggregates to the delivery hash
                        routeAggregateKeys.forEach(function(aggregateKey) {
                            var aggregate = allAggregates[aggregateKey];
                            var activityId = aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID];
                            if (!branchedActivities[aggregate.route][activityId]) {
                                // We can deliver this because it was not branched into an aggregate
                                aggregatesToDeliver[aggregateKey] = aggregate;
                            }
                        });
                    });

                    // Retrieve the live aggregates and merge with local data to deliver
                    var activeAggregateKeys = _.keys(activeAggregates);
                    ActivityDAO.getAggregatedEntities(activeAggregateKeys, function(err, fetchedEntities) {
                        if (err) {
                            return callback(err);
                        }

                        var deliveredAggregateKeys = _.keys(aggregatesToDeliver);

                        // Create the activities to route
                        var visitedActivities = {};
                        var activityStreamUpdates = {};
                        deliveredAggregateKeys.forEach(function(aggregateKey) {
                            var aggregate = aggregatesToDeliver[aggregateKey];

                            // Activities can be duplicated if activities have multiple pivot points. Only deliver each activity once
                            visitedActivities[aggregate.route] = visitedActivities[aggregate.route] || {};
                            var duplicate = (visitedActivities[aggregate.route][aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID]]);
                            visitedActivities[aggregate.route][aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID]] = true;
                            if (duplicate) {
                                return;
                            }

                            var activityType = aggregate[ActivityConstants.properties.OAE_ACTIVITY_TYPE];
                            var activityId = aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID];
                            var verb = aggregate.verb;
                            var published = aggregate.published;
                            var actors = aggregate.actors;
                            var objects = aggregate.objects;
                            var targets = aggregate.targets;

                            // Merge the freshly fetched entities into the aggregate. This pulls in previously-aggregated entities
                            if (fetchedEntities[aggregateKey]) {
                                actors = _.extend(fetchedEntities[aggregateKey].actors, actors);
                                objects = _.extend(fetchedEntities[aggregateKey].objects, objects);
                                targets = _.extend(fetchedEntities[aggregateKey].targets, targets);
                            }

                            actors = _.values(actors);
                            objects = _.values(objects);
                            targets = _.values(targets);

                            // Create the entities
                            var ext = {};
                            var actor = undefined;
                            if (actors.length === 1) {
                                actor = actors[0];
                            } else if (actors.length > 1) {
                                ext[ActivityConstants.properties.OAE_COLLECTION] = _.values(actors);
                                actor = new ActivityEntity('collection', activityId, {'ext': ext});
                            }

                            var object = undefined;
                            if (objects.length === 1) {
                                object = objects[0];
                            } else if (objects.length > 1) {
                                ext = {};
                                ext[ActivityConstants.properties.OAE_COLLECTION] = _.values(objects);
                                object = new ActivityEntity('collection', activityId, {'ext': ext});
                            }

                            var target = undefined;
                            if (targets.length === 1) {
                                target = targets[0];
                            } else if (targets.length > 1) {
                                ext = {};
                                ext[ActivityConstants.properties.OAE_COLLECTION] = _.values(targets);
                                target = new ActivityEntity('collection', activityId, {'ext': ext});
                            }

                            activityStreamUpdates[aggregate.route] = activityStreamUpdates[aggregate.route] || {};
                            activityStreamUpdates[aggregate.route][activityId] = new Activity(activityType, activityId, verb, published, actor, object, target);
                        });

                        // Deliver the new activities to the streams
                        ActivityDAO.deliverActivities(activityStreamUpdates, function(err) {
                            if (err) {
                                return callback(err);
                            }

                            // Collection date is marked as the date/time that the aggregate gets delivered
                            var collectionDate = Date.now();

                            // For each delivered aggregate key, delete the old activity
                            var activitiesToDelete = {};
                            deliveredAggregateKeys.forEach(function(aggregateKey) {
                                var status = statusByAggregateKey[aggregateKey];
                                if (status && status.lastActivity) {
                                    var route = allAggregates[aggregateKey].route;
                                    activitiesToDelete[route] = activitiesToDelete[route] || [];
                                    activitiesToDelete[route].push(status.lastActivity);
                                }
                            });

                            // Delete the old activities that are being replaced by aggregates
                            ActivityDAO.deleteActivities(activitiesToDelete, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                // Determine how to update all the aggregate statuses
                                var statusUpdates = {};
                                allAggregateKeys.forEach(function(aggregateKey) {
                                    var aggregate = allAggregates[aggregateKey];
                                    statusUpdates[aggregateKey] = {
                                        'lastUpdated': aggregate.published,
                                        'lastCollected': collectionDate
                                    };

                                    if (!activeAggregates[aggregateKey] || expiredAggregates[aggregateKey]) {
                                        // This aggregate was not previously active, so mark its creation date at the beginning of the first activity
                                        statusUpdates[aggregateKey].created = aggregate.published;
                                    }

                                    if (aggregatesToDeliver[aggregateKey]) {
                                        // This aggregate was delivered, give them the activity id to track their "last activity"
                                        statusUpdates[aggregateKey].lastActivity = aggregate[ActivityConstants.properties.OAE_ACTIVITY_ID];
                                    }
                                });

                                // Update the activity statuses
                                ActivityDAO.updateAggregateStatus(statusUpdates, function(err) {
                                    if (err) {
                                        return callback(err);
                                    }

                                    // Remove the queued activities that were just delivered / aggregated
                                    ActivityDAO.deleteQueuedActivities(bucketNumber, queuedActivitiesToDelete, function(err) {
                                        if (err) {
                                            return callback(err);
                                        }

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Produce activity entities based on the actor, object and target resources of the given activity seed.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed from which to extract the actor, object and target resource information
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {ActivityEntity}    callback.actor              The actor activity entity
 * @param   {String}            callback.actorPropagation   The actor entity propagation rule
 * @param   {ActivityEntity}    callback.object             The object activity entity
 * @param   {String}            callback.objectPropagation  The object entity propagation rule
 * @param   {ActivityEntity}    callback.target             The actor activity entity
 * @param   {String}            callback.targetPropagation  The actor entity propagation rule
 * @api private
 */
var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor, actorPropagation) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object, objectPropagation) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target, targetPropagation) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, actorPropagation, object, objectPropagation, target, targetPropagation);
            });
        });
    });
};

/**
 * Produce the routes for the given actor, object and target activity entities.
 *
 * @param   {ActivitySeed}      activitySeed            The activity seed that was used to post the activity
 * @param   {Function}          callback                Invoked when the process completes
 * @param   {Object}            callback.err            An error that occurred, if any
 * @param   {String[]}          callback.actorRoutes    The routes to which to route the activity for the actor
 * @param   {String[]}          callback.objectRoutes   The routes to which to route the activity for the object
 * @param   {String[]}          callback.targetRoutes   The routes to which to route the activity for the target
 * @api private
 */
var _produceAllRoutes = function(activitySeed, callback) {
    log().trace({'activitySeed': activitySeed}, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actorRoutes) {
        if (err) {
            return callback(err);
        }

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, objectRoutes) {
            if (err) {
                return callback(err);
            }

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, targetRoutes) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actorRoutes, objectRoutes, targetRoutes);
            });
        });
    });
};

/**
 * Produce the routes for the activity entity.
 *
 * @param   {String}                activityType        The type of activity being routed
 * @param   {String}                entityType          The type of entity for which activities are being routed (e.g., actor, object, target)
 * @param   {ActivitySeedResource}  resource            The activity resource that was used to generate the activity entity
 * @param   {Function}              callback            Invoked when the process completes
 * @param   {Object}                callback.err        An error that occurred, if any
 * @param   {String[]}              callback.routes     The routes to which to route the activity
 * @api private
 */
var _produceRoutes = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback(null, []);
    }

    var router = activityRouters[resource.resourceType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, resource, function(err, routes) {
        if (err) {
            return callback(err);
        }

        routes = routes || [];

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'routes': routes
        }, 'Generated routes for activity entity.');
        
        return callback(null, routes);
    });
};

/**
 * Produce an activity entity with the given seed resource information.
 *
 * @param   {String}                activityType            The type of activity for which the entity is being produced
 * @param   {String}                entityType              The type of entity for which the entity is being produced (i.e., actor, object or target)
 * @param   {ActivitySeedResource}  resource                The activity resource that was used to seed the activity
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {ActivityEntity}        callback.activityEntity The activity entity that was produced
 * @param   {String}                callback.propagation    A rule specifying how the activity entity should be propagated across the routes. The possible values are enumerated by `ActivityConstants.entityPropagation`
 * @api private
 */
var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    var producer = activityProducers[resource.resourceType];
    if (!producer) {
        log().error({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource
        }, 'No activity producer found for activity entity.');
        return callback({'code': 500, 'msg': 'No activity producer found for resource type "' + resource.resourceType + '"'});
    }

    producer(activityType, entityType, resource, function(err, entity, propagation) {
        if (err) {
            return callback(err);
        }

        // Ensure a valid propagation, resource id and resource type
        propagation = propagation || ActivityConstants.entityPropagation.DEFAULT;
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity, propagation);
    });
};

var _createAggregates = function(routedActivities) {
    var aggregates = {};
    routedActivities.forEach(function(routedActivity) {
        var route = routedActivity.route;
        var activity = routedActivity.activity;
        var activityType = activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE];
        var activityId = activity[ActivityConstants.properties.OAE_ACTIVITY_ID];

        // Build the entity keys which will be used to create the aggregate key
        var actorKey = _createEntityKey(activity.actor);
        var objectKey = _createEntityKey(activity.object);
        var targetKey = _createEntityKey(activity.target);

        // Determine how this activity will be grouped (a.k.a., pivot points) for aggregation
        var groupBy = (activityTypes[activityType]) ? activityTypes[activityType].groupBy : [];

        // Ensure we atleast have the "all" aggregate, which means we don't get duplicate activities within the same aggregation
        // period.
        if (groupBy.length === 0) {
            groupBy = [{
                'actor': true,
                'object': true,
                'target': true
            }];
        }

        groupBy.forEach(function(pivot) {
            var pivotActorKey = (pivot.actor) ? actorKey : '';
            var pivotObjectKey = (pivot.object) ? objectKey : '';
            var pivotTargetKey = (pivot.target) ? targetKey : '';
            var aggregateKey = util.format('%s#%s#%s#%s#%s', activityType, route, pivotActorKey, pivotObjectKey, pivotTargetKey);

            if (!aggregates[aggregateKey]) {
                aggregates[aggregateKey] = {
                    'route': route,
                    'numberOfActivities': 0,
                    'verb': activity.verb,
                    'published': activity.published,
                    'actors': {},
                    'objects': {},
                    'targets': {}
                };
                aggregates[aggregateKey][ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activityType;
                aggregates[aggregateKey][ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
            }

            var aggregate = aggregates[aggregateKey];
            aggregate.numberOfActivities++;

            if (activity.actor) {
                aggregate.actors[actorKey] = activity.actor;
            }

            if (activity.object) {
                aggregate.objects[objectKey] = activity.object;
            }

            if (activity.target) {
                aggregate.targets[targetKey] = activity.target;
            }

        });
    });

    return aggregates;
};

var _createEntityKey = function(entity) {
    return (entity) ? util.format('%s:%s', entity.objectType, entity[ActivityConstants.properties.OAE_ID]) : ENTITY_KEY_EMPTY;
};

var _createActivityId = function(published) {
    return util.format('%s:%s', published, ShortId.generate());
};

var _getBucketNumber = function(route, activitySeed) {
    var sum = crypto.createHash('md5');
    // Concurrency considerations in activity aggregation / replacement require us to store, at the least, all aggregates of a
    // particular route in one bucket. The reason we include the activity type is because it is still concurrency-safe, and
    // also avoids "hot buckets" when you take into consideration something like a "public" or "loggedin" activity stream.
    // Having "hot buckets" would essentially translate into a hot Cassandra row, since each bucket is a row, which is bad.
    sum.update(route);
    sum.update(activitySeed.activityType);

    return parseInt(sum.digest('hex'), 16) % numberOfProcessingBuckets;
};

var _isExpired = function(aggregateStatus, published) {
    var lastUpdateWasCollected = (aggregateStatus.lastCollected && aggregateStatus.lastCollected > aggregateStatus.lastUpdated);
    var lastUpdateIsIdleExpired = ((published - aggregateStatus.lastModified) > aggregateIdleExpiry);
    var createdMaxIsExpired = ((published - aggregateStatus.created) > aggregateMaxExpiry);
    return (lastUpdateWasCollected && (lastUpdateIsIdleExpired || createdMaxIsExpired));
};

