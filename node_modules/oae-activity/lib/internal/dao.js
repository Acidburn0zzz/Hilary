/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');
var OaeUtil = require('oae-util/lib/util');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;

var activityTtl = null;

/**
 * Refresh the configuration of the DAO.
 *
 * @param   {Number}    activityTtl   The time-to-live (in seconds) for generated activities
 */
var refreshConfiguration = module.exports.refreshConfiguration = function(_activityTtl) {
    activityTtl = _activityTtl;
};

/**
 * Get a list of activities from the specified activity stream.
 *
 * @param   {String}        activityStreamId    The ID of the activity stream
 * @param   {Number|String} start               Number of millis since the epoc (stringified or number version) from which to start returning activities. Only activities older than this timestamp will be returned.
 * @param   {Number}        limit               The number of activities to return
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Activity[]}    callback.activities The list of activities
 */
var getActivities = module.exports.getActivities = function(activityStreamId, start, limit, callback) {
    limit = limit || 25;
    var paging = Cassandra.getPagingParameters(start, limit);
    var activities = [];

    // Selecting with consistency ONE as having great consistency is not critical for activities
    Cassandra.runQuery('SELECT FIRST ? REVERSED ? .. \'\' FROM ActivityStreams USING CONSISTENCY ONE WHERE activityStreamId = ?', [paging.limit, paging.start, activityStreamId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        return callback(null, _rowToActivities(rows[0]));
    });
};

var deliverActivities = module.exports.deliverActivities = function(routedActivities, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error delivering routed activities.');
        }
    };
    
    var queries = [];
    _.keys(routedActivities).forEach(function(route) {
        var activities = routedActivities[route];
        var sets = [];
        var params = [];
        _.keys(activities).forEach(function(activityId) {
            var activity = activities[activityId];
            var activityStr = JSON.stringify(activity);
            sets.push('? = ?');
            params.push(activityId, activityStr);
        });

        params.push(route);

        queries.push({
            'query': 'UPDATE ActivityStreams USING TTL ' + activityTtl + ' SET ' + sets.join(', ') + ' WHERE activityStreamId = ?',
            'parameters': params
        });
    });

    // Saving activities with consistency ONE because consistency is not critical for activities
    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

var deleteActivities = module.exports.deleteActivities = function(routeActivityIds, callback) {
    var routes = _.keys(routeActivityIds);
    if (routes.length === 0) {
        return callback();
    }

    var queries = [];
    routes.forEach(function(route) {
        var activityIds = routeActivityIds[route];
        if (activityIds.length === 0) {
            return;
        }

        var placeholders = [];
        var params = [];
        activityIds.forEach(function(activityId) {
            placeholders.push('?');
            params.push(activityId);
        });
        params.push(route);

        queries.push({
            'query': 'DELETE ' + placeholders.join(', ') + ' FROM ActivityStreams WHERE activityStreamId = ?',
            'parameters': params
        });
    });

    Cassandra.runBatchQuery(queries, 'ONE', callback);
};

var saveQueuedActivities = module.exports.saveQueuedActivities = function(activitySeed, activityBuckets, callback) {
    if (activityBuckets.length === 0) {
        return callback();
    }

    var now = Date.now();
    var queries = [];
    for (var i = 0; i < activityBuckets.length; i++) {
        var activityBucket = activityBuckets[i];
        if (activityBucket && activityBucket.length) {
            var sets = [];
            var params = [];
            activityBucket.forEach(function(routedActivity) {
                sets.push('? = ?');
                // Order by time to they are prioritized
                params.push(util.format('%s:%s', routedActivity.activity[ActivityConstants.properties.OAE_ACTIVITY_ID], routedActivity.route));
                params.push(JSON.stringify(routedActivity));
            });

            params.push(i);

            queries.push({
                'query': 'UPDATE ActivityProcessingBuckets SET ' + sets.join(', ') + ' WHERE bucketId = ?',
                'parameters': params
            });
        }
    }

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

var getQueuedActivities = module.exports.getQueuedActivities = function(bucketNumber, limit, callback) {
    limit = parseInt(limit, 10);
    limit = (isNaN(limit) || limit < 1) ? 1000 : limit;
    Cassandra.runQuery('SELECT FIRST ' + limit + ' REVERSED * FROM ActivityProcessingBuckets USING CONSISTENCY QUORUM WHERE bucketId = ?', [bucketNumber], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var queuedActivities = {};
        rows[0].forEach(function(name, value) {
            try {
                queuedActivities[name] = JSON.parse(value);
            } catch (err) {
                log().warn({'err': err}, 'Error parsing queued activity from bucket %s', bucketNumber);
                // We still need to return this value as the caller will want to know this key exists for deletion
                queuedActivities[name] = null;
            }
        });

        return callback(null, queuedActivities);
    });
};

var deleteQueuedActivities = module.exports.deleteQueuedActivities = function(bucketNumber, queuedActivityIds, callback) {
    if (queuedActivityIds.length === 0) {
        return callback();
    }

    var placeholders = [];
    var params = [];
    queuedActivityIds.forEach(function(queuedActivityId) {
        placeholders.push('?');
        params.push(queuedActivityId);
    });

    params.push(bucketNumber);

    Cassandra.runQuery('DELETE ' + placeholders.join(', ') + ' FROM ActivityProcessingBuckets USING CONSISTENCY QUORUM WHERE bucketId = ?', params, callback);
};

var getAggregateStatus = module.exports.getAggregateStatus = function(aggregateKeys, callback) {
    if (aggregateKeys.length === 0) {
        return callback(null, {});
    }

    var aggregateStatus = {};
    Cassandra.runQuery('SELECT * FROM ActivityAggregateStatus USING CONSISTENCY QUORUM WHERE aggregateKey IN (?)', [aggregateKeys], function(err, rows) {
        if (err) {
            return callback(err);
        }

        rows.forEach(function(row) {
            var status = Cassandra.rowToHash(row);
            if (!status.lastUpdated) {
                return;
            }
            aggregateStatus[status.aggregateKey] = status;
        });

        return callback(null, aggregateStatus);
    });
};

var updateAggregateStatus = module.exports.updateAggregateStatus = function(statusUpdates, callback) {
    var aggregateKeys = _.keys(statusUpdates);
    if (aggregateKeys.length === 0) {
        return callback();
    }

    var queries = [];
    aggregateKeys.forEach(function(aggregateKey) {
        var query = Cassandra.constructUpsertCQL('ActivityAggregateStatus', 'aggregateKey', aggregateKey, statusUpdates[aggregateKey]);
        if (query) {
            queries.push(query);
        } else {
            log().warn({'statusUpdate': statusUpdates[aggregateKey]}, 'Failed to persist update for aggregate status.');
        }
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

var deleteAggregates = module.exports.deleteAggregates = function(aggregateKeys, callback) {
    if (aggregateKeys.length === 0) {
        return callback();
    }

    // Delete both the aggregated entities and the aggregate status
    var queries = [
        {
            'query': 'DELETE FROM ActivityAggregateStatus WHERE aggregateKey IN (?)',
            'parameters': [aggregateKeys]
        },
        {
            'query': 'DELETE FROM ActivityAggregateEntities WHERE aggregateKey IN (?)',
            'parameters': [aggregateKeys]
        }
    ];

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

var getAggregatedEntities = module.exports.getAggregatedEntities = function(aggregateKeys, callback) {
    if (aggregateKeys.length === 0) {
        return callback(null, {});
    }

    var entityAggregateKeys = [];
    aggregateKeys.forEach(function(aggregateKey) {
        entityAggregateKeys.push(aggregateKey + '#actors', aggregateKey + '#objects', aggregateKey + '#targets');
    });

    var aggregatedEntities = {};
    Cassandra.runQuery('SELECT * FROM ActivityAggregateEntities USING CONSISTENCY QUORUM WHERE aggregateKey IN (?)', [entityAggregateKeys], function(err, rows) {
        if (err) {
            return callback(err);
        }

        rows.forEach(function(row) {
            var aggregateKey = row.key.split('#');
            var entityType = aggregateKey[aggregateKey.length - 1];
            aggregateKey = aggregateKey.slice(0, -1).join('#');

            aggregatedEntities[aggregateKey] = aggregatedEntities[aggregateKey] || {
                'actors': {},
                'objects': {},
                'targets': {}
            };

            row.forEach(function(name, value) {
                // Don't include the primary key column
                if (name === 'aggregateKey') {
                    return;
                }

                try {
                    // entityType will be one of actors, objects or targets
                    aggregatedEntities[aggregateKey][entityType][name] = JSON.parse(value);
                } catch (err) {
                    log().warn({
                        'err': err,
                        'aggregateKey': aggregateKey,
                        'entityKey': name
                    }, 'Error parsing entity from aggregated activity entities. Skipping.');
                }
            });
        });

        return callback(null, aggregatedEntities);
    });
};

var saveAggregatedEntities = module.exports.saveAggregatedEntities = function(aggregates, callback) {
    var aggregateKeys = _.keys(aggregates);
    if (aggregateKeys.length === 0) {
        return callback();
    }

    var queries = [];
    aggregateKeys.forEach(function(aggregateKey) {
        var aggregate = aggregates[aggregateKey];
        var actors = aggregate.actors;
        var objects = aggregate.objects;
        var targets = aggregate.targets;

        // Create the actor entity updates
        var sets = [];
        var params = [];
        var keys = _.keys(actors);
        if (keys.length > 0) {
            keys.forEach(function(actorKey) {
                sets.push('? = ?');
                params.push(actorKey, JSON.stringify(actors[actorKey]));
            });

            // We post-fix the aggregate with actor, because it's just the actor entities
            params.push(aggregateKey + '#actors');

            queries.push({
                'query': 'UPDATE ActivityAggregateEntities SET ' + sets.join(', ') + ' WHERE aggregateKey = ?',
                'parameters': params
            });
        }

        // Create the object entity updates
        sets = [];
        params = [];
        keys = _.keys(objects);
        if (keys.length > 0) {
            keys.forEach(function(objectKey) {
                sets.push('? = ?');
                params.push(objectKey, JSON.stringify(objects[objectKey]));
            });

            params.push(aggregateKey + '#objects');

            queries.push({
                'query': 'UPDATE ActivityAggregateEntities SET ' + sets.join(', ') + ' WHERE aggregateKey = ?',
                'parameters': params
            });
        }

        // Create the target entity updates
        sets = [];
        params = [];
        keys = _.keys(targets);
        if (keys.length > 0) {
            keys.forEach(function(targetKey) {
                sets.push('? = ?');
                params.push(targetKey, JSON.stringify(targets[targetKey]));
            });

            params.push(aggregateKey + '#targets');

            queries.push({
                'query': 'UPDATE ActivityAggregateEntities SET ' + sets.join(', ') + ' WHERE aggregateKey = ?',
                'parameters': params
            });
        }
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

/**
 * Convert a Cassandra row into an array of activities extracted from its columns.
 *
 * @param   {Row}       row         The Cassandra row from which to extract the activities
 * @return  {Object}                The activities that were extracted from the rows
 */
var _rowToActivities = function(row) {
    var activities = [];
    row.forEach(function(name, value) {
        try {
            activities.push(JSON.parse(value));
        } catch (err) {
            log().warn({'err': err}, 'Error parsing activity value.');
        }
    });
    return activities;
};


