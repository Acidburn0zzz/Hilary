/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzUtil = require('oae-authz/lib/util');
var Context = require('oae-context').Context;
var EmailAPI = require('oae-email');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-activity-email');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Redis = require('oae-util/lib/redis');
var Telemetry = require('oae-telemetry').telemetry('activity-email');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var UIAPI = require('oae-ui');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./dao');
var ActivityEmitter = require('./emitter');
var ActivityModel = require('oae-activity/lib/model');
var ActivityRegistry = require('./registry');
var ActivitySystemConfig = require('./config');
var ActivityTransformer = require('./transformer');
var ActivityUtil = require('oae-activity/lib/util');

var ActivityAdapter = require('../../../../../3akai-ux/node_modules/oae-bundles/activityadapter/js/activityadapter');

/*!
 * When activities get delivered to a stream
 */
ActivityEmitter.on(ActivityConstants.events.ROUTED_ACTIVITIES, function(activitySeed, allActivities) {
    var routes = _.keys(allActivities);
    var usersToMail = _.chain(allActivities).keys().filter(function(route) {
        // Filter out any non-email route
        return (route.split('#').slice(1).join('#') === 'email');
    }).map(function(route) {
        // Return the user ID
        return route.split('#')[0];
    }).uniq().value();

    // If there was no route to an email stream, we can stop early
    if (usersToMail.length === 0) {
        return;
    }

    // We need to know the email preferences for each user so we know whether and when to send them an e-mail
    PrincipalsDAO.getPrincipals(usersToMail, ['principalId', 'tenantAlias', 'email', 'emailPreference', 'timezone'], function(err, users) {
        if (err) {
            return log().error({'err': err, 'usersToMail': usersToMail}, 'Failed to get the email preference field for all the users in this activity');
        }

        var usersPreferences = {};
        _.each(users, function(user) {
            // Users without a valid email address or who've opted out of email notifications should not get emails
            if (!user.email || !user.emailPreference || user.emailPreference === PrincipalsConstants.emailPreferences.NEVER) {
                return;
            }

            usersPreferences[user.id] = {'emailPreference': user.emailPreference, 'timezone': (user.timezone || 'UTC')};
        });


        ActivityDAO.queueUsersForEmail(usersPreferences, function(err) {
            if (err) {
                log().error({'err': err, 'activitySeed': activitySeed}, 'Unable to store the IDs of the users who need to receive mail');
            }

            log().trace({'usersPreferences': usersPreferences, 'activitySeed': activitySeed}, 'Queued mail for users');
            Telemetry.incr('queued.count');
        });
    });
});


///////////////////////
// Bucket collection //
///////////////////////


var currentConcurrentCollectionCount = 0;

var shuttingDown = false;

/**
 * Perform a full collection of all activity buckets. If any bucket is already locked by another process, it will be skipped. When
 * this process completes and the callback is invoked, it will guarantee that:
 *
 * a) This process was not allowed to start another collection cycle, as there were too many occuring; or
 * b) for every bucket that wasn't locked, it was collected until it was empty.
 *
 * This is most useful for unit tests to ensure that all activities up until a point in time have been aggregated and delivered.
 *
 * @param  {Function}   [callback]      Invoked when collection is complete.
 * @param  {Object}     [callback.err]  An error that occurred, if any
 */
var collectAllBuckets = module.exports.collectAllBuckets = function(callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error collecting aggregates.');
        }
    };

    // Ensure we don't surpass the configured number of concurrent collections
    if (currentConcurrentCollectionCount >= ActivitySystemConfig.getConfig().maxConcurrentCollections) {
        log().trace('Aborting collection due to max concurrent collections count reached.');
        return callback();
    }
    currentConcurrentCollectionCount++;

    // Fill all the possible bucket numbers to collect
    var bucketNumbers = [];
    for (var i = 0; i < ActivitySystemConfig.getConfig().numberOfProcessingBuckets; i++) {
        bucketNumbers.push(i);
    }

    log().trace('Beginning collection of %s buckets.', bucketNumbers.length);

    // Perform a collection cycle on the bucket numbers
    collectBuckets(bucketNumbers, function(err) {
        log().trace('Completed collection cycle.');

        // Mark that this collection cycle has completed, whether or not there was an error
        currentConcurrentCollectionCount--;
        return callback(err);
    });
};

/**
 * Collects the given array of bucket numbers until they are empty, or "stolen". This process will skip over buckets that are
 * in the process of being collected. Therefore, if all buckets in the array are currently undergoing collection, this will not
 * actually perform any collections. This process will only attempt to collect one bucket at a time in order given in the array.
 *
 * @param  {Number[]}   bucketNumbers   The buckets that should be collected by this cycle.
 * @param  {Function}   callback        Invoked when the collection cycle completes.
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object[]}   [errs]          Maintains a list of errors that occurred during collection. Used recursively.
 */
var collectBuckets = module.exports.collectBuckets = function(bucketNumbers, callback, errs) {
    errs = errs || [];
    if (_.isEmpty(bucketNumbers)) {
        // Return the first error, if there was any.
        return callback(errs[0]);
    }

    var bucketNumber = bucketNumbers.shift();
    _collectBucket(bucketNumber, function(err) {
        if (err) {
            log().warn({'err': err, 'bucketNumber': bucketNumber}, 'Error collecting aggregate bucket');
            Telemetry.incr('collection.error.count');
            errs.push(err);
        }

        collectBuckets(bucketNumbers, callback, errs);
    });
};

/**
 * Collect the provided bucket number until it is empty (or "stolen"). If the bucket is already being collected, this will
 * effectively do nothing.
 *
 * @param  {Number}    bucketNumber        The number of the bucket to collect.
 * @param  {Function}  callback            Invoked when collection is complete.
 * @param  {Object}    callback.err        An error that occurred, if any.
 * @api private
 */
var _collectBucket = function(bucketNumber, callback) {
    if (shuttingDown) {
        log().info('Aborting activity bucket collection of bucket %s as shutdown is in progress', bucketNumber);
        return callback();
    }

    log().trace('Attempting collection of bucket number %s', bucketNumber);
    // Try and acquire a lock on the bucket to collect the next batch
    Locking.acquire(_getLockKey(bucketNumber), ActivitySystemConfig.getConfig().collectionExpiry, function(err, lockId) {
        if (err) {
            return callback(err);
        } else if (lockId) {
            log().trace({'lockId': lockId}, 'Acquired a lock on bucket number %s', bucketNumber);

            // We acquired the lock, perform a collection iteration
            _collectBucketBatch(bucketNumber, ActivitySystemConfig.getConfig().collectionBatchSize, function(collectionErr, empty) {
                // We want to ensure we release the bucket, whether we received an error or not
                Locking.release(_getLockKey(bucketNumber), lockId, function(releaseErr, hadLock) {
                    if (collectionErr) {
                        return callback(collectionErr);
                    } else if (releaseErr) {
                        log().warn({'err': releaseErr}, 'An unexpected error occurred while releasing the lock from bucket number %s', bucketNumber);

                        // If there was an error releasing the lock, worst case scenario would be that the lock eventually expires
                        // and a cluster node picks it up soon after that and continues processing.
                        return callback(releaseErr);
                    }

                    log().trace({'lockId': lockId}, 'Successfully released lock for bucket number %s', bucketNumber);

                    if (!hadLock) {
                        // This means that the lock expired before we finished collecting, which likely means the lock expiry
                        // is not configured high enough for the collection batch size. Send an error, because it will almost
                        // certainly end up in a noticeable degradation of user experience.
                        log().error({
                            'collectionExpiry': ActivitySystemConfig.getConfig().collectionExpiry,
                            'collectionBatchSize': ActivitySystemConfig.getConfig().collectionBatchSize
                        }, 'The bucket lock expired before we finished collecting a batch of activities. This probably means that ' +
                           'it takes longer than the "collectionExpiry" number of seconds to collect "collectionBatchSize" number of ' +
                           'activities. Consider either increasing "collectionExpiry" or decreasing "collectionBatchSize" to fix this ' +
                           'problem.');
                    }

                    if (empty) {
                        // The bucket is now empty, return to the caller
                        return callback();
                    }

                    // The bucket isn't empty, try another collection iteration
                    return _collectBucket(bucketNumber, callback);
                });
            });
        } else {
            // We could not acquire a lock, someone else came around and managed to snag the bucket
            return callback();
        }
    });
};

/**
 * Get the lock key for the given bucket number. The bucket lock key will look like: oae-activity:bucket:lock-0
 * for the 0th bucket, for example.
 *
 * @param  {Number}    bucketNumber    The bucket number for which to create the lock key.
 * @return {String}                    The key that can be used to lock the bucket with the given number.
 * @api private
 */
var _getLockKey = function(bucketNumber) {
    return util.format('oae-activity:email-bucket:lock-%s', bucketNumber);
};

/**
 * Collects a bucket of queued emails
 *
 * @param  {Number}    bucketNumber        The bucket to process
 * @param  {Number}    limit               The number of users to handle at any given time
 * @param  {Function}  callback            Invoked when the batch has been processed
 * @param  {Object}    callback.err        An error that occurred, if any
 * @api private
 */
var _collectBucketBatch = function(bucketNumber, limit, callback) {
    _handleImmediateEmails(bucketNumber, limit, function(err) {
        if (err) {
            return callback(err);
        }

        _handleDailyEmails(bucketNumber, limit, function(err) {
            if (err) {
                return callback(err);
            }

            _handleWeeklyEmails(bucketNumber, limit, callback);
        });
    });
};

/**
 * Collect all the mails that are queued for immediate delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Number}     limit               The number of users to handle at any given time
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _handleImmediateEmails = function(bucketNumber, limit, callback) {
    _collectMails(bucketNumber, PrincipalsConstants.emailPreferences.IMMEDIATE, 0, null, limit, callback);
};

/**
 * Collect all the mails that are queued for daily delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Number}     limit               The number of users to handle at any given time
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _handleDailyEmails = function(bucketNumber, limit, callback) {
    var config = ActivitySystemConfig.getConfig();
    var now = new Date();
    var end = new Date(now.getTime() + (config.mail.pollingFrequency * 1000));
    var collectAt = new Date(now.getFullYear(), now.getMonth(), now.getDate(), config.mail.daily.hour, 0, 0, 0);
    if ((now < collectAt && collectAt < end)) {
        return _collectMails(bucketNumber, PrincipalsConstants.emailPreferences.DAILY, now.getHours() + 1, null, limit, callback);
    } else {
        return callback(null, true);
    }
};

/**
 * Collect all the mails that are queued for weekly delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Number}     limit               The number of users to handle at any given time
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _handleWeeklyEmails = function(bucketNumber, limit, callback) {
    if (_isWeeklyCycle()) {
        var hour = new Date().getHours() + 1;
        return _collectMails(bucketNumber, PrincipalsConstants.emailPreferences.WEEKLY, hour, null, limit, callback);
    } else {
        return callback(null, true);
    }
};

/**
 * Checks whether the weekly aggregate mails should be sent out now
 *
 * @return {Boolean}    Whether or not weekly mails should be collected
 * @api private
 */
var _isWeeklyCycle = function() {
    var config = ActivitySystemConfig.getConfig();

    // If today is not the day of (or the day before) the weekly collection cycle, there is no need to check further
    // We need to include the day before as we might want to collect weekly mails at midnight
    var now = new Date();
    var today = now.getDay();
    if (today === config.mail.weekly.day || today === ((config.mail.weekly.day + 6) % 7)) {
        var day = now.getDate() + (config.mail.weekly.day - now.getDay());
        var collectAt = new Date(now.getFullYear(), now.getMonth(), day, config.mail.weekly.hour, 0, 0, 0);
        var end = new Date(now.getTime() + (config.mail.pollingFrequency * 1000));
        return (now < collectAt && collectAt < end);
    } else {
        return false;
    }
};

/**
 * Drain an e-mail bucket by sending the correct e-mail to everybody whose in it.
 *
 * Steps:
 *   1.  Get all the users whom we need to mail in this iteration
 *   2.  Stop aggregating for those user's their email activity streams
 *   3.  Collect all the activities from those streams
 *   4.  Remove the activities from those streams as they are no longer required
 *   5.  Send mail
 *
 * @param  {Number}     bucketNumber        he bucket to process
 * @param  {String}     emailPreference     Which bucket type the users should be retrieved from. One of {@see PrincipalsConstants.emailPreferences}
 * @param  {String}     start               A user id that can be used as a starting point to page the users that are in the email bucket
 * @param  {Number}     limit               The number of users to handle at any given time
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _collectMails = function(bucketNumber, emailPreference, hour, start, limit, callback) {
    var collectionStart = Date.now();
    log().trace('Collecting batch of %s users from bucket number %s:%s.', limit, bucketNumber, emailPreference);

    // 1. Get a set of users for whom we need to mail in this iteration
    ActivityDAO.getQueuedUsersForEmail(bucketNumber, emailPreference, hour, start, limit, function(err, users, nextToken) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(users)) {
            return callback(null, true);
        }

        // Get all the active aggregate keys that will be included in this e-mail
        // We remove them immediately, so that the next e-mail doesn't contain the same activities.
        var activityStreams = [];
        var userIds = [];
        _.each(users, function(user) {
            activityStreams.push(user.userId + '#email');
            userIds.push(user.userId);
        });
        ActivityDAO.resetAggregationForActivityStreams(activityStreams, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove the users from the buckets
            ActivityDAO.unqueueUsersForEmail(bucketNumber, users, hour, function(err) {
                if (err) {
                    return callback(err);
                }

                // Get all the activities that should be included in the emails
                ActivityDAO.getActivitiesFromMultipleStreams(activityStreams, function(err, activitiesPerStream) {
                    if (err) {
                        return callback(err);
                    }

                    // Delete these activities as we will be pushing them out
                    ActivityDAO.deleteActivitiesFromMultipleStreams(activitiesPerStream, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Get all the users
                        PrincipalsDAO.getPrincipals(userIds, null, function(err, users) {
                            if (err) {
                                log().error({'err': err, 'userIds': userIds}, 'Failed to get the users when sending email');
                                return callback(err);
                            }

                            // Keep track of whom we need to email
                            var toMail = [];
                            _.each(users, function(user) {
                                // Users without a valid email address or who've opted out of email notifications should not get emails
                                if (!user.email || !user.emailPreference || user.emailPreference === PrincipalsConstants.emailPreferences.NEVER) {
                                    return;
                                }
                                toMail.push({'user': user, 'activities': activitiesPerStream[user.id + '#email']});
                            });

                            _mailAll(toMail, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                Telemetry.incr(util.format('sent.%s.count', emailPreference), userIds.length);
                                Telemetry.appendDuration(util.format('sent.%s.time', emailPreference), collectionStart);

                                var isEmpty = (_.isNull(nextToken));
                                return callback(null, isEmpty);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Mails a set of users
 *
 * @param  {Object[]}   toMail          An object containing the `user` and the `activities` they should receive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var _mailAll = function(toMail, callback) {
    if (_.isEmpty(toMail)) {
        return callback();
    }

    var to = toMail.pop();
    _mail(to.user, to.activities, function(err) {
        if (err) {
            return callback(err);
        }

        _mailAll(toMail, callback);
    });
};

/**
 * Send a mail to a user
 *
 * @param  {User}           user            The user to mail
 * @param  {Activity[]}     activities      The set of activities that should go in the mail
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Standard error object, if any
 * @api private
 */
var _mail = function(user, activities, callback) {
    var tenant = TenantsAPI.getTenant(user.tenant.alias);
    var ctx = new Context(tenant, user);
    ActivityTransformer.transformActivities(ctx, activities, 'activitystreams', function(err) {
        if (err) {
            log().error({'err': err}, 'Could not transform activities for mail');
            return callback(err);
        }

        var skinVariables = UIAPI.getTenantSkinVariables(tenant.alias);
        var adaptedActivities = ActivityAdapter.adapt(user, activities);
        var data = {
            'activities': adaptedActivities,
            'tenant': tenant,
            'user': user,
            'baseUrl': TenantsUtil.getBaseUrl(tenant),
            'skinVariables': skinVariables
        };

        EmailAPI.sendEmail('oae-activity', 'mail', user, data, {}, callback);
    });
};
