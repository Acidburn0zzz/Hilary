/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzUtil = require('oae-authz/lib/util');
var Context = require('oae-context').Context;
var EmailAPI = require('oae-email');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-activity-email');
var PrincipalsConfig = require('oae-config').config('oae-principals');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsAPI = require('oae-principals');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Redis = require('oae-util/lib/redis');
var Telemetry = require('oae-telemetry').telemetry('activity-email');
var TenantsAPI = require('oae-tenants');
var TenantsUtil = require('oae-tenants/lib/util');
var UIAPI = require('oae-ui');

var ActivityAggregator = require('./aggregator');
var ActivityBuckets = require('./buckets');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./dao');
var ActivityEmitter = require('./emitter');
var ActivityModel = require('oae-activity/lib/model');
var ActivityRegistry = require('./registry');
var ActivitySystemConfig = require('./config');
var ActivityTransformer = require('./transformer');
var ActivityUtil = require('oae-activity/lib/util');

// The maximum amount of users can be handled during a bucket collection
var MAX_COLLECTION_BATCH_SIZE = 50;

/*!
 * When activities get delivered to a stream, we check if any were delivered to an
 * `email` stream and queue them for email delivery.
 */
ActivityEmitter.on(ActivityConstants.events.ROUTED_ACTIVITIES, function(activitySeed, allActivities) {
    var routes = _.keys(allActivities);
    var usersToMail = _.chain(allActivities).keys().filter(function(activityStreamId) {
        // Filter out any non-email route
        return (allActivities[activityStreamId].streamType === 'email');
    }).map(function(activityStreamId) {
        // Return the user ID
        return allActivities[activityStreamId].resourceId;
    }).uniq().value();

    // If there were no activities delivered in email streams we can stop here
    if (_.isEmpty(usersToMail)) {
        return;
    }

    // We need to know the email preferences for each user so we know whether and when to send them an e-mail
    PrincipalsDAO.getPrincipals(usersToMail, ['principalId', 'tenantAlias', 'email', 'emailPreference'], function(err, users) {
        if (err) {
            return log().error({'err': err, 'usersToMail': usersToMail}, 'Failed to get the email preference field for all the users in this activity');
        }

        var usersToQueue = _.filter(users, function(user) {
            // Users without a valid email address or who've opted out of email notifications should not get emails
            return (user.email && user.emailPreference && user.emailPreference !== PrincipalsConstants.emailPreferences.NEVER);
        });

        ActivityDAO.queueUsersForEmail(usersToQueue, function(err) {
            if (err) {
                log().error({'err': err, 'activitySeed': activitySeed}, 'Unable to store the IDs of the users who need to receive mail');
            }

            log().trace({'usersToQueue': usersToQueue, 'activitySeed': activitySeed}, 'Queued mail for users');
            Telemetry.incr('queued.count');
        });
    });
});


/////////////////
// UPDATE-USER //
/////////////////

/*!
 * When a user changes his email preferences we re-queue him in the correct email bucket
 */
PrincipalsAPI.on(PrincipalsConstants.events.UPDATED_USER, function(ctx, newUser, oldUser) {
    // If the user's email preference didn't change we don't have to do anything
    if (newUser.emailPreference === oldUser.emailPreference) {
        return ActivityEmitter.emit(ActivityConstants.events.UPDATED_USER, ctx, newUser, oldUser);
    }

    // Take the user out of the old bucket
    var timezone = PrincipalsConfig.getValue(newUser.tenant.alias, 'user', 'timezone');
    var bucketId = ActivityDAO.createEmailBucketIdForUser(oldUser.id, oldUser.emailPreference, timezone);
    ActivityDAO.unqueueUsersForEmail(bucketId, [oldUser.id], function(err) {
        if (err) {
            return log().error({'err': err, 'user': oldUser.id}, 'Unable to unqueue a user from an email bucket when he changed his preference');
        } else if (newUser.emailPreference === PrincipalsConstants.emailPreferences.NEVER) {
            // The user has opted out of email delivery
            return ActivityEmitter.emit(ActivityConstants.events.UPDATED_USER, ctx, newUser, oldUser);
        }

        // Queue the user with his new email preference. If he has no pending emails,
        // he will be ignored during the collection cycle
        ActivityDAO.queueUsersForEmail([newUser], function(err) {
            if (err) {
                log().error({'err': err, 'user': newUser.id}, 'Could not re-queue the user for email');
            }
            ActivityEmitter.emit(ActivityConstants.events.UPDATED_USER, ctx, newUser, oldUser);
        });
    });
});


///////////////////////
// Bucket collection //
///////////////////////


/**
 * Perform a full collection of all email buckets. If any bucket is already locked by another process, it will be skipped. When
 * this process completes and the callback is invoked, it will guarantee that:
 *
 * a) This process was not allowed to start another collection cycle, as there were too many occuring; or
 * b) for every bucket that wasn't locked, it was collected until it was empty.
 *
 * This is most useful for unit tests to ensure that all emails up until a point in time have been aggregated and delivered.
 *
 * @param  {Function}   [callback]      Invoked when collection is complete
 * @param  {Object}     [callback.err]  An error that occurred, if any
 */
var collectAllBuckets = module.exports.collectAllBuckets = function(callback) {
    var nrOfBuckets = ActivitySystemConfig.getConfig().numberOfProcessingBuckets;
    var maxConcurrentCollections = ActivitySystemConfig.getConfig().maxConcurrentCollections;
    var collectionExpiry = ActivitySystemConfig.getConfig().collectionExpiry;
    ActivityBuckets.collectAllBuckets('email', nrOfBuckets, maxConcurrentCollections, collectionExpiry, _collectBucket, callback);
};

/**
 * Collects a bucket of queued emails
 *
 * @param  {Number}    bucketNumber        The bucket to process
 * @param  {Function}  callback            Invoked when the batch has been processed
 * @param  {Object}    callback.err        An error that occurred, if any
 * @api private
 */
var _collectBucket = function(bucketNumber, callback) {
    _handleImmediateEmails(bucketNumber, function(err) {
        if (err) {
            return callback(err);
        }

        _handleDailyEmails(bucketNumber, function(err) {
            if (err) {
                return callback(err);
            }

            _handleWeeklyEmails(bucketNumber, callback);
        });
    });
};

/**
 * Collect all the mails that are queued for immediate delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _handleImmediateEmails = function(bucketNumber, callback) {
    collectMails(bucketNumber, PrincipalsConstants.emailPreferences.IMMEDIATE, 0, callback);
};

/**
 * Collect all the mails that are queued for daily delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _handleDailyEmails = function(bucketNumber, callback) {
    var config = ActivitySystemConfig.getConfig();
    var now = new Date();
    var end = new Date(now.getTime() + (config.mail.pollingFrequency * 1000));
    var collectAt = new Date(now.getFullYear(), now.getMonth(), now.getDate(), config.mail.daily.hour, 0, 0, 0);
    if ((now < collectAt && collectAt < end)) {
        return collectMails(bucketNumber, PrincipalsConstants.emailPreferences.DAILY, now.getHours() + 1, callback);
    } else {
        return callback(null, true);
    }
};

/**
 * Collect all the mails that are queued for weekly delivery
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @api private
 */
var _handleWeeklyEmails = function(bucketNumber, callback) {
    if (_isWeeklyCycle()) {
        var hour = new Date().getHours() + 1;
        return collectMails(bucketNumber, PrincipalsConstants.emailPreferences.WEEKLY, hour, callback);
    } else {
        return callback(null, true);
    }
};

/**
 * Checks whether the weekly aggregate mails should be sent out now
 *
 * @return {Boolean}    Whether or not weekly mails should be collected
 * @api private
 */
var _isWeeklyCycle = function() {
    var config = ActivitySystemConfig.getConfig();

    // If today is not the day of (or the day before) the weekly collection cycle, there is no need to check further
    // We need to include the day before as we might want to collect weekly mails at midnight
    var now = new Date();
    var today = now.getDay();
    if (today === config.mail.weekly.day || today === ((config.mail.weekly.day + 6) % 7)) {
        var day = now.getDate() + (config.mail.weekly.day - now.getDay());
        var collectAt = new Date(now.getFullYear(), now.getMonth(), day, config.mail.weekly.hour, 0, 0, 0);
        var end = new Date(now.getTime() + (config.mail.pollingFrequency * 1000));
        return (now < collectAt && collectAt < end);
    } else {
        return false;
    }
};

/**
 * Drain an e-mail bucket by sending the correct e-mail to everybody whose in it.
 *
 * Steps:
 *   1.  Get all the users whom we need to mail in this iteration
 *   2.  Stop aggregating for those user's their email activity streams
 *   3.  Unqueue the users from the email bucket
 *   4.  Collect all the activities from those streams
 *   5.  Remove the activities from those streams as they are no longer required
 *   6.  Send mail
 *
 * Note that this function is only exported for testing purposes. You should use `collectAllBuckets`
 * as this method will *NOT* perform any locking on the processed bucket.
 *
 * @param  {Number}     bucketNumber        The bucket to process
 * @param  {String}     emailPreference     Which bucket type the users should be retrieved from. One of {@see PrincipalsConstants.emailPreferences}
 * @param  {Number}     hour                Identifies the hour for which the users are scheduled
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.empty      Whether or not the bucket is empty
 * @param  {User[]}     callback.users      The users that received an email
 */
var collectMails = module.exports.collectMails = function(bucketNumber, emailPreference, hour, callback) {
    var collectionStart = Date.now();
    log().trace('Collecting batch of %s users from bucket number %s:%s.', MAX_COLLECTION_BATCH_SIZE, bucketNumber, emailPreference);

    // 1. Get a set of users for whom we need to mail in this iteration
    ActivityDAO.getQueuedUsersForEmail(bucketNumber, emailPreference, hour, null, MAX_COLLECTION_BATCH_SIZE, function(err, bucketId, userIds, nextToken) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(userIds)) {
            return callback(null, true, []);
        }

        // 2. Reset aggregation for the email streams for the queued, so that the next e-mail doesn't contain the same activities
        var activityStreamIds = _.map(userIds, function(userId) {
            return util.format('%s#email', userId);
        });
        ActivityDAO.resetAggregationForActivityStreams(activityStreamIds, function(err) {
            if (err) {
                return callback(err);
            }

            // 3. Remove the users from the buckets
            ActivityDAO.unqueueUsersForEmail(bucketId, userIds, function(err) {
                if (err) {
                    return callback(err);
                }

                // 4. Get all the activities that should be included in the emails
                ActivityDAO.getActivitiesFromStreams(activityStreamIds, function(err, activitiesPerStream) {
                    if (err) {
                        return callback(err);
                    }

                    // 5. Delete these activities as we will be pushing them out
                    var activitiesPerStreamToDelete = {};
                    _.each(activitiesPerStream, function(activities, activityStreamId) {
                        activitiesPerStreamToDelete[activityStreamId] = _.pluck(activities, 'oae:activityId');
                    });
                    ActivityDAO.deleteActivities(activitiesPerStreamToDelete, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Get all the user profiles
                        PrincipalsDAO.getPrincipals(userIds, null, function(err, users) {
                            if (err) {
                                log().error({'err': err, 'userIds': userIds}, 'Failed to get the users when sending email');
                                return callback(err);
                            }

                            // Keep track of whom we need to email
                            var usersToMail = _.filter(users, function(user) {
                                // Although it's very unlikely that a user who changed his email preferences would end up here,
                                // we take it into account as it would be really unfortunate to send him any further email. Additionally,
                                // if the email stream for the user was empty (because he marked his notifications as read), we can't send
                                // him any mail either
                                return (user.emailPreference !== PrincipalsConstants.emailPreferences.NEVER &&
                                        activitiesPerStream[user.id + '#email'] && activitiesPerStream[user.id + '#email'].length > 0);
                            });

                            // Transform the users array so the activities are included
                            var toMail = _.map(usersToMail, function(user) {
                                 return {'user': user, 'activities': activitiesPerStream[user.id + '#email']};
                            });

                            // 6. Send out the emails
                            _mailAll(toMail, function(err) {
                                if (err) {
                                    return callback(err);
                                }

                                Telemetry.incr(util.format('sent.%s.count', emailPreference), userIds.length);
                                Telemetry.appendDuration(util.format('sent.%s.time', emailPreference), collectionStart);

                                var isEmpty = (_.isNull(nextToken));
                                return callback(null, isEmpty, usersToMail);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Mails a set of users
 *
 * @param  {Object[]}   toMail          An object containing the `user` and the `activities` they should receive
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 * @api private
 */
var _mailAll = function(toMail, callback) {
    if (_.isEmpty(toMail)) {
        return callback();
    }

    var to = toMail.pop();
    _mail(to.user, to.activities, function(err) {
        if (err) {
            return callback(err);
        }

        _mailAll(toMail, callback);
    });
};

/**
 * Send a mail to a user
 *
 * @param  {User}           user            The user to mail
 * @param  {Activity[]}     activities      The set of activities that should go in the mail
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Standard error object, if any
 * @api private
 */
var _mail = function(user, activities, callback) {
    // Given that we support weekly deliveries, there is a possibility that there are 2 activities
    // present in the activity stream that could aggregate.
    var aggregatedActivities = _aggregate(user.id, activities);

    // Transform the activities in the activity streams format so we can pass it on to the adapter
    var tenant = TenantsAPI.getTenant(user.tenant.alias);
    var ctx = new Context(tenant, user);
    ActivityTransformer.transformActivities(ctx, aggregatedActivities, 'activitystreams', function(err) {
        if (err) {
            log().error({'err': err}, 'Could not transform activities for mail');
            return callback(err);
        }

        // Transform the activities in a simple model that the templates can use to generate the email
        var ActivityAdapter = UIAPI.getActivityAdapter();
        var adaptedActivities = ActivityAdapter.adapt(user, aggregatedActivities);

        // Generate a unique fingerprint for this mail so we don't accidentally send it out multiple times
        // We cannot use the activityId as each activity gets a new ID when routed and/or aggregated
        // See https://github.com/oaeproject/Hilary/pull/759 for more information
        var emailHash = util.format('%s#', user.id);
        _.each(aggregatedActivities, function(activity) {
            emailHash += util.format('%s:%s#', activity['oae:activityType'], activity.published);
        });

        // Construct the data that needs to go into the email template
        var data = {
            'activities': adaptedActivities,
            'tenant': tenant,
            'user': user,
            'baseUrl': TenantsUtil.getBaseUrl(tenant),
            'skinVariables': UIAPI.getTenantSkinVariables(tenant.alias)
        };
        EmailAPI.sendEmail('oae-activity', 'mail', user, data, {'hash': emailHash}, callback);
    });
};


/**
 * Aggregate those activities that can be aggregated in the set of passed in activities. Aggregation happens
 * regardless of the time that sits between two activities.
 *
 * @param  {String}         userId          The ID of the user for which these activities are intended
 * @param  {Activity[]}     activities      The set of activities to aggregate
 * @return {Activity[]}                     The aggregated activities
 * @private
 */
var _aggregate = function(userId, activities) {
    // Unroll the `activities` so it does not contain any aggregates
    var unrolledActivities = _unrollActivities(activities);

    // Convert the set of unrolled activities into a set of "routed activities"
    // so we can generate the aggregates for it
    var routedActivities = _.map(unrolledActivities, function(activity) {
        return {
            'route': userId,
            'activity': activity
        };
    });

    // Re-aggregate everything
    var aggregates = ActivityAggregator.createAggregates(routedActivities);

    // Convert the aggregates into activities
    var aggregatedActivities = [];
    _.each(aggregates, function(aggregate, aggregateKey) {
        var actor = ActivityAggregator.createActivityEntity(_.values(aggregate.actors));
        var object = ActivityAggregator.createActivityEntity(_.values(aggregate.objects));
        var target = ActivityAggregator.createActivityEntity(_.values(aggregate.targets));
        aggregatedActivities.push(new ActivityModel.Activity(aggregate['oae:activityType'], aggregate.activityIds[0], aggregate.verb, aggregate.published, actor, object, target));
    });

    // Return an array of activities sorted in time
    return aggregatedActivities.sort(function(a, b) {
        return a.published - b.published;
    });
};

/**
 * Unroll a set of activities by expanding aggregated activities into separate distinct
 * aggregates. Note that the unrolled activities will probably *NOT* match the activity
 * from before aggregation.
 *
 * @param  {Activity[]}     aggregatedActivities    A set of activities that contain possible aggregates
 * @return {Activity[]}                             The expanded activities that do not contain aggregates
 * @api private
 */
var _unrollActivities = function(aggregatedActivities) {
    var activities = [];
    _.each(aggregatedActivities, function(activity) {
        var actorEntities = _getEntities(activity.actor);
        var objectEntities = _getEntities(activity.object);
        var targetEntities = _getEntities(activity.target);

        // If the activity contains at most 1 entity for the actor, object and target entities, it
        // hasn't aggregated with other activities, which means we don't have to unroll anything
        if (actorEntities.length <= 1 && objectEntities.length <= 1 && targetEntities.length <= 1) {
            activities.push(activity);
            return;
        }

        // This activity has aggregated with another activity so one (or more) entities are collections
        // that need to be unrolled
        var actor = null;
        var object = null;
        var target = null;
        while (actorEntities.length > 0 || objectEntities.length > 0 || targetEntities.length > 0) {
            actor = actorEntities.pop() || actor;
            object = objectEntities.pop() || object;
            target = targetEntities.pop() || target;

            var newActivity = new ActivityModel.Activity(activity['oae:activityType'], activity['oae:activityId'], activity.verb, activity.published, actor, object, target);
            activities.push(newActivity);
        }
    });
    return activities;
};

/**
 * Get the set of entities for a given `actor`, `object` or `target` entity. If the entity
 * is null an empty array will be returned. If there's only a single entity available, an
 * array with that single value in it will be returned.
 *
 * @param  {Object}             entity      The entity to return. Either an `ActivityEntity` or an `oae:collection` of `ActivityEntity` objects
 * @return {ActivityEntity[]}               An array of `ActivityEntity` objects
 * @api private
 */
var _getEntities = function(entity) {
    if (!entity) {
        return [];
    } else if (entity.objectType !== 'collection') {
        return [entity];
    } else {
        return entity['oae:collection'];
    }
};
