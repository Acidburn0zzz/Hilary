/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var util = require('util');

var AuthzUtil = require('oae-authz/lib/util');
var log = require('oae-logger').logger('oae-activity-push');
var Context = require('oae-context').Context;
var MQ = require('oae-util/lib/mq');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var Telemetry = require('oae-telemetry').telemetry('push');
var Tenant = require('oae-tenants/lib/model').Tenant;
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-authz/lib/validator').Validator;
var User = require('oae-principals/lib/model').User;

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityEmitter = require('oae-activity/lib/internal/emitter');
var ActivityRegistry = require('oae-activity/lib/internal/registry');
var ActivityTransformer = require('oae-activity/lib/internal/transformer');


//////////////////////
// MODULE VARIABLES //
//////////////////////

// A hash of sockets per stream
var socketsPerStream = {};

// The name of the queue we'll be using for this app server
var queueName = null;

var QueueConstants = {};

QueueConstants.exchange = {
    'NAME': 'oae-activity-pushexchange',
    'OPTIONS': {
        'type': 'direct',
        'durable': false,
        'autoDelete': false
    }
};

QueueConstants.queue = {
    'PREFIX': 'oae-activity-push-',
    'OPTIONS': {
        'durable': false,
        'autoDelete': true,
        'arguments': {
            // Additional information on highly available RabbitMQ queues can be found at http://www.rabbitmq.com/ha.html.
            // We use `all` as the policy: Queue is mirrored across all nodes in the cluster.
            // When a new node is added to the cluster, the queue will be mirrored to that node.
            'x-ha-policy': 'all'
        }
    }
};

QueueConstants.publish = {
    'OPTIONS': {
        // 1 indicates 'non-persistent'
        'deliveryMode': 1
    }
};

QueueConstants.subscribe = {
    'OPTIONS': {
        'ack': false,
        'prefetchCount': 15
    }
};

////////////////
// PUSH LOGIC //
////////////////

/**
 * Initializes the push logic. We will declare an exchange on which activities can be published,
 * create a queue specificly for this app server and start listening for new messages that are received on the queue.
 * When a client connects to this app server we will add a binding from the exchange too the queue.
 * This means that any activities that are relevant to the client will end up in our appserver queue and thus on this app server.
 *
 * @param  {Function} callback      Standard callback function
 * @param  {Object}   callback.err  Standard error object (if any)
 */
var init = module.exports.init = function(callback) {
    // Declare the push exchange
    MQ.declareExchange(QueueConstants.exchange.NAME, QueueConstants.exchange.OPTIONS, function(err) {
        if (err) {
            return callback(err);
        }

        // Create our queue
        queueName = QueueConstants.queue.PREFIX + Math.floor(Math.random()*1000000);
        MQ.declareQueue(queueName, QueueConstants.queue.OPTIONS, function(err) {
            if (err) {
                return callback(err);
            }

            // Subscribe to our queue for new events
            MQ.subscribeQueue(queueName, QueueConstants.subscribe.OPTIONS, _handlePushActivity, callback);
        });
    });
};

/**
 * Registers a websocket connection for push notifications
 *
 * @param  {Socket}     socket  A WebSocket connection
 */
var registerConnection = module.exports.registerConnection = function(socket) {
    log().trace({'sid': socket.id}, 'Got a new WS connection');
    socket.streams = [];
    socket.ctx = null;
    var connectionStart = Date.now();

    Telemetry.incr('connection.count');

    socket.on('data', function(msg) {
        var message = null;
        try {
            // Deserialize the incoming message (Sock.JS only supports strings)
            message = JSON.parse(msg);
            if (_.isUndefined(message.id)) {
                log().error({'msg': msg}, 'Missing id on the message');
                _writeResponse(socket, 0, {'code': 400, 'msg': 'Missing id on the message'});
                return socket.close();
            }
        } catch (err) {
            log().error({'msg': msg}, 'Ignoring malformed message');
            _writeResponse(socket, 0, {'code': 400, 'msg': 'Malformed message'});

            // This must've been the first frame which indicates a bad authentication attempt
            // Close the socket
            if (!socket.ctx) {
                log().error({'err': err}, 'Invalid json and has no context');
                socket.close();
            }

            // Do not attempt to do anything else with this frame and return
            return;
        }

        // The first message coming from the UI has to be an authentication frame
        // If it's something else, we ignore it and immediately close the socket
        if (!socket.ctx && message.name !== 'authentication') {
            log().error('First frame is not authentication');
            _writeResponse(socket, message.id, {'code': 401, 'msg': 'The first frame should be an authentication frame'});
            return socket.close();
        }

        if (message.name === 'authentication') {
            _authenticate(socket, message);
        } else if (message.name === 'subscribe') {
            _subscribe(socket, message);
        }
    });

    /**
     * A client disconnected. We need to do some clean-up.
     *
     * 1/ Unbind our RabbitMQ queue from the exchange for all the streams that user was interested in (but nobody else).
     *
     * 2/ Clear all local references to this socket, so we're not leaking memory.
     */
    socket.on('close', function() {
        log().trace({'sid': socket.id, 'streams': socket.streams}, 'Closing socket');
        // Measure how long the clients stay connected
        Telemetry.appendDuration('connected.time', connectionStart);

        var todo = socket.streams.length;
        if (todo === 0) {
            log().trace({'sid': socket.id}, 'Not registered for any streams, not doing anything');
            return;
        }

        var start = Date.now();
        _.each(socket.streams, function(stream) {
            if (socketsPerStream[stream].length === 1) {
                // If nobody else is interested in this stream, we can remove it
                delete socketsPerStream[stream];

                // We can also stop listening to messages from this stream as nobody is interested in it anymore
                MQ.unbindQueueFromExchange(queueName, QueueConstants.exchange.NAME, stream, function() {
                    todo--;

                    if (todo === 0) {
                        Telemetry.appendDuration('unbind.all.time', start);
                    }
                });

                // Otherwise we need to iterate through the list of sockets for this stream and splice this one out
            } else {
                todo--;

                // Find the socket in the socketsPerStream[stream] array and remove it
                // Unfortunately we can't use an underscore utility as all of the filter/find
                // functions return a copy of the array or the socket we're searching for
                var index = 0;
                log().trace({'sid': socket.id, 'stream': stream, 'socketsInstream': socketsPerStream[stream].length}, 'Searching through sockets');
                while (index < socketsPerStream[stream].length) {
                    if (socketsPerStream[stream][index].id === socket.id) {
                        // If we have found the socket we're looking for, we can abort early
                        break;
                    }

                    // Otherwise we need to look at the next element
                    index++;
                }

                // Make sure we've actually found it and don't accidentally remove the last added socket
                if (socketsPerStream[stream][index].id === socket.id) {
                    socketsPerStream[stream].splice(index, 1);
                }

                if (todo === 0) {
                    Telemetry.appendDuration('unbind.all.time', start);
                }
            }
        });
    });
};

/**
 * Handles authentication of the client. Authentication happens by passing a signature
 * along that can be retrieved from the /api/me endpoint. This signature is specific to the
 * user.
 *
 * Once the user is connected, a `Context` object will be made available on the socket
 * which can be used to pass into any of the standard API methods.
 *
 * @param  {Socket}     socket      The socket on which the client connected
 * @param  {Object}     message     The authentication frame
 * @api private
 */
var _authenticate = function(socket, message) {

    var data = message.payload;
    if (!data) {
        _writeResponse(socket, message.id, {'code': 400, 'msg': 'Missing data payload containing the userId and signature'});
        return socket.close();
    }

    // Parameter validation
    var validator = new Validator();
    validator.check(data.tenantAlias, {'code': 400, 'msg': 'A tenant needs to be provided'}).notEmpty();
    validator.check(data.userId, {'code': 400, 'msg': 'A userId needs to be provided'}).isUserId();
    validator.check(null, {'code': 400, 'msg': 'A signature object needs to be provided'}).isObject(data.signature);
    if (data.signature) {
        validator.check(data.signature.signature, {'code': 400, 'msg': 'A signature needs to be provided'}).notEmpty();
        validator.check(data.signature.expires, {'code': 400, 'msg': 'An expires value needs to be provided'}).isInt();
        validator.check(data.signature.expires, {'code': 400, 'msg': 'An expires value cannot be in the past'}).min(Date.now());
        validator.check(data.signature.signature, {'code': 401, 'msg': 'An invalid signature has been provided'}).verifyExpiringSignature(data.tenantAlias, data.signature.expires, data.userId);
    }
    if (validator.hasErrors()) {
        _writeResponse(socket, message.id, validator.getFirstError());
        log().error({'err': validator.getFirstError()}, 'Invalid auth frame');
        socket.close();
        return;
    }

    // Get the full user object
    PrincipalsDAO.getPrincipal(data.userId, function (err, user) {
        if (err) {
            _writeResponse(socket, message.id, err);
            log().error({'err': err}, 'Error on getPrincipal');
            return socket.close();
        }

        // Store a context with the tenant we're running on and the full user object
        var currentTenant = TenantsAPI.getTenant(data.tenantAlias);
        socket.ctx = new Context(currentTenant, user);
        _writeResponse(socket, message.id);
    });
};

/**
 * A client wants to subscribe on a stream. We do some basic validation, pass the message
 * too the authorization handler for that stream and do the appropriate MQ binding
 *
 * @param  {Socket}     socket      The socket on which the client connected
 * @param  {Object}     message     The message containing the subscription request
 * @api private
 */
var _subscribe = function (socket, message) {
    var data = message.payload;
    if (!data || !data.stream || !data.stream.resourceId || !data.stream.activityStreamId) {
        return _writeResponse(socket, message.id, {'code': 400, 'msg': 'Missing stream properties'});
    }


    // Check if the client is authorized for this stream (and if the stream even exists)
    var authzHandler = _getAuthorizationHandler(data.stream.activityStreamId);
    if (!authzHandler) {
        return _writeResponse(socket, message.id, {'code': 400, 'msg': 'Unknown stream'});
    }

    // Perform authorization
    authzHandler(socket.ctx, data.stream.resourceId, data.token, function(err) {
        if (err) {
            return _writeResponse(socket, message.id, err);
        }

        var streamName = util.format('%s#%s', data.stream.resourceId, data.stream.activityStreamId);
        log().trace({'sid': socket.id, 'streamName': streamName}, 'Registering socket for stream');

        // Bind our app queue to the exchange (if it wasn't already)
        _bindQueue(streamName, function(err) {
            if (err) {
                log().error({'sid': socket.id, 'err': err, 'stream': streamName}, 'Could not bind our queue to the exchange');
                return _writeResponse(socket, 'register-for-stream', err);
            }

            // Remember this socket on the app server so we can push to it asynchronously
            socketsPerStream[streamName] = socketsPerStream[streamName] || [];
            socketsPerStream[streamName].push(socket);

            // Remember this stream on the socket
            socket.streams.push(streamName);

            // Acknowledge a succesfull subscription
            log().trace({'sid': socket.id, 'streamName': streamName}, 'Registered a client for a stream');
            _writeResponse(socket, message.id);
        });
    });
};

/**
 * Instructs RabbitMQ to deliver events for `streamName` to our app-queue.
 * If we're already listening on `streamName` this function will callback immediately.
 *
 * @param  {String}     streamName      The name of the stream we're interested in
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object (if any).
 * @api private
 */
var _bindQueue = function(streamName, callback) {
    // If this is the first time we see this stream we'll need to bind this app server to receive
    // events from RabbitMQ
    if (!socketsPerStream[streamName]) {
        MQ.bindQueueToExchange(queueName, QueueConstants.exchange.NAME, streamName, callback);

    // If we've seen this stream before, we're already listening for events for that stream
    // so there is no need to bind again
    } else {
        return callback();
    }
};

/**
 * Gets an authorization handler for a stream
 *
 * @param  {String}     activityStreamId    The id of the stream for which to retrieve the authorization handler. ex: `activity`
 * @return {Function}                       The authorization function or null if the activity stream has no authorization handler
 * @api private
 */
var _getAuthorizationHandler = function(activityStreamId) {
    var streamOptions = ActivityRegistry.getRegisteredActivityStreamType(activityStreamId);
    if (!streamOptions || !streamOptions.authorizationHandler) {
        return null;
    } else {
        return streamOptions.authorizationHandler;
    }
};

/**
 * Writes a message over the socket.
 * Only use this in response to an earlier request.
 *
 * @param  {Socket}     socket          The socket to write to
 * @param  {Number}     id              The id of the message that was sent by the client. This will be used by the client to identify what request this response is for
 * @param  {Object}     [error]         An optional error object
 * @param  {Number}     [error.code]    An HTTP error code
 * @param  {String}     error.msg       A message explaining the error
 * @api private
 */
var _writeResponse = function(socket, id, error) {
    var msg = {};
    msg.id = id;
    if (error) {
        msg.error = error;
    }
    socket.write(JSON.stringify(msg));
};

//////////////////////////////
// SEND/RECEIVE TO RABBITMQ //
//////////////////////////////

/**
 * Push out an activity to the RabbitMQ exchange.
 * From there it can be routed to the appropriate app server based on the activityStreamId.
 *
 * @param  {String}     activityStreamId            The activity stream on which the activity was routed. ex: `u:cam:abc123#notification`
 * @param  {Object}     routedActivity              The routed activity structure
 * @param  {String}     routedActivity.resourceId   The ID of the resource to whom/what this activity was routed. ex: `u:cam:abc123`
 * @param  {String}     routedActivity.streamType   The name of the stream to which the activity was routed. ex: `notification`
 * @param  {Activity}   routedActivity.activity     The actual activity object
 * @api private
 */
var _push = function(activityStreamId, routedActivity) {
    MQ.submit(QueueConstants.exchange.NAME, activityStreamId, routedActivity, QueueConstants.publish.OPTIONS);
};

/**
 * A message arrived on our RabbitMQ queue which we need to distribute
 * to the connected clients who are interested in this stream.
 *
 * @param  {Object}        data        The stream and activity
 * @param  {Function}      callback    Standard callback method
 * @api private
 */
var _handlePushActivity = function(data, callback) {
    var activityStreamId = data.resourceId + '#' + data.streamType;

    var todo = 0;
    // Iterate over the sockets that are interested in this stream, transform the activity and send it down the socket
    _.each(socketsPerStream[activityStreamId], function(socket) {

        todo++;
        try {
            // Because we're sending this activity to possible multiple sockets/users we'll need to clone and transform it for each socket
            var activities = [clone(data.activity)];
            ActivityTransformer.transformActivities(socket.ctx, activities, function(err) {
                if (err) {
                    return log().error({'err': err}, 'Could not transform event');
                }

                var msg = JSON.stringify({
                    'resourceId': data.resourceId,
                    'streamType': data.streamType,
                    'activity': activities[0]
                });
                socket.write(msg);

                todo--;
                if (todo === 0) {
                    callback();
                }
            });
        } catch (err) {
            log().error({'err': err, 'data': data}, 'Failed to transform activity');
        }
    });
};

/////////////////////
// EVENT LISTENERS //
/////////////////////


/*!
 * Send routed activities to the push exchange
 */
ActivityEmitter.on(ActivityConstants.events.ROUTED_ACTIVITIES, function(activitySeed, routedActivities) {
    _.each(routedActivities, function(routedActivity, activityStreamId) {
        _push(activityStreamId, routedActivity);
    });
});
