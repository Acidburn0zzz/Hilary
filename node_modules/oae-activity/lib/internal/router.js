/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var crypto = require('crypto');
var log = require('oae-logger').logger('oae-activity-router');
var Telemetry = require('oae-telemetry').telemetry('activity');

var ActivityConfig = require('./config');
var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityDAO = require('./dao');

var activityRouters = {};
var activityProducers = {};

/**
 * Register an activity router.
 *
 * @see ActivityAPI#registerActivityRouter
 */
var registerActivityRouter = module.exports.registerActivityRouter = function(resourceType, router) {
    if (activityRouters[resourceType]) {
        throw new Error('Attempted to register duplicate activity router');
    }
    activityRouters[resourceType] = router;
};

/**
 * Register an activity entity producer.
 *
 * @see ActivityAPI#registerActivityEntityProducer
 */
var registerActivityEntityProducer = module.exports.registerActivityEntityProducer = function(resourceType, producer) {
    if (activityProducers[resourceType]) {
        throw new Error('Attempted to register duplicate activity producer');
    }
    activityProducers[resourceType] = producer;
};

/**
 * Produce, route and queue an activity from an activity seed.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed that was used to post the activity
 * @param   {Function}      [callback]          Invoked when the process completes
 * @param   {Object}        [callback.err]      An error that occurred, if any
 */
var routeActivity = module.exports.routeActivity = function(activitySeed, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Error handling activity.');
        }
    };

    log().trace({'activitySeed': activitySeed}, 'Routing activity seed.');

    // Will aggregate all the activityStreamId (i.e., route) -> activity pairings that will be delivered
    var routedActivities = {};
    var activityId = ActivityDAO.createActivityId(activitySeed.published);
    var routingStart = Date.now();

    // Produce all of the activity entities
    _produceAllEntities(activitySeed, function(err, actor, object, target) {
        if (err) {
            return callback(err);
        }

        // Produce the routes for the actor, object and target entities
        _produceAllRoutes(activitySeed, actor, object, target, function(err, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation) {
            if (err) {
                return callback(err);
            }

            // 1. Create all routes and apply the "ROUTES" propagation entities, also apply minimum data for entities that may not be propagated
            for (var i = 0; i < actorRoutes.length; i++) {
                var actorRoute = actorRoutes[i];
                routedActivities[actorRoute] = routedActivities[actorRoute] || {};
                if (actorPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[actorRoute].actor = actor;
                }
            }

            for (i = 0; i < objectRoutes.length; i++) {
                var objectRoute = objectRoutes[i];
                routedActivities[objectRoute] = routedActivities[objectRoute] || {};
                if (objectPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[objectRoute].object = object;
                }
            }

            for (i = 0; i < targetRoutes.length; i++) {
                var targetRoute = targetRoutes[i];
                routedActivities[targetRoute] = routedActivities[targetRoute] || {};
                if (targetPropagation.type === ActivityConstants.entityPropagation.ROUTES) {
                    routedActivities[targetRoute].target = target;
                }
            }

            // 2. Fill activity data, including the "ALL" propagation entities, as well as minimum data for entities that are not routed
            _.values(routedActivities).forEach(function(activity) {

                // Also use this loop to put all the activity-level properties onto each activity
                activity[ActivityConstants.properties.OAE_ACTIVITY_TYPE] = activitySeed.activityType;
                activity[ActivityConstants.properties.OAE_ACTIVITY_ID] = activityId;
                activity.verb = activitySeed.verb;
                activity.published = activitySeed.published;

                // Backfill the appropriate actor data (there should always be an actor associated to the activity)
                if (activitySeed.actorResource && actorPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.actor = actor;
                } else if (activitySeed.actorResource) {
                    activity.actor = {};
                    activity.actor.objectType = activitySeed.actorResource.resourceType;
                    activity.actor[ActivityConstants.properties.OAE_ID] = activitySeed.actorResource.resourceId;
                }

                // Backfill the appropriate object data if there was an object associated to the activity
                if (activitySeed.objectResource && objectPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.object = object;
                } else if (activitySeed.objectResource) {
                    activity.object = {};
                    activity.object.objectType = activitySeed.objectResource.resourceType;
                    activity.object[ActivityConstants.properties.OAE_ID] = activitySeed.objectResource.resourceId;
                }

                // Backfill the appropriate target data if there was a target associated to the activity
                if (activitySeed.targetResource && targetPropagation.type === ActivityConstants.entityPropagation.ALL) {
                    activity.target = target;
                } else if (activitySeed.targetResource) {
                    activity.target = {};
                    activity.target.objectType = activitySeed.targetResource.resourceType;
                    activity.target[ActivityConstants.properties.OAE_ID] = activitySeed.targetResource.resourceId;
                }
            });

            // 3. Apply the "SPECIFY" propagation entities where possible
            if (activitySeed.actorResource && actorPropagation.type === ActivityConstants.entityPropagation.SPECIFY && actorPropagation.specify) {
                actorPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].actor = actor;
                    }
                });
            }

            if (activitySeed.objectResource && objectPropagation.type === ActivityConstants.entityPropagation.SPECIFY && objectPropagation.specify) {
                objectPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].object = object;
                    }
                });
            }

            if (activitySeed.targetResource && targetPropagation.type === ActivityConstants.entityPropagation.SPECIFY && targetPropagation.specify) {
                targetPropagation.specify.forEach(function(route) {
                    if (routedActivities[route]) {
                        routedActivities[route].target = target;
                    }
                });
            }

            log().trace({
                'activitySeed': activitySeed,
                'routedActivities': routedActivities
            }, 'Queueing activities to be routed.');

            // Queue the activity entities to be collected and aggregated
            _queueActivities(activitySeed, routedActivities, function(err, buckets) {
                if (err) {
                    return callback(err);
                }

                Telemetry.appendDuration('activity.routing.time', routingStart);
                return callback();
            });
        });
    });
};


/**
 * Produce activity entities based on the actor, object and target resources of the given activity seed.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed from which to extract the actor, object and target resource information
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {ActivityEntity}    callback.actor              The actor activity entity
 * @param   {String}            callback.actorPropagation   The actor entity propagation rule
 * @param   {ActivityEntity}    callback.object             The object activity entity
 * @param   {String}            callback.objectPropagation  The object entity propagation rule
 * @param   {ActivityEntity}    callback.target             The actor activity entity
 * @param   {String}            callback.targetPropagation  The actor entity propagation rule
 * @api private
 */
var _produceAllEntities = function(activitySeed, callback) {
    _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, activitySeed.actorResource, function(err, actor) {
        if (err) {
            return callback(err);
        }

        _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, activitySeed.objectResource, function(err, object) {
            if (err) {
                return callback(err);
            }

            _produceEntity(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, activitySeed.targetResource, function(err, target) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actor, object, target);
            });
        });
    });
};

/**
 * Produce an activity entity with the given seed resource information.
 *
 * @param   {String}                activityType            The type of activity for which the entity is being produced
 * @param   {String}                entityType              The type of entity for which the entity is being produced (i.e., actor, object or target)
 * @param   {ActivitySeedResource}  resource                The activity resource that was used to seed the activity
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {ActivityEntity}        callback.activityEntity The activity entity that was produced
 * @param   {String}                callback.propagation    A rule specifying how the activity entity should be propagated across the routes. The possible values are enumerated by `ActivityConstants.entityPropagation`
 * @api private
 */
var _produceEntity = function(activityType, entityType, resource, callback) {
    if (!resource) {
        return callback();
    }

    var producer = activityProducers[resource.resourceType];
    if (!producer) {
        log().error({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource
        }, 'No activity producer found for activity entity.');
        return callback({'code': 500, 'msg': 'No activity producer found for resource type "' + resource.resourceType + '"'});
    }

    producer(activityType, entityType, resource, function(err, entity, propagation) {
        if (err) {
            return callback(err);
        }

        // Ensure a valid resource id and resource type
        entity = entity || {};
        entity.objectType = resource.resourceType;
        entity[ActivityConstants.properties.OAE_ID] = resource.resourceId;

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'resource': resource,
            'entity': entity
        }, 'Produced activity entity.');

        return callback(null, entity);
    });
};

/**
 * Produce the routes for the given actor, object and target activity entities.
 *
 * @param   {ActivitySeed}      activitySeed                The activity seed that was used to post the activity
 * @param   {ActivityEntity}    actor                       The actor entity that was produced for the activity
 * @param   {ActivityEntity}    object                      The object entity that was produced for the activity
 * @param   {ActivityEntity}    target                      The target entity that was produced for the activity
 * @param   {Function}          callback                    Invoked when the process completes
 * @param   {Object}            callback.err                An error that occurred, if any
 * @param   {String[]}          callback.actorRoutes        The routes to which to route the activity for the actor
 * @param   {Object}            callback.actorPropagation   How to propagate the actor entity among activity routes
 * @param   {String[]}          callback.objectRoutes       The routes to which to route the activity for the object
 * @param   {Object}            callback.objectPropagation  How to propagate the object entity among activity routes
 * @param   {String[]}          callback.targetRoutes       The routes to which to route the activity for the target
 * @param   {Object}            callback.targetPropagation  How to propagate the target entity among activity routes
 * @api private
 */
var _produceAllRoutes = function(activitySeed, actor, object, target, callback) {
    log().trace({'activitySeed': activitySeed}, 'Producing routes for activity entities.');

    _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.ACTOR, actor, function(err, actorRoutes, actorPropagation) {
        if (err) {
            return callback(err);
        }

        _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.OBJECT, object, function(err, objectRoutes, objectPropagation) {
            if (err) {
                return callback(err);
            }

            _produceRoutes(activitySeed.activityType, ActivityConstants.entityTypes.TARGET, target, function(err, targetRoutes, targetPropagation) {
                if (err) {
                    return callback(err);
                }

                return callback(null, actorRoutes, actorPropagation, objectRoutes, objectPropagation, targetRoutes, targetPropagation);
            });
        });
    });
};

/**
 * Produce the routes for the activity entity.
 *
 * @param   {String}                activityType            The type of activity being routed
 * @param   {String}                entityType              The type of entity for which activities are being routed (e.g., actor, object, target)
 * @param   {ActivityEntity}        entity                  The entity for which to produce the routes
 * @param   {Function}              callback                Invoked when the process completes
 * @param   {Object}                callback.err            An error that occurred, if any
 * @param   {String[]}              callback.routes         The routes to which to route the activity
 * @param   {Object}                callback.propagation    How to propagate the entity among the activity routes
 * @api private
 */
var _produceRoutes = function(activityType, entityType, entity, callback) {
    if (!entity) {
        return callback(null, []);
    }

    var router = activityRouters[entity.objectType];
    if (!router) {
        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity
        }, 'No router found for object type.');
        return callback();
    }

    router(activityType, entityType, entity, function(err, routes, propagation) {
        if (err) {
            return callback(err);
        }

        routes = routes || [];

        log().trace({
            'activityType': activityType,
            'entityType': entityType,
            'entity': entity,
            'routes': routes,
            'propagation': propagation
        }, 'Generated routes for activity entity.');
        
        propagation = propagation || {'type': ActivityConstants.entityPropagation.ROUTES};

        return callback(null, routes, propagation);
    });
};

/**
 * Queue the given set of routed activities for collection.
 *
 * @param   {ActivitySeed}  activitySeed        The activity seed from which the activities were generated.
 * @param   {Object}        routedActivities    A hash whose value is the activity to deliver, where the key is the route to which the activity should be delivered.
 * @param   {Function}      callback            Invoked when the routed activities have been queued
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Number[]}      callback.buckets    The collection buckets that received activities as a result of this invocation
 * @api private
 */
var _queueActivities = function(activitySeed, routedActivities, callback) {
    var allRoutes = _.keys(routedActivities);
    var activityBuckets = [];

    allRoutes.forEach(function(route) {
        // Assign all activities to their processing buckets to support safe concurrency
        var bucketNumber = _getBucketNumber(route, activitySeed);
        activityBuckets[bucketNumber] = activityBuckets[bucketNumber] || [];
        activityBuckets[bucketNumber].push({
            'route': route,
            'activity': routedActivities[route]
        });
    });

    // Queue the aggregates into their associated buckets to indicate they need to be collected and delivered
    ActivityDAO.saveQueuedActivities(activityBuckets, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.keys(activityBuckets));
    });
};


/**
 * Get the bucket number in which a routed activity should be queued.
 *
 * @param   {String}        route           The string of the route.
 * @param   {ActivitySeed}  activitySeed    The activity seed from which the activity seed is being generated.
 * @return  {Number}                        The bucket number in which to queue the activity for processing.
 * @api private
 */
var _getBucketNumber = function(route, activitySeed) {
    var sum = crypto.createHash('md5');
    // Concurrency considerations in activity aggregation / replacement require us to store, at the least, all aggregates of a
    // particular route in one bucket. The reason we include the activity type is because it is still concurrency-safe, and
    // also avoids "hot buckets" when you take into consideration something like a "public" or "loggedin" activity stream.
    // Having "hot buckets" would essentially translate into a hot Cassandra row, since each bucket is a row, which is bad.
    sum.update(route);
    sum.update(activitySeed.activityType);
    return parseInt(sum.digest('hex'), 16) % ActivityConfig.getConfig().numberOfProcessingBuckets;
};

