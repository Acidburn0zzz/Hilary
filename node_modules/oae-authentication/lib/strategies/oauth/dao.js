/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var Cassandra = require('oae-util/lib/cassandra');


///////////////////
// Access tokens //
///////////////////

module.exports.AccessTokens = {};

/**
 * Creates an access token
 *
 * @param  {String}         token                   The randomly generated string, this will be the primary identifier for the access token
 * @param  {String}         userId                  The ID of the user for who this access token will work
 * @param  {String}         clientId                The ID of the client to which this access token is associated
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {AccessToken}    callback.accessToken    The created access token
 */
var createAccessToken = module.exports.AccessTokens.createAccessToken = function(token, userId, clientId, callback) {
    var params = {
        'userId': userId,
        'clientId': clientId
    };

    var byUserParams = {};
    byUserParams[clientId] = token;
    var queries = [
        Cassandra.constructUpsertCQL('OAuth_accessToken', 'token', token, params),
        Cassandra.constructUpsertCQL('OAuth_accessTokenByUser', 'userId', userId, byUserParams),
    ];
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, new AccessToken(token, userId, clientId));
    });
};

/**
 * Get a full access token object
 *
 * @param  {String}         token                   The randomly generated string
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {AccessToken}    callback.accessToken    The access token object which contains the user for which the token can be used
 */
var getAccessToken = module.exports.AccessTokens.getAccessToken = function(token, callback) {
    // TODO: As this gets called on every OAuth authenticated call, it might not be a bad idea to cache this in Redis
    Cassandra.runQuery('SELECT * FROM OAuth_accessToken USING CONSISTENCY QUORUM WHERE token = ?', [token], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (!rows || rows[0].count <= 1) {
            return callback(null, null);
        }

        var hash = Cassandra.rowToHash(rows[0]);
        var accessToken = new AccessToken(hash.token, hash.userId, hash.clientId);
        return callback(null, accessToken);
    });
};

/**
 * Given a user and a client, gets the access token for that combination
 *
 * @param  {String}         userId                  The user who allowed access to his data to the client
 * @param  {String}         clientId                The client for which the access token was granted
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {AccessToken}    callback.accessToken    The access token object which contains the user for which the token can be used
 */
var getAccessTokenForUserAndClient = module.exports.AccessTokens.getAccessTokenForUserAndClient = function(userId, clientId, callback) {
    // TODO: As this gets called on every OAuth authenticated call, it might not be a bad idea to cache this in Redis
    Cassandra.runQuery('SELECT ? FROM OAuth_accessTokenByUser USING CONSISTENCY QUORUM WHERE userId = ?', [clientId, userId], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (!rows || rows[0].count < 1) {
            return callback(null, null);
        }

        var hash = Cassandra.rowToHash(rows[0]);
        var accessToken = new AccessToken(hash[clientId], userId, clientId);
        return callback(null, accessToken);
    });
};

/**
 * The access token model
 *
 * @param  {String}     token       The randomly generated string
 * @param  {String}     userId      The ID of the user for which this token is valid
 * @param  {String}     clientId    The ID of the client for which this token was granted
 */
var AccessToken = function(token, userId, clientId) {
    var that = {};
    that.token = token;
    that.userId = userId;
    that.clientId = clientId;
    return that;
};


/////////////
// Clients //
/////////////

module.exports.Clients = {};

/**
 * Creates a client.
 * The id and secret for the client will be generated and returned to you as part of
 * the client object in the callback.
 *
 * @param  {String}     id                  The id for this client
 * @param  {String}     displayName         A descriptive name for this client
 * @param  {String}     secret              The secret token for this client
 * @param  {String}     userId              The ID of the user who owns this client
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object, if any
 * @param  {Client}     callback.client     The created client
 */
var createClient = module.exports.Clients.createClient = function(id, displayName, secret, userId, callback) {
    var params = {
        'displayName': displayName,
        'secret': secret,
        'userId': userId
    };

    var byUserParams = {};
    byUserParams[Date.now()] = id;

    var queries = [
        Cassandra.constructUpsertCQL('OAuth_client', 'id', id, params),
        Cassandra.constructUpsertCQL('OAuth_clientsByUser', 'userId', userId, byUserParams),
    ];

    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, new Client(id, displayName, secret, userId));
    });
};

/**
 * Delete a client
 *
 * @param  {String}     id              The ID of the client to remove
 * @param  {String}     userId          The ID of the user who owns this client
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Standard error object, if any
 */
var deleteClient = module.exports.Clients.deleteClient = function(id, userId, callback) {
    var queries = [
        {'query': 'DELETE FROM OAuth_client WHERE id = ?', 'parameters': [id]},
        {'query': 'DELETE ? FROM OAuth_clientsByUser WHERE userId = ?', 'parameters': [id, userId]},
    ];
    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};


/**
 * Retrieve a client by its id
 * 
 * @param  {String}     id                The ID of the client to retrieve
 * @param  {Function}   callback          Standard callback function
 * @param  {Object}     callback.err      Standard error object, if any
 * @param  {Client}     callback.client   The retrieved client or null if it could not be found
 */
var getClientById = module.exports.Clients.getClientById = function(id, callback) {
    // TODO: As this gets called on every OAuth authenticated call, it might not be a bad idea to cache this in Redis
    _getClientsByIds([id], function(err, clients) {
        if (err) {
            return callback(err);
        } else if (clients.length === 0) {
            return callback();
        }

        return callback(null, clients[0]);
    });
};

/**
 * Get the list of clients for a user
 *
 * @param  {String}     userId              The ID of the user for whom the retrieve the client
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object, if any
 * @param  {Client[]}   callback.clients    The set of clients that are registered for this user
 */
var getClientsByUser = module.exports.Clients.getClientsByUser = function(userId, callback) {
    Cassandra.runQuery('SELECT * FROM OAuth_clientsByUser USING CONSISTENCY QUORUM WHERE userId = ?', [userId], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var hash = Cassandra.rowToHash(rows[0]);
        var clientIds = [];
        _.each(hash, function(val, key) {
            if (key !== 'userId') {
                clientIds.push(val);
            }
        });
        _getClientsByIds(clientIds, callback);
    });
};

/**
 * Get a set of clients by their IDs
 *
 * @param  {String}     clientIds           The IDs of the client that need to be retrieved
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object, if any
 * @param  {Client[]}   callback.clients    The set of clients
 * @api private
 */
var _getClientsByIds = function(clientIds, callback) {
    if (clientIds.length === 0) {
        return callback(null, []);
    }
    Cassandra.runQuery('SELECT * FROM OAuth_client USING CONSISTENCY QUORUM WHERE id IN (?)', [clientIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var clients = [];
        _.each(rows, function(row) {
            if (row.count > 1) {
                var hash = Cassandra.rowToHash(row);
                clients.push(new Client(hash.id, hash.displayName, hash.secret, hash.userId));
            }
        });
        return callback(null, clients);
    });
};

/**
 * The client object
 *
 * @param  {String}     id              The ID of the client
 * @param  {String}     displayName     The display name of the client
 * @param  {String}     secret          A randomly generated secret for this client
 * @param  {String}     userId          The ID of the client who should own this client
 */
var Client = function(id, displayName, secret, userId) {
    var that = {};
    that.id = id;
    that.displayName = displayName;
    that.secret = secret;
    that.userId = userId;
    return that;
};
