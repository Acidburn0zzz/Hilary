/*!
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Chance = require('chance');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var OaeUtil = require('oae-util/lib/util');

var Invitation = require('oae-authz/lib/invitations/model').Invitation;
var Validator = require('oae-authz/lib/validator').Validator;

var chance = new Chance();

var TOKEN_POOL = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';

var getOrCreateTokensByEmails = module.exports.getInvitationToken = function(emails, callback) {
    // Determine which emails already have tokens
    Cassandra.runQuery('SELECT * FROM "AuthzInvitationsTokenByEmail" WHERE "email" IN (?)', [emails], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var emailTokens = _.chain(rows)
            .map(Cassandra.rowToHash)
            .indexBy('email')
            .mapObject(function(hash) {
                return hash.token;
            })
            .value();
        var queries = [];

        // For each email that did not have an invitation associated to it, persist one and add it
        // to the email tokens hash
        _.each(emails, function(email) {
            if (!emailTokens[email]) {
                var token = chance.string({'length': 12, 'pool': TOKEN_POOL});
                queries.push(
                    Cassandra.constructUpsertCQL('AuthzInvitationsTokenByEmail', 'email', email, {'token': token}),
                    Cassandra.constructUpsertCQL('AuthzInvitationsEmailByToken', 'token', token, {'email': email})
                );
                emailTokens[email] = token;
            }
        });

        // If all the emails had tokens, we can just return without doing any queries
        if (_.isEmpty(queries)) {
            return callback(null, emailTokens);
        }

        // Add the missing email tokens to the invitations token tables
        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, emailTokens);
        });
    });
};

var getEmailByToken = module.exports.getInvitationEmailByToken = function(token, callback) {
    Cassandra.runQuery('SELECT * FROM "AuthzInvitationsEmailByToken" WHERE "token" = ?', [token], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': util.format('There is no email associated to the email token "%s"', token)});
        }

        return callback(null, _.first(rows).get('email'));
    });
};

var getAllInvitationsByEmail = module.exports.getAllInvitationsByEmail = function(email, callback) {
    _getAllInvitationResourceIdsByEmail(email, function(err, invitationResourceIds) {
        if (err) {
            return callback(err);
        }

        return _getInvitations(invitationResourceIds, email, callback);
    });
};

var getAllInvitationsByResourceId = module.exports.getAllInvitationsByResourceId = function(resourceId, callback, _invitations, _nextToken) {
    if (_nextToken === null) {
        return callback(null, _invitations);
    }

    _nextToken = _nextToken || '';
    Cassandra.runQuery('SELECT * FROM "AuthzInvitations" WHERE "resourceId" = ? AND "email" > ? ORDER BY "email" ASC LIMIT 150', [resourceId, _nextToken], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            return getAllInvitationsByResourceId(resourceId, callback, _invitations, null);
        }

        var invitations = _.map(rows, Cassandra.rowToHash);
        return getAllInvitationsByResourceId(resourceId, callback, _.union(_invitations, invitations), _.last(invitations).email);
    });
};

var createInvitations = module.exports.createInvitations = function(resourceId, emailRoles, inviterUserId, callback) {
    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Specified resource must have a valid resource id'}).isResourceId();
    _.each(emailRoles, function(role, email) {
        validator.check(email, {'code': 400, 'msg': 'A valid email must be supplied to invite'}).isEmail();
        validator.check(role, {'code': 400, 'msg': 'A valid role must be supplied to give the invited user'}).isValidRole();
    });
    validator.check(inviterUserId, {'code': 400, 'msg': util.format('Specified inviter id "%s" must be a valid user id')}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getOrCreateTokensByEmails(_.keys(emailRoles), function(err, emailTokens) {
        if (err) {
            return callback(err);
        }

        var invitationHashes = _.map(emailRoles, function(role, email) {
            return {
                'resourceId': resourceId,
                'email': email,
                'inviterUserId': inviterUserId,
                'role': role
            };
        });
        var queries = _.chain(invitationHashes)
            .map(function(hash) {
                return [
                    {
                        'query': 'UPDATE "AuthzInvitations" SET "inviterUserId" = ?, "role" = ? WHERE "resourceId" = ? AND "email" = ?',
                        'parameters': [hash.inviterUserId, hash.role, hash.resourceId, hash.email]
                    },
                    {
                        'query': 'INSERT INTO "AuthzInvitationsResourceIdByEmail" ("resourceId", "email") VALUES (?, ?)',
                        'parameters': [hash.resourceId, hash.email]
                    }
                ];
            })
            .flatten()
            .value();

        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, emailTokens, invitationHashes);
        });
    });
};

var updateInvitationRoles = module.exports.updateInvitationRoles = function(resourceId, emailRoles, callback) {
    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Specified resource must have a valid resource id'}).isResourceId();
    _.each(emailRoles, function(role, email) {
        validator.check(email, {'code': 400, 'msg': util.format('Invalid email "%s" specified', email)}).isEmail();
        validator.check(role, {'code': 400, 'msg': util.format('Invalid role change "%s" specified', role)}).isValidRoleChange();
        if (role !== false) {
            validator.check(null, {'code': 400, 'msg': util.format('Invalid role "%s" specified', role)}).isString(role);
        }
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var queries = [];
    _.each(emailRoles, function(role, email) {
        if (_.isString(role)) {
            queries.push({
                'query': 'UPDATE "AuthzInvitations" SET "role" = ? WHERE "resourceId" = ? AND "email" = ?',
                'parameters': [role, resourceId, email]
            });
        } else if (role === false) {
            queries.push(
                {
                    'query': 'DELETE FROM "AuthzInvitations" WHERE "resourceId" = ? AND "email" = ?',
                    'parameters': [resourceId, email]
                },
                {
                    'query': 'DELETE FROM "AuthzInvitationsResourceIdByEmail" WHERE "email" = ?',
                    'parameters': [email]
                }
            );
        }
    });

    Cassandra.runBatchQuery(queries, callback);
};

var deleteInvitations = module.exports.deleteInvitations = function(email, callback) {
    var validator = new Validator();
    validator.check(resourceId, {'code': 400, 'msg': 'Specified resource must have a valid resource id'}).isResourceId();
    _.each(emailsByResourceId, function(emails, resourceId) {
        _.each(emails, function(email) {
            validator.check(email, {'code': 400, 'msg': util.format('Invalid email "%s" specified', email)}).isEmail();
        });
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the active token for the given email
    getOrCreateTokensByEmails([email], function(err, tokenByEmail) {
        if (err) {
            return callback(err);
        }

        var token = tokenByEmail[email];

        _getAllInvitationResourceIdsByEmail(email, function(err, resourceIds) {
            if (err) {
                return callback(err);
            }

            var queries = [
                // Delete the email token so a new one can be generated
                {
                    'query': 'DELETE FROM "AuthzInvitationsEmailByToken" WHERE "token" = ?',
                    'parameters': [token]
                },
                {
                    'query': 'DELETE FROM "AuthzInvitationsTokenByEmail" WHERE "email" = ?',
                    'parameters': [email]
                },

                // Delete the invitations index associated to this email
                {
                    'query': 'DELETE FROM "AuthzInvitationsResourceIdByEmail" WHERE "email" = ?',
                    'parameters': [email]
                }
            ];

            // Delete all the invitations entries for each resource that invited this email
            _.each(resourceIds, function(resourceId) {
                queries.push({
                    'query': 'DELETE FROM "AuthzInvitations" WHERE "resourceId" = ? AND "email" = ?',
                    'parameters': [resourceId, email]
                });
            });

            return Cassandra.runBatchQuery(queries, callback);
        });
    });
};

var _getAllInvitationResourceIdsByEmail = function(email, callback, _resourceIds, _nextToken) {
    var cql = 'SELECT "resourceId" FROM "AuthzInvitationsResourceIdByEmail" WHERE "email" = ?';
    var params = [email];
    if (_nextToken) {
        cql += ' AND "resourceId" > ?';
        params.push(_nextToken);
    }

    cql += ' ORDER BY "email" ASC LIMIT 100';
    Cassandra.runQuery(cql, params, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var resourceIds = _.chain(rows)
            .map(Cassandra.rowToHash)
            .pluck('resourceId')
            .value();
        _resourceIds = _.union(_resourceIds, resourceIds);
        if (_.isEmpty(resourceIds)) {
            return callback(null, _resourceIds);
        } else {
            _nextToken = _.last(resourceIds);
            return _getAllInvitationResourceIdsByEmail(email, callback, _resourceIds, _nextToken);
        }
    });
};

var _getInvitations = function(resourceIds, email, callback) {
    Cassandra.runQuery('SELECT * FROM "AuthzInvitations" WHERE "resourceId" IN (?) AND email = ?', [resourceIds, email], function(err, rows) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.map(rows, Cassandra.rowToHash));
    });
};
