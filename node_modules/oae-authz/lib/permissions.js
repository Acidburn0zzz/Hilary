
var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants');

var resolveEffectivePermissions = module.exports.resolveEffectivePermissions = function(ctx, resource, callback) {
    AuthzAPI.resolveEffectiveRole(ctx.user(), resource, [AuthzConstants.role.VIEWER, AuthzConstants.role.MANAGER], function(err, effectiveRole, canInteract) {
        if (err) {
            return callback(err);
        }

        var canView = _.isString(effectiveRole);
        var canManage = (effectiveRole === AuthzConstants.role.MANAGER);
        var canSetRoles = canManage;

        // Anyone who can interact can share, unless the resource is private. In that case, only managers can share
        var canShare = canInteract;
        if (resource.visibility === AuthzConstants.visibility.PRIVATE) {
            canShare = canManage;
        }

        return callback(null, {
            'canView': canView,
            'canInteract': canInteract,
            'canShare': canShare,
            'canManage': canManage,
            'canSetRoles': canManage
        });
    });
};

var canManage = module.exports.canManage = function(ctx, resource, callback) {
    var permissionErr = {
        'code': 401,
        'msg': 'The current user does not have access to manage this resource'
    };
    var user = ctx.user();
    if (!user) {
        // Anonymous can never manage
        return callback(permissionErr);
    }

    AuthzAPI.resolveImplicitRole(ctx, resource, [AuthzConstants.role.VIEWER, AuthzConstants.role.MANAGER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === AuthzConstants.role.MANAGER) {
            // We have an implicit manageR role (e.g., we are an administrator), succeed
            return callback();
        }

        // By this point, we can only manage if we have explicit manager role
        AuthzAPI.hasRole(user.id, resource.id, AuthzConstants.role.MANAGER, function(err, hasRole) {
            if (err) {
                return callback(err);
            } else if (!hasRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var canManageMessage = module.exports.canManageMessage = function(ctx, parentResource, message, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to delete this message'};
    if (!ctx.user()) {
        // Anonymous can never manage a message
        return callback(permissionErr);
    }

    resolveEffectivePermissions(ctx, parentResource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canInteract) {
            // If the user cannot interact, they cannot manage the message even if they were the
            // author
            return callback(permissionErr);
        } else if (ctx.user().id !== message.createdBy && !permissions.canManage) {
            // The user cannot delete the message if they weren't the author and if they can't
            // manage the parent resource
            return callback(permissionErr);
        }

        // The user can interact with the parent resource, and is either the author of the message
        // or can manage the parent resource
        return callback();
    });
};

var canView = module.exports.canView = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to this resource'};
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(user, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we
            // can atleast view
            return callback();
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(permissionErr);
        }

        // By this point, we only have access to view if we have a role on the item
        AuthzAPI.hasAnyRole(user.id, _getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var canShare = module.exports.canShare = function(ctx, resource, opts, callback) {
    opts = opts || {};
    opts.principals = opts.principals || [];
    opts.emails = opts.emails || [];

    resolveEffectivePermissions(ctx, resource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canShare) {
            return callback({'code': 401, 'msg': 'The current user does not have access to share this resource'});
        }

        var roleChangeOpts = {
            'principalRoles': _.map(principals, function(principal) {
                return {
                    'role': AuthzConstants.role.VIEWER,
                    'principal': principal
                };
            }),
            'emailRoles': _.map(emails, function(email) {
                return {
                    'role': AuthzConstants.role.VIEWER,
                    'email': email
                };
            })
        };

        _validateRoleChanges(ctx, resource, roleChangeOpts, function(err, memberRoles, newMembers) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(newMembers)) {
                // If there are no new members, then this is basically an empty share which should
                // be fine
                return callback(null, []);
            } else if (permissions.canManage) {
                // If the user can manage the resource, then we don't care about resource->target
                // visibility violations, as managers can extend those boundaries VIA share
                return callback(null, newMembers);
            }

            // Since we are not a manager, for each principal we are sharing with, we need to make
            // sure all users already had implicit access to the resource (e.g., a non-manager can't
            // share a loggedin resource with a public user from another tenant because that would
            // violate the visibility that managers applied to the resource)
            var invalidPrincipals = {};
            var done = _.after(newMembers.length, function() {
                if (!_.isEmpty(invalidPrincipals)) {
                    return callback({
                        'code': 401,
                        'msg': 'The current user does not have access to share this resource with the specified principals',
                        'invalidPrincipals': invalidPrincipals
                    });
                }

                return callback(null, newMembers);
            });

            _.each(newMembers, function(newMember) {
                AuthzAPI.resolveImplicitRole(newMember, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
                    if (err) {
                        invalidPrincipals[newMember.id] = err;
                    } else if (!canInteract) {
                        invalidPrincipals[newMember.id] = {'code': 401, 'msg': 'The current user does not have access to share this resource with the specified principals'};
                    }

                    return done();
                });
            });
        });
    });
};

var canRemoveRole = module.exports.canRemoveRole = function(ctx, principal, resource, callback) {
    canManage(ctx, principal, function(err) {
        if (err) {
            return callback(err);
        }

        var principalRoles = [{
            'role': false,
            'principal': principal
        }];

        _validateRoleChanges(ctx, resource, {'principalRoles': principalRoles}, function(err, memberRoles) {
            if (err) {
                return callback(err);
            } else if (!_.chain(memberRoles).values().contains(AuthzConstants.role.MANAGER)) {
                return callback({'code': 400, 'msg': 'The requested change will result in leaving the resource without a manager'});
            }

            return callback(null, memberRoles);
        });
    });
};

var canSetRoles = module.exports.canSetRoles = function(ctx, resource, opts, callback) {
    canManage(ctx, resource, function(err) {
        if (err) {
            return callback(err);
        }

        _validateRoleChanges(ctx, resource, opts, function(err, memberRoles, newMembers, updatedMembers, removedMembers) {
            if (err) {
                return callback(err);
            } else if (!_.chain(memberRoles).values().contains(AuthzConstants.role.MANAGER)) {
                return callback({'code': 400, 'msg': 'The requested change will result in leaving the resource without a manager'});
            }

            return callback(null, memberRoles, newMembers, updatedMembers, removedMembers);
        });
    });
};

var canInteract = module.exports.canInteract = function(ctx, resources, callback) {
    if (_.isEmpty(resources)) {
        return callback({'err': 400, 'msg': 'At least one principal must be specified to check for interaction'});
    } else if (!_.isArray(resources)) {
        return canInteract(ctx, [resources], callback);
    }

    var user = ctx.user();
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with these resources'};
    var resourceErrs = {};
    var done = _.after(resources.length, function() {
        if (!_.isEmpty(resourceErrs)) {
            return callback(_.extend(permissionError, {'invalidResources': resourceErrs}));
        }

        return callback();
    });

    _.each(resources, function(resource) {
        _canInteract(ctx, resource, function(err) {
            if (err) {
                resourceErrs[resource.id] = err;
            }

            return done();
        });
    });
};

var _validateRoleChanges = function(ctx, resource, opts, callback) {
    opts = opts || {};
    opts.principalRoles = opts.principalRoles || [];
    opts.emailRoles = opts.emailRoles || [];

    var principals = _.pluck(principalRoles, 'principal');
    var emailResources = _.chain(opts.emailRoles)
        .pluck('email')
        .map(_emailToResource)
        .value();

    // Build our hash indicating the membership changes to make
    var roleChanges = {};
    _.each(opts.principalRoles, function(principalRole) {
        roleChanges[principalRole.principal.id] = principalRole.role;
    });

    AuthzAPI.computeMemberRolesAfterChanges(resource.id, roleChanges, function(err, memberRoles, newMemberIds, updatedMemberIds, removedMemberIds) {
        if (err) {
            return callback(err);
        }

        // Map all member ids to their principal resources
        var principalsById = _.indexBy(principals, 'id');
        var newMembers = _.map(newMemberIds, _.propertyOf(principalsById));
        var updatedMembers = _.map(updatedMemberIds, _.propertyOf(principalsById));
        var removedMembers = _.map(removedMemberIds, _.propertyOf(principalsById));

        // For users who are being added to the resource, ensure interaction boundaries are not
        // being violated between the user in context and the target principal. Users who were
        // already associated can have their role changed or removed by a manager regardless of
        // tenant interaction boundaries
        var newTargets = _.union(newMembers, emailResources);

        OaeUtil.invokeIfNecessary(!_.isEmpty(newTargets), canInteract, ctx, newTargets, function(err) {
            if (err && err.code === 401) {
                // Contextualize the error a bit better than the generic `canInteract` error
                return callback({
                    'code': 401,
                    'msg': 'The current user does not have access to add the specified principals',
                    'invalidPrincipals': err.invalidResources
                });
            } else if (err) {
                return callback(err);
            }

            return callback(null, memberRoles, newMembers, updatedMembers, removedMembers);
        });
    });
};

var _canInteract = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with this resource'};
    var user = ctx.user();

    // First ensure the user in context can share with the resource
    AuthzAPI.resolveImplicitRole(ctx.user(), resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (!user && !canInteract) {
            // Anonymous users will have no explicit access on anything, so we can short-circuit
            return callback(permissionErr);
        } else if (AuthzUtil.isUserId(resource.id) || (!resource.id && resource.email)) {
            // It is not possible to have explicit access to a user (or email invitation), so we can
            // short-circuit and throw an error
            if (!canInteract) {
                return callback(permissionErr);
            } else {
                return callback();
            }
        }

        // We are an authenticated user, checking interaction on a non-user resource, and we do not
        // have implicit ability to interact. Check explicit access
        AuthzAPI.hasAnyRole(user.id, _getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var _emailToResource = function(email) {
    var emailDomain = _.last(email.split('@'));

    // We represent a transient email invitation as a resource that has an `email` instead of an
    // `id`. We can reference it as being public since the email user will explicitly decide if they
    // want to accept an interaction
    return {
        'tenant': TenantsAPI.getTenantByEmailDomain(emailDomain),
        'email': email,
        'visibility': AuthzConstants.visibility.PUBLIC
    }
};

var _getAuthzId = function(resource) {
    return resource.groupId || resource.id;
};
