
var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzInvitationsUtil = require('oae-authz/lib/invitations/util');
var AuthzUtil = require('oae-authz/lib/util');

var TenantsAPI = require('oae-tenants');

/**
 * Determine which of all potential permissions a user has. This resolves permissions for:
 *
 *  * View
 *  * Interact
 *  * Share
 *  * Edit
 *  * Manage
 *  * SetRoles
 *
 * @param  {Context}    ctx                                 The context of the current request
 * @param  {Resource}   resource                            The resource on which we are determining permissions
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        An error that occurred, if any
 * @param  {Object}     callback.permissions                An object indicating the permissions the current user has on the resource
 * @param  {Boolean}    callback.permissions.canView        Whether or not the current user can view the resource
 * @param  {Boolean}    callback.permissions.canInteract    Whether or not the current user can interact with the resource
 * @param  {Boolean}    callback.permissions.canShare       Whether or not the current user can share the resource
 * @param  {Boolean}    callback.permissions.canEdit        Whether or not the current user can edit the resource
 * @param  {Boolean}    callback.permissions.canManage      Whether or not the current user can manage the resource
 * @param  {Boolean}    callback.permissions.canSetRoles    Whether or not the current user can set roles on the resource
 * @param  {String}     callback.effectiveRole              The effective role of the user in context
 */
var resolveEffectivePermissions = module.exports.resolveEffectivePermissions = function(ctx, resource, callback) {
    AuthzAPI.resolveEffectiveRole(ctx.user(), resource, AuthzConstants.role.ALL_PRIORITY, function(err, effectiveRole, canInteract) {
        if (err) {
            return callback(err);
        }

        var canView = _.isString(effectiveRole);
        var canManage = (effectiveRole === AuthzConstants.role.MANAGER);
        var canEdit = (canManage || (effectiveRole === AuthzConstants.role.EDITOR));
        var canSetRoles = canManage;
        var canJoin = (canInteract && (resource.joinable === AuthzConstants.joinable.YES));

        // Anyone who can interact can share, unless the resource is private. In that case, only managers can share
        var canShare = canInteract;
        if (resource.visibility === AuthzConstants.visibility.PRIVATE) {
            canShare = canManage;
        }

        var permissions = {
            'canView': canView,
            'canInteract': canInteract,
            'canJoin': canJoin,
            'canShare': canShare,
            'canEdit': canEdit,
            'canManage': canManage,
            'canSetRoles': canManage
        };

        return callback(null, permissions, effectiveRole);
    });
};

/**
 * Determine if the current user can manage the specified resource
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {Resource}   resource        The resource on which to check permission
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Thrown if the permission check fails
 */
var canManage = module.exports.canManage = function(ctx, resource, callback) {
    var permissionErr = {
        'code': 401,
        'msg': 'The current user does not have access to manage this resource'
    };
    var user = ctx.user();
    if (!user) {
        // Anonymous can never manage
        return callback(permissionErr);
    }

    AuthzAPI.resolveImplicitRole(user, resource, AuthzConstants.role.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === AuthzConstants.role.MANAGER) {
            // We have an implicit manager role (e.g., we are an administrator), succeed
            return callback();
        } else if (AuthzUtil.isUserId(resource.id)) {
            // It is not possible to have an explicit role on a user, short-circuit here
            return callback(permissionErr);
        }

        // By this point, we can only manage if we have explicit manager role
        AuthzAPI.hasRole(user.id, AuthzUtil.getAuthzId(resource), AuthzConstants.role.MANAGER, function(err, hasRole) {
            if (err) {
                return callback(err);
            } else if (!hasRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

/**
 * Determine if the current user can manage the message of the specified resource
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {Resource}   parentResource  The parent resource on which to check permission
 * @param  {Message}    message         The message on which to check permission
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Thrown if the permission check fails
 */
var canManageMessage = module.exports.canManageMessage = function(ctx, parentResource, message, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to delete this message'};
    if (!ctx.user()) {
        // Anonymous can never manage a message
        return callback(permissionErr);
    }

    resolveEffectivePermissions(ctx, parentResource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canInteract) {
            // If the user cannot interact, they cannot manage the message even if they were the
            // author
            return callback(permissionErr);
        } else if (ctx.user().id !== message.createdBy && !permissions.canManage) {
            // The user cannot delete the message if they weren't the author and if they can't
            // manage the parent resource
            return callback(permissionErr);
        }

        // The user can interact with the parent resource, and is either the author of the message
        // or can manage the parent resource
        return callback();
    });
};

/**
 * Determine if the current user can view the specified resource
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {Resource}   resource        The resource on which to check permission
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Thrown if the permission check fails
 */
var canView = module.exports.canView = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to this resource'};
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(user, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we
            // can atleast view
            return callback();
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(permissionErr);
        } else if (AuthzUtil.isUserId(resource.id)) {
            // Users can't have explicit access, therefore we can short-circuit here
            return callback(permissionErr);
        }

        // By this point, we only have access to view if we have a role on the item
        AuthzAPI.hasAnyRole(user.id, AuthzUtil.getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

/**
 * Determine if the current user can edit the specified resource
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {Resource}   resource        The resource on which to check permission
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Thrown if the permission check fails
 */
var canEdit = module.exports.canEdit = function(ctx, resource, callback) {
    resolveEffectivePermissions(ctx, resource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canEdit) {
            return callback({'code': 401, 'msg': 'The current user does not have access to edit this resource'});
        }

        return callback();
    });
};

/**
 * Determine if the current user can share the specified resource. This will validate the following:
 *
 *  * The current user in context (if any) has access to share the specified resource
 *  * The current user in context (if any) is able to share with all of the targets
 *  * The current user in context (if any) is able to associate the resource with the targets
 *      * E.g., a "viewer" should not be able to share a private resource
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {Resource}       resource                The resource on which to check permission

 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Thrown if the permission check fails
 * @param  {Object}         callback.changes
 * @param  {Object}         callback.roles
 * @param  {Object}         callback.addedMembers
 */
var canShare = module.exports.canShare = function(ctx, resource, targets, role, callback) {
    targets = targets || {};

    resolveEffectivePermissions(ctx, resource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canShare) {
            return callback({'code': 401, 'msg': 'The current user does not have access to share this resource'});
        }

        targets = {
            'principalRoles': _.map(targets.principals, function(principal) {
                return {
                    'principal': principal,
                    'role': role
                };
            }),
            'emailRoles': _.map(targets.emails, function(email) {
                return {
                    'email': email,
                    'role': role
                };
            })
        };

        _validateRoleChanges(ctx, resource, targets, {'onlyAdd': true}, function(err, members, emails) {
            if (err) {
                return callback(err);
            } else if (permissions.canManage) {
                // If we can manage the resource we don't need to check that the user in context can
                // extend the explicit access of the resource outside the set visibility
                return callback(null, members, emails);
            }

            // The user is not a manager, so we should ensure that whomever they are adding as a
            // share target already has implicit access
            var emailResourcesAdded = _.map(emails.emails.added, _emailToResource);
            var addedPrincipals = _.union(members.members.added, emailResourcesAdded);
            if (_.isEmpty(addedPrincipals)) {
                // If there are no actual changes to make, then this is basically an empty share
                // which should be fine
                return callback(null, members, emails);
            }

            // Since we are not a manager, for each principal we are sharing with, we need to make
            // sure all users already had implicit access to the resource (e.g., a non-manager can't
            // share a loggedin resource with a public user from another tenant because that would
            // violate the visibility that managers applied to the resource)
            var invalidPrincipals = {};
            var _done = _.after(addedPrincipals.length, function() {
                if (!_.isEmpty(invalidPrincipals)) {
                    return callback({
                        'code': 401,
                        'msg': 'The current user does not have access to share this resource with the specified principals',
                        'invalidPrincipals': invalidPrincipals
                    });
                }

                return callback(null, members, emails);
            });

            _.each(addedPrincipals, function(addedPrincipal) {
                AuthzAPI.resolveImplicitRole(addedPrincipal, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
                    if (err) {
                        invalidPrincipals[addedPrincipal.id || addedPrincipal.email] = err;
                    } else if (!canInteract) {
                        invalidPrincipals[addedPrincipal.id || addedPrincipal.email] = {'code': 401, 'msg': 'The current user does not have access to share this resource with the specified principals'};
                    }

                    return _done();
                });
            });
        });
    });
};

/**
 * Determine if the current user can join the specified resource. This will validate the following:
 *
 *  * The current user in context (if any) has permission to join the resource
 *  * The current user in context (if any) is not already a member of the resource being joined
 *
 * @param  {Context}    ctx                     The context of the current request
 * @param  {Resource}   resource                The resource on which to check permission
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Thrown if the permission check fails
 * @param  {Object}     callback.memberRoles    An object keyed by principal id whose value are roles of the final membership state of the resource after the join is applied
 */
var canJoin = module.exports.canJoin = function(ctx, resource, callback) {
    var user = ctx.user();
    if (!user) {
        return callback({'code': 401, 'msg': 'The current user does not have access to join this resource'});
    } else if (resource.joinable !== AuthzConstants.joinable.YES) {
        return callback({'code': 401, 'msg': 'The resource being joined is not joinable'});
    }

    var targets = {
        'principalRoles': [
            {
                'principal': ctx.user(),
                'role': AuthzConstants.role.MEMBER
            }
        ]
    }

    // If the resource is joinable, and the current user can interact with it, then it is joinable
    canInteract(ctx, resource, function(err) {
        if (err) {
            return callback(err);
        }

        // Validate the role changes. This is always going to succeed because the only role being
        // changed is the user in context. However, it needs to be done to check if the current user
        // is actually being added or not
        _validateRoleChanges(ctx, resource, targets, null, function(err, members) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(members.members.added)) {
                return callback({'code': 400, 'msg': 'The current user is already a member of the resource'});
            }

            return callback(null, members.changes, members.roles);
        });
    });
};

/**
 * Determine if the current user can remove the role of the specified resource. This is a special
 * case of updating permissions which ensures that users are always able to remove a resource they
 * manage (e.g., a group they manage, or themselves!) from a resource. This validates:
 *
 *  * The current user in context (if any) can manage the target principal (i.e., the principal is
 *    a group they manage, or the user is removing themselves)
 *  * The current user in context (if any) isn't the only manager remaining on the resource
 *
 * @param  {Context}    ctx                     The context of the current request
 * @param  {Principal}  principal               The principal being removed from the resource
 * @param  {Resource}   resource                The resource on which to check permission
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Thrown if the permission check fails
 * @param  {Object}     callback.memberRoles    An object keyed by principal id whose value are roles of the final membership state of the resource after the removal is applied
 * @param  {String}     callback.role           The current role held by the principal, before any remove operation is applied
 */
var canRemoveRole = module.exports.canRemoveRole = function(ctx, principal, resource, callback) {
    canManage(ctx, principal, function(err) {
        if (err && err.code === 401) {
            // Better contextualize this error message to indicate principal instead of resource
            return callback({'code': 401, 'msg': 'The current user does not have access to remove this principal'});
        } else if (err) {
            return callback(err);
        }

        var targets = {
            'principalRoles': [
                {
                    'role': false,
                    'principal': principal
                }
            ]
        };

        _validateRoleChanges(ctx, resource, targets, null, function(err, members) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(members.members.removed)) {
                return callback({'code': 400, 'msg': 'The principal being removed is not currently a member of the resource'});
            } else if (!_.chain(members.roles.after).values().contains(AuthzConstants.role.MANAGER).value()) {
                return callback({'code': 400, 'msg': 'The requested change will result in leaving the resource without a manager'});
            }

            return callback(null, members.changes, members.roles);
        });
    });
};

/**
 * Determine if the current user can set the specified roles on the resource. This will validate
 * that:
 *
 *  * The current user in context (if any) has access to set roles on the resource
 *  * The current user in context (if any) is able to interact with all of the targets
 *  * The role changes do not leave the resource without a manager
 *
 * @param  {Context}        ctx                                     The context of the current request
 * @param  {Resource}       resource                                The resource on which to check permission
 * @param  {Object}         [targets]                               The target role changes to be applied
 * @param  {Object[]}       [targets.emailRoles]                    The email addresses that are being invited into the resource
 * @param  {String}         [targets.emailRoles[i].email]           The email address being invited into the resource
 * @param  {String}         [targets.emailRoles[i].role]            The role in which the email is being shared
 * @param  {Object[]}       [targets.principalRoles]                The principals that are being invited into the resource
 * @param  {String}         [targets.principalRoles[i].principal]   The principal that is being associated to the resource
 * @param  {String}         [targets.principalRoles[i].role]        The role in which the principal is being associated to the resource
 * @param  {Function}       callback                                Standard callback function
 * @param  {Object}         callback.err                            Thrown if the permission check fails
 * @param  {Object}         [callback.err.invalidPrincipals]        If any of the target principals couldn't be associated, this object will be keyed by all principals that failed, and the value wil be the error that caused the failure
 * @param  {Object}         callback.memberRoles                    An object keyed by principal id whose value are roles of the final membership state of the resource after the role changes are applied
 * @param  {Principal[]}    callback.newMembers                     The members being added as a result of this change
 * @param  {Principal[]}    callback.updatedMembers                 The members whose roles are being updated as a result of this change
 * @param  {Principal[]}    callback.removedMembers                 The members who are being removed as a result of this change
 */
var canSetRoles = module.exports.canSetRoles = function(ctx, resource, targets, callback) {
    canManage(ctx, resource, function(err) {
        if (err) {
            return callback(err);
        }

        _validateRoleChanges(ctx, resource, targets, null, function(err, members, emails) {
            if (err) {
                return callback(err);
            } else if (!_.isEmpty(members.changes) && !_.chain(members.roles.after).values().contains(AuthzConstants.role.MANAGER).value()) {
                return callback({'code': 400, 'msg': 'The requested change will result in leaving the resource without a manager'});
            }

            return callback(null, members, emails);
        });
    });
};

/**
 * Determine if the current user can create a resource with the specified membership. This will
 * validate that:
 *
 *  * The current user in context (if any) is able to create resources
 *  * The current user in context (if any) is able to interact with all of the targets
 *
 * @param  {Context}        ctx                                     The context of the current request

 * @param  {Function}       callback                                Standard callback function
 * @param  {Object}         callback.err                            Thrown if the permission check fails
 * @param  {Object}         [callback.err.invalidPrincipals]        If any of the target principals couldn't be associated, this object will be keyed by all principals that failed, and the value wil be the error that caused the failure
 * @param  {Object}         callback.memberRoles                    An object keyed by principal id whose value are roles of the membership state of the resource after it is created
 * @param  {Object}         callback.emailRoles                     An object keyed by email address whose value are roles in which the email should be invited
 */
var canCreate = module.exports.canCreate = function(ctx, targets, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Anonymous users are not authorized to create resources'});
    }

    _validateRoleChanges(ctx, null, targets, null, function(err, members, emails) {
        if (err) {
            return callback(err);
        }

        return callback(null, members, emails);
    });
};

/**
 * Determine if the current user can interact with all the specified resources
 *
 * @param  {Context}        ctx                                 The context of the current request
 * @param  {Resource[]}     resources                           The resources on which to check permission
 * @param  {Function}       callback                            Standard callback function
 * @param  {Object}         callback.err                        Thrown if the permission check fails
 * @param  {Object}         [callback.err.invalidResources]     If specified, indicates the resource with which the user in context couldn't interact. The object is keyed by resource id, whose value is the error that caused the failure
 */
var canInteract = module.exports.canInteract = function(ctx, resources, callback) {
    if (!_.isArray(resources)) {
        return canInteract(ctx, _.compact([resources]), callback);
    } else if (_.isEmpty(resources)) {
        return callback();
    }

    var user = ctx.user();
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with these resources'};
    var resourceErrs = {};
    var _done = _.after(resources.length, function() {
        if (!_.isEmpty(resourceErrs)) {
            return callback(_.extend(permissionErr, {'invalidResources': resourceErrs}));
        }

        return callback();
    });

    _.each(resources, function(resource) {
        _canInteract(ctx, resource, function(err) {
            if (err) {
                resourceErrs[resource.id] = err;
            }

            return _done();
        });
    });
};

/**
 * Determine whether or not the user in context can perform the specified role changes on the
 * target principals and email addresses. In addition to computing the membership changes, this will
 * ensure that the user in context can interact with all the target principals being added
 *
 * @param  {Context}        ctx                                     The current request context
 * @param  {Resource}       resource                                The resource on which to validate role changes
 * @param  {Object}         [targets]                               The target role changes to be applied
 * @param  {Object[]}       [targets.emailRoles]                    The email addresses that are being invited into the resource
 * @param  {String}         [targets.emailRoles[i].email]           The email address being invited into the resource
 * @param  {String}         [targets.emailRoles[i].role]            The role in which the email is being shared
 * @param  {Object[]}       [targets.principalRoles]                The principals that are being invited into the resource
 * @param  {String}         [targets.principalRoles[i].principal]   The principal that is being associated to the resource
 * @param  {String}         [targets.principalRoles[i].role]        The role in which the principal is being associated to the resource
 * @param  {Function}       callback                                Standard callback function
 * @param  {Object}         callback.err                            An error that ocurred, if any
 * @param  {Object}         [callback.err.invalidPrincipals]        If any of the target principals couldn't be associated, this object will be keyed by all principals that failed, and the value wil be the error that caused the failure
 * @param  {Object}         callback.changes
 * @param  {Object}         callback.roles
 * @param  {Object}         callback.roles.before
 * @param  {Object}         callback.roles.after
 * @param  {Object}         callback.members
 * @param  {Principal[]}    callback.members.added
 * @param  {Principal[]}    callback.members.updated
 * @param  {Principal[]}    callback.members.removed
 * @param  {Object}         callback.newInvitations     The new email invitations being made
 * @api private
 */
var _validateRoleChanges = function(ctx, resource, targets, opts, callback) {
    targets = targets || {};
    targets.emailRoles = targets.emailRoles || [];
    targets.principalRoles = targets.principalRoles || [];

    _computeMemberRolesAfterChanges(resource, targets.principalRoles, opts, function(err, memberChanges, memberRoles, members) {
        if (err) {
            return callback(err);
        }

        _computeInvitationRolesAfterChanges(resource, targets.emailRoles, opts, function(err, emailChanges, emailRoles, emails) {
            if (err) {
                return callback(err);
            }

            // Expanded emails added into transient resources so they can be checked for interaction
            var emailResourcesAdded = _.map(emails.added, _emailToResource);
            var addedTargets = _.union(members.added, emailResourcesAdded);
            canInteract(ctx, addedTargets, function(err) {
                if (err && err.code === 401) {
                    // Contextualize the error a bit better than the generic `canInteract` error
                    return callback({
                        'code': 401,
                        'msg': 'The current user does not have access to add the specified principals',
                        'invalidPrincipals': err.invalidResources
                    });
                } else if (err) {
                    return callback(err);
                }

                var memberResult = {
                    'changes': memberChanges,
                    'roles': memberRoles,
                    'members': members
                };

                var emailResult = {
                    'changes': emailChanges,
                    'roles': emailRoles,
                    'emails': emails
                };

                return callback(null, memberResult, emailResult);
            });
        });
    });
};

/**
 * Determine if the current user can manage the specified resource
 *
 * @param  {Context}    ctx                                 The context of the current request
 * @param  {Resource}   resource                            The resource on which to check permission
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        Thrown if the permission check fails
 * @api private
 */
var _canInteract = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with this resource'};
    var user = ctx.user();

    // First ensure the user in context can share with the resource
    AuthzAPI.resolveImplicitRole(user, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (!canInteract) {
            if (!user) {
                // Anonymous users will not have an explicit role on anything, so we can
                // short-circuit
                return callback(permissionErr);
            } else if ((!resource.id && resource.email) || AuthzUtil.isUserId(resource.id)) {
                // If the target resource is a user (local or invited by email address) then we
                // cannot have an explicit role. So short-circuit
                return callback(permissionErr);
            }
        } else if (canInteract) {
            // If we can implicitly interact, there is no reason to check explicit access
            return callback();
        }

        // We are an authenticated user, checking interaction on a non-user resource, and we do not
        // have implicit ability to interact. Check explicit access to figure out if we can interact
        // VIA role assignment
        AuthzAPI.hasAnyRole(user.id, AuthzUtil.getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var _computeMemberRolesAfterChanges = function(resource, memberRoles, opts, callback) {
    if (_.isEmpty(memberRoles)) {
        return callback(null, {}, {}, {});
    }

    var roleChanges = {};
    _.each(memberRoles, function(memberRole) {
        roleChanges[memberRole.principal.id] = memberRole.role;
    });

    var authzId = (resource) ? AuthzUtil.getAuthzId(resource) : null;
    AuthzAPI.computeMemberRolesAfterChanges(authzId, roleChanges, opts, function(err, changes, roles, members) {
        if (err) {
            return callback(err);
        }

        var principalsById = _.chain(memberRoles).pluck('principal').indexBy('id').value();

        var getPrincipalById = _.propertyOf(principalsById);
        var memberResources = {
            'added': _.map(members.addedIds, getPrincipalById),
            'updated': _.map(members.updatedIds, getPrincipalById),
            'removed': _.map(members.removedIds, getPrincipalById)
        };

        return callback(null, changes, roles, memberResources);
    });
};

var _computeInvitationRolesAfterChanges = function(resource, emailRoles, opts, callback) {
    if (_.isEmpty(emailRoles)) {
        return callback(null, {}, {}, {});
    }

    var roleChanges = {};
    _.each(emailRoles, function(emailRole) {
        roleChanges[emailRole.email] = emailRole.role;
    });

    var authzId = (resource) ? AuthzUtil.getAuthzId(resource) : null;
    AuthzInvitationsUtil.computeInvitationRolesAfterChanges(authzId, roleChanges, opts, function(err, changes, roles, emails) {
        if (err) {
            return callback(err);
        }

        return callback(null, changes, roles, emails);
    });
};

/**
 * Convert the given email address into a full resource including the associated tenant and default
 * visibility
 *
 * @param  {String}     email   The email address from which to derive a resource object
 * @return {Resource}           The resource that represents the given email address
 * @api private
 */
var _emailToResource = function(email) {
    // We represent a transient email invitation as a resource that has an `email` instead of an
    // `id`. We can reference it as being public since the email user will explicitly decide if they
    // want to accept an interaction
    return {
        'tenant': TenantsAPI.getTenantByEmail(email),
        'email': email,
        'visibility': AuthzConstants.visibility.PUBLIC
    };
};
