
var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants');

var canView = module.exports.canView = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to this resource'};
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(user, resource, ['viewer'], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we
            // can atleast view
            return callback(permissionErr);
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(permissionErr);
        }

        // By this point, we only have access to view if we have a role on the item
        AuthzAPI.hasAnyRole(user.id, _getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var canShare = module.exports.canShare = function(ctx, resource, opts, callback) {
    opts = opts || {};
    opts.principals = opts.principals || [];
    opts.emails = opts.emails || [];

    // Determine the current user's role on the resource
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to share this resource'};
    var user = ctx.user();
    AuthzAPI.resolveEffectiveRole(user, resource, ['viewer', 'manager'], function(err, effectiveRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (!canInteract) {
            return callback(permissionErr);
        } else if (_.isEmpty(opts.principals)) {
            return callback();
        }

        // Then determine if the user in context can share with the target principals
        canInteract(ctx, opts.principals, function(err) {
            if (err && err.code === 401) {
                // Better contextualize the more generic `canInteract` error for the share operation
                return callback({
                    'code': 401,
                    'msg': 'The current user does not have access to share with the specified principals'
                    'invalidPrincipals': err.invalidResources
                });
            } else if (err) {
                return callback(err);
            } else if (effectiveRole === 'manager') {
                // If the user in context has the highest effective role, then the resource->
                // principals interaction checks are not applicable
                return callback();
            }

            // Since we are not a manager, for each principal we are sharing with, we need to make
            // sure all users already had implicit access to the resource (e.g., a non-manager can't
            // share a loggedin resource with a public user from another tenant because that would
            // violate the visibility that managers applied to the resource)
            var invalidPrincipals = {};
            var done = _.after(opts.principals.length, function() {
                if (!_.isEmpty(invalidPrincipals)) {
                    return callback({
                        'code': 401,
                        'msg': 'The current user does not have access to share this resource with the specified principals',
                        'invalidPrincipals': invalidPrincipals
                    });
                }

                return callback();
            });

            _.each(principals, function(principal) {
                AuthzAPI.resolveImplicitRole(principal, resource, ['viewer'], function(err, implicitRole, canInteract) {
                    if (err) {
                        invalidPrincipals[principal.id] = err;
                    } else if (!canInteract) {
                        invalidPrincipals[principal.id] = {'code': 401, 'msg': 'The current user does not have access to share this resource with the specified principals'};
                    }

                    return done();
                });
            });
        });
    });
};

var canSetRoles = module.exports.canSetRoles = function(ctx, resource, opts, callback) {
    opts = opts || {};
    opts.principalRoles = opts.principalRoles || [];
    opts.emailRoles = opts.emailRoles || [];

    // Determine the current user's role on the resource
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to set roles on this resource'};
    var user = ctx.user();
    AuthzAPI.resolveEffectiveRole(user, resource, ['viewer', 'manager'], function(err, effectiveRole) {
        if (err) {
            return callback(err);
        } else if (effectiveRole !== 'manager') {
            return callback(permissionErr);
        } else if (_.isEmpty(opts.principalRoles)) {
            return callback();
        }


    });

};

var canInteract = module.exports.canInteract = function(ctx, resources, callback) {
    if (!_.isEmpty(resources)) {
        return callback({'err': 400, 'msg': 'At least one principal must be specified to check for interaction'});
    } else if (!_.isArray(resources)) {
        return canInteract(ctx, [resources], callback);
    }

    var user = ctx.user();
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with these resources'};
    var resourceErrs = {};
    var done = _.after(resources.length, function() {
        if (!_.isEmpty(resourceErrs)) {
            return callback(_.extend(permissionError, {'invalidResources': resourceErrs}));
        }

        return callback();
    });

    _.each(resources, function(resource) {
        _canInteract(ctx, resource, function(err) {
            if (err) {
                resourceErrs[resource.id] = err;
            }

            return done();
        });
    })

};

var _canInteract = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with this resource'};
    var user = ctx.user();

    // First ensure the user in context can share with the resource
    AuthzAPI.resolveImplicitRole(ctx.user(), resource, ['viewer'], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (!user && !canInteract) {
            // Anonymous users will have no explicit access on anything, so we can short-circuit
            return callback(permissionErr);
        } else if (AuthzUtil.isUserId(resource.id) || (!resource.id && resource.email)) {
            // It is not possible to have explicit access to a user (or email invitation), so we can
            // short-circuit
            if (!canInteract) {
                return callback(permissionErr);
            } else {
                return callback();
            }
        }

        // We are an authenticated user, checking interaction on a non-user resource, and we do not
        // have implicit ability to interact. Check explicit access
        AuthzAPI.hasAnyRole(user.id, resource.authzId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var _emailToResource = function(email) {
    var emailDomain = _.last(email.split('@'));

    // We represent a transient email invitation as a resource that has an `email` instead of an
    // `id`. We can reference it as being public since the email user will explicitly decide if they
    // want to accept an interaction
    return {
        'tenant': TenantsAPI.getTenantByEmailDomain(emailDomain),
        'email': email,
        'visibility': AuthzConstants.visibility.PUBLIC
    }
};

var _getAuthzId = function(resource) {
    return resource.authzId || resource.id;
};
