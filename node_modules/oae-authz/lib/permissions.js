
var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');

var resolveEffectivePermissions = module.exports.resolveEffectivePermissions = function(ctx, resource, callback) {
    AuthzAPI.resolveEffectiveRole(ctx.user(), resource, AuthzConstants.role.ALL_PRIORITY, function(err, effectiveRole, canInteract) {
        if (err) {
            return callback(err);
        }

        var canView = _.isString(effectiveRole);
        var canManage = (effectiveRole === AuthzConstants.role.MANAGER);
        var canSetRoles = canManage;

        // Anyone who can interact can share, unless the resource is private. In that case, only managers can share
        var canShare = canInteract;
        if (resource.visibility === AuthzConstants.visibility.PRIVATE) {
            canShare = canManage;
        }

        return callback(null, {
            'canView': canView,
            'canInteract': canInteract,
            'canShare': canShare,
            'canManage': canManage,
            'canSetRoles': canManage
        });
    });
};

var canManage = module.exports.canManage = function(ctx, resource, callback) {
    var permissionErr = {
        'code': 401,
        'msg': 'The current user does not have access to manage this resource'
    };
    var user = ctx.user();
    if (!user) {
        // Anonymous can never manage
        return callback(permissionErr);
    }

    AuthzAPI.resolveImplicitRole(user, resource, AuthzConstants.role.ALL_PRIORITY, function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole === AuthzConstants.role.MANAGER) {
            // We have an implicit manager role (e.g., we are an administrator), succeed
            return callback();
        } else if (AuthzUtil.isUserId(resource.id)) {
            // It is not possible to have an explicit role on a user, short-circuit here
            return callback(permissionErr);
        }

        // By this point, we can only manage if we have explicit manager role
        AuthzAPI.hasRole(user.id, _getAuthzId(resource), AuthzConstants.role.MANAGER, function(err, hasRole) {
            if (err) {
                return callback(err);
            } else if (!hasRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var canManageMessage = module.exports.canManageMessage = function(ctx, parentResource, message, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to delete this message'};
    if (!ctx.user()) {
        // Anonymous can never manage a message
        return callback(permissionErr);
    }

    resolveEffectivePermissions(ctx, parentResource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canInteract) {
            // If the user cannot interact, they cannot manage the message even if they were the
            // author
            return callback(permissionErr);
        } else if (ctx.user().id !== message.createdBy && !permissions.canManage) {
            // The user cannot delete the message if they weren't the author and if they can't
            // manage the parent resource
            return callback(permissionErr);
        }

        // The user can interact with the parent resource, and is either the author of the message
        // or can manage the parent resource
        return callback();
    });
};

var canView = module.exports.canView = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to this resource'};
    var user = ctx.user();
    AuthzAPI.resolveImplicitRole(user, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (implicitRole) {
            // We have an implicit access, no reason to try and find an explicit access because we
            // can atleast view
            return callback();
        } else if (!user) {
            // Anonymous user with no implicit access cannot view
            return callback(permissionErr);
        }

        // By this point, we only have access to view if we have a role on the item
        AuthzAPI.hasAnyRole(user.id, _getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var canShare = module.exports.canShare = function(ctx, resource, opts, callback) {
    opts = opts || {};
    opts.principals = opts.principals || [];
    opts.emails = opts.emails || [];

    resolveEffectivePermissions(ctx, resource, function(err, permissions) {
        if (err) {
            return callback(err);
        } else if (!permissions.canShare) {
            return callback({'code': 401, 'msg': 'The current user does not have access to share this resource'});
        }

        var roleChangeOpts = {
            'principalRoles': _.map(opts.principals, function(principal) {
                return {
                    'role': AuthzConstants.role.VIEWER,
                    'principal': principal
                };
            }),
            'emailRoles': _.map(opts.emails, function(email) {
                return {
                    'role': AuthzConstants.role.VIEWER,
                    'email': email
                };
            })
        };

        _validateRoleChanges(ctx, resource, roleChangeOpts, function(err, memberRoles, newMembers) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(newMembers)) {
                // If there are no new members, then this is basically an empty share which should
                // be fine
                return callback(null, [], memberRoles);
            } else if (permissions.canManage) {
                // If the user can manage the resource, then we don't care about resource->target
                // visibility violations, as managers can extend those boundaries VIA share
                return callback(null, newMembers, memberRoles);
            }

            // Since we are not a manager, for each principal we are sharing with, we need to make
            // sure all users already had implicit access to the resource (e.g., a non-manager can't
            // share a loggedin resource with a public user from another tenant because that would
            // violate the visibility that managers applied to the resource)
            var invalidPrincipals = {};
            var _done = _.after(newMembers.length, function() {
                if (!_.isEmpty(invalidPrincipals)) {
                    return callback({
                        'code': 401,
                        'msg': 'The current user does not have access to share this resource with the specified principals',
                        'invalidPrincipals': invalidPrincipals
                    });
                }

                return callback(null, newMembers, memberRoles);
            });

            _.each(newMembers, function(newMember) {
                AuthzAPI.resolveImplicitRole(newMember, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
                    if (err) {
                        invalidPrincipals[newMember.id] = err;
                    } else if (!canInteract) {
                        invalidPrincipals[newMember.id] = {'code': 401, 'msg': 'The current user does not have access to share this resource with the specified principals'};
                    }

                    return _done();
                });
            });
        });
    });
};

var canJoin = module.exports.canJoin = function(ctx, resource, callback) {
    var user = ctx.user();
    if (user) {
        return callback({'code': 401, 'msg': 'The current user does not have access to join this resource'});
    } else if (resource.joinable !== AuthzConstants.joinable.YES) {
        return callback({'code': 401, 'msg': 'The resource being joined is not joinable'});
    }

    var principalRoles = [{
        'principal': ctx.user(),
        'role': AuthzConstants.role.MEMBER
    }];

    // If the resource is joinable, and the current user can interact with it, then it is joinable
    canInteract(ctx, resource, function(err) {
        if (err) {
            return callback(err);
        }

        // Validate the role changes. This is always going to succeed because the only role being
        // changed
        _validateRoleChanges(ctx, resource, {'principalRoles': principalRoles}, function(err, memberRoles, newMembers) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(newMembers)) {
                return callback({'code': 400, 'msg': 'The current user is already a member of the resource'});
            }

            return callback(null, memberRoles);
        });
    });
};

var canRemoveRole = module.exports.canRemoveRole = function(ctx, principal, resource, callback) {
    canManage(ctx, principal, function(err) {
        if (err && err.code === 401) {
            // Better contextualize this error message to indicate principal instead of resource
            return callback({'code': 401, 'msg': 'The current user does not have access to remove this principal'});
        } else if (err) {
            return callback(err);
        }

        var principalRoles = [{
            'role': false,
            'principal': principal
        }];

        _validateRoleChanges(ctx, resource, {'principalRoles': principalRoles}, function(err, memberRoles, newMembers, updatedMembers, removedMembers, memberRolesBeforeChanges) {
            if (err) {
                return callback(err);
            } else if (_.isEmpty(removedMembers)) {
                return callback({'code': 400, 'msg': 'The principal being removed is not currently a member of the resource'});
            } else if (!_.chain(memberRoles).values().contains(AuthzConstants.role.MANAGER).value()) {
                return callback({'code': 400, 'msg': 'The requested change will result in leaving the resource without a manager'});
            }

            return callback(null, memberRoles, memberRolesBeforeChanges[principal.id]);
        });
    });
};

var canSetRoles = module.exports.canSetRoles = function(ctx, resource, opts, callback) {
    canManage(ctx, resource, function(err) {
        if (err) {
            return callback(err);
        }

        _validateRoleChanges(ctx, resource, opts, function(err, memberRoles, newMembers, updatedMembers, removedMembers) {
            if (err) {
                return callback(err);
            } else if (!_.chain(memberRoles).values().contains(AuthzConstants.role.MANAGER).value()) {
                return callback({'code': 400, 'msg': 'The requested change will result in leaving the resource without a manager'});
            }

            return callback(null, memberRoles, newMembers, updatedMembers, removedMembers);
        });
    });
};

var canInteract = module.exports.canInteract = function(ctx, resources, callback) {
    if (!_.isArray(resources)) {
        return canInteract(ctx, _.compact([resources]), callback);
    } else if (_.isEmpty(resources)) {
        return callback();
    }

    var user = ctx.user();
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with these resources'};
    var resourceErrs = {};
    var _done = _.after(resources.length, function() {
        if (!_.isEmpty(resourceErrs)) {
            return callback(_.extend(permissionErr, {'invalidResources': resourceErrs}));
        }

        return callback();
    });

    _.each(resources, function(resource) {
        _canInteract(ctx, resource, function(err) {
            if (err) {
                resourceErrs[resource.id] = err;
            }

            return _done();
        });
    });
};

var _validateRoleChanges = function(ctx, resource, opts, callback) {
    opts = opts || {};
    opts.principalRoles = opts.principalRoles || [];
    opts.emailRoles = opts.emailRoles || [];

    var emailResources = _.chain(opts.emailRoles)
        .pluck('email')
        .map(_emailToResource)
        .value();

    // Build our hash indicating the membership changes to make
    var roleChanges = {};
    _.each(opts.principalRoles, function(principalRole) {
        roleChanges[principalRole.principal.id] = principalRole.role;
    });

    AuthzAPI.computeMemberRolesAfterChanges(_getAuthzId(resource), roleChanges, function(err, memberRoles, newMemberIds, updatedMemberIds, removedMemberIds, memberRolesBeforeChanges) {
        if (err) {
            return callback(err);
        }

        // Map all member ids to their principal resources
        var principals = _.pluck(opts.principalRoles, 'principal');
        var principalsById = _.indexBy(principals, 'id');
        var newMembers = _.map(newMemberIds, _.propertyOf(principalsById));
        var updatedMembers = _.map(updatedMemberIds, _.propertyOf(principalsById));
        var removedMembers = _.map(removedMemberIds, _.propertyOf(principalsById));

        // For users who are being added to the resource, ensure interaction boundaries are not
        // being violated between the user in context and the target principal. Users who were
        // already associated can have their role changed or removed by a manager regardless of
        // tenant interaction boundaries
        var newTargets = _.union(newMembers, emailResources);

        canInteract(ctx, newTargets, function(err) {
            if (err && err.code === 401) {
                // Contextualize the error a bit better than the generic `canInteract` error
                return callback({
                    'code': 401,
                    'msg': 'The current user does not have access to add the specified principals',
                    'invalidPrincipals': err.invalidResources
                });
            } else if (err) {
                return callback(err);
            }

            return callback(null, memberRoles, newMembers, updatedMembers, removedMembers, memberRolesBeforeChanges);
        });
    });
};

var _canInteract = function(ctx, resource, callback) {
    var permissionErr = {'code': 401, 'msg': 'The current user does not have access to interact with this resource'};
    var user = ctx.user();

    // First ensure the user in context can share with the resource
    AuthzAPI.resolveImplicitRole(user, resource, [AuthzConstants.role.VIEWER], function(err, implicitRole, canInteract) {
        if (err) {
            return callback(err);
        } else if (!canInteract) {
            if (!user) {
                // Anonymous users will not have an explicit role on anything, so we can
                // short-circuit
                return callback(permissionErr);
            } else if (AuthzUtil.isUserId(resource.id) || (!resource.id && resource.email)) {
                // If the target resource is a user (local or invited by email address) then we
                // cannot have an explicit role. So short-circuit
                return callback(permissionErr);
            }
        } else if (canInteract) {
            // If we can implicitly interact, there is no reason to check explicit access
            return callback();
        }

        // We are an authenticated user, checking interaction on a non-user resource, and we do not
        // have implicit ability to interact. Check explicit access to figure out if we can interact
        // VIA role assignment
        AuthzAPI.hasAnyRole(user.id, _getAuthzId(resource), function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            } else if (!hasAnyRole) {
                return callback(permissionErr);
            }

            return callback();
        });
    });
};

var _emailToResource = function(email) {
    var emailDomain = _.last(email.split('@'));

    // We represent a transient email invitation as a resource that has an `email` instead of an
    // `id`. We can reference it as being public since the email user will explicitly decide if they
    // want to accept an interaction
    return {
        'tenant': TenantsAPI.getTenantByEmailDomain(emailDomain),
        'email': email,
        'visibility': AuthzConstants.visibility.PUBLIC
    };
};

var _getAuthzId = function(resource) {
    return resource.groupId || resource.id;
};
