/*
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var util = require('util');

var ContentTestUtil = require('oae-content/lib/test/util');
var DiscussionsTestUtil = require('oae-discussions/lib/test/util');
var EmailTestUtil = require('oae-email/lib/test/util');
var FoldersTestUtil = require('oae-folders/lib/test/util');
var PrincipalsTestUtil = require('oae-principals/lib/test/util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var TenantsAPI  = require('oae-tenants');
var TenantsTestUtil = require('oae-tenants/lib/test/util');
var TestsUtil = require('oae-tests');

var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var AuthzTestUtil = require('oae-authz/lib/test/util');
var AuthzUtil = require('oae-authz/lib/util');

describe('Invitations', function() {

    // Initialize some rest contexts for anonymous and admin users
    var anonymousRestContext = null;
    var camAdminRestContext = null;
    var gtAdminRestContext = null;
    var globalAdminRestContext = null;

    var randomString = TestsUtil.generateRandomText(1);

    var resourceMemberRoles = {
        'content': 'viewer',
        'discussion': 'member',
        'folder': 'viewer',
        'group': 'member'
    };

    var resourceFns = {
        'content': {
            'createSucceeds': _.partial(ContentTestUtil.assertCreateLinkSucceeds, _, randomString, randomString, _, 'http://oae.local', _, _, [], _),
            'createFails': _.partial(ContentTestUtil.assertCreateLinkFails, _, randomString, randomString, _, 'http://oae.local', _, _, [], _, _),
            'shareSucceeds': ContentTestUtil.assertShareContentSucceeds,
            'shareFails': ContentTestUtil.assertShareContentFails,
            'setRolesSucceeds': ContentTestUtil.assertUpdateContentMembersSucceeds,
            'setRolesFails': ContentTestUtil.assertUpdateContentMembersFails,
            'getMembersSucceeds': _.partial(ContentTestUtil.getAllContentMembers, _, _, null, _),
            'getLibrarySucceeds': _.partial(ContentTestUtil.assertGetAllContentLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': ContentTestUtil.assertDeleteContentSucceeds
        },
        'discussion': {
            'createSucceeds': _.partial(DiscussionsTestUtil.assertCreateDiscussionSucceeds, _, randomString, randomString, _, _, _, _),
            'createFails': _.partial(DiscussionsTestUtil.assertCreateDiscussionFails, _, randomString, randomString, _, _, _, _, _),
            'shareSucceeds': DiscussionsTestUtil.assertShareDiscussionSucceeds,
            'shareFails': DiscussionsTestUtil.assertShareDiscussionFails,
            'setRolesSucceeds': DiscussionsTestUtil.assertUpdateDiscussionMembersSucceeds,
            'setRolesFails': DiscussionsTestUtil.assertUpdateDiscussionMembersFails,
            'getMembersSucceeds': _.partial(DiscussionsTestUtil.getAllDiscussionMembers, _, _, null, _),
            'getLibrarySucceeds': _.partial(DiscussionsTestUtil.assertGetAllDiscussionsLibrarySucceeds, _, _, null, _)
        },
        'folder': {
            'createSucceeds': _.partial(FoldersTestUtil.assertCreateFolderSucceeds, _, randomString, randomString, _, _, _, _),
            'createFails': _.partial(FoldersTestUtil.assertCreateFolderFails, _, randomString, randomString, _, _, _, _, _),
            'shareSucceeds': FoldersTestUtil.assertShareFolderSucceeds,
            'shareFails': FoldersTestUtil.assertShareFolderFails,
            'setRolesSucceeds': FoldersTestUtil.assertUpdateFolderMembersSucceeds,
            'setRolesFails': FoldersTestUtil.assertUpdateFolderMembersFails,
            'getMembersSucceeds': _.partial(FoldersTestUtil.assertGetAllFolderMembersSucceeds, _, _, null, _),
            'getLibrarySucceeds': _.partial(FoldersTestUtil.assertGetAllFoldersLibrarySucceeds, _, _, null, _)
        },
        'group': {
            'createSucceeds': _.partial(PrincipalsTestUtil.assertCreateGroupSucceeds, _, randomString, randomString, _, 'no', _, _, _),
            'createFails': _.partial(PrincipalsTestUtil.assertCreateGroupFails, _, randomString, randomString, _, 'no', _, _, _, _),
            'setRolesSucceeds': PrincipalsTestUtil.assertSetGroupMembersSucceeds,
            'setRolesFails': PrincipalsTestUtil.assertSetGroupMembersFails,
            'getMembersSucceeds': _.partial(PrincipalsTestUtil.assertGetAllMembersLibrarySucceeds, _, _, null, _),
            'getLibrarySucceeds': _.partial(PrincipalsTestUtil.assertGetAllMembershipsLibrarySucceeds, _, _, null, _)
        }
    };

    before(function(callback) {
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        return callback();
    });

    describe('Create', function() {

        describe('Content', function() {

            it('verify creating content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('content', callback);
            });

            it('verify validation of creating content with invitations', function(callback) {
                return _testInvitationsValidationForCreate('content', callback);
            });

            it('verify authorization of creating content with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify creating discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('discussion', callback);
            });

            it('verify validation of creating discussion with invitations', function(callback) {
                return _testInvitationsValidationForCreate('discussion', callback);
            });

            it('verify authorization of creating discussion with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify creating folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('folder', callback);
            });

            it('verify validation of creating folder with invitations', function(callback) {
                return _testInvitationsValidationForCreate('folder', callback);
            });

            it('verify authorization of creating folder with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('folder', callback);
            });
        });

        describe('Group', function() {

            it('verify creating group with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('group', callback);
            });

            it('verify validation of creating group with invitations', function(callback) {
                return _testInvitationsValidationForCreate('group', callback);
            });

            it('verify authorization of creating group with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('group', callback);
            });
        });
    });

    describe('Share', function() {

        describe('Content', function() {

            it('verify sharing content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('content', callback);
            });

            it('verify validation of content share with invitations', function(callback) {
                return _testInvitationsValidationForShare('content', callback);
            });

            it('verify authorization of content share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify sharing discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('discussion', callback);
            });

            it('verify validation of discussion share with invitations', function(callback) {
                return _testInvitationsValidationForShare('discussion', callback);
            });

            it('verify authorization of discussion share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify sharing folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('folder', callback);
            });

            it('verify validation of folder share with invitations', function(callback) {
                return _testInvitationsValidationForShare('folder', callback);
            });

            it('verify authorization of folder share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('folder', callback);
            });
        });
    });

    describe('Set Roles', function() {

        describe('Content', function() {

            it('verify setting roles of content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('content', 'viewer', callback);
            });

            it('verify validation of setting roles of content with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('content', 'viewer', callback);
            });

            it('verify authorization of setting roles of content with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('content', 'viewer', callback);
            });
        });

        describe('Discussion', function() {

            it('verify setting roles of discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('discussion', 'member', callback);
            });

            it('verify validation of setting roles of discussion with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('discussion', 'member', callback);
            });

            it('verify authorization of setting roles of discussion with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('discussion', 'member', callback);
            });
        });

        describe('Folder', function() {

            it('verify setting roles of folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('folder', 'viewer', callback);
            });

            it('verify validation of setting roles of folder with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('folder', 'viewer', callback);
            });

            it('verify authorization of setting roles of folder with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('folder', 'viewer', callback);
            });
        });

        describe('Group', function() {

            it('verify setting roles of group with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('group', 'member', callback);
            });

            it('verify validation of setting roles of group with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('group', 'member', callback);
            });

            it('verify authorization of setting roles of group with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('group', 'member', callback);
            });
        });
    });

    describe('Accept', function() {

        describe('Content', function() {

            it('verify accepting an invitation with content', function(callback) {
                _testInvitationAccept('content', 'viewer', callback);
            });

            it('verify validation of accepting an invitation with content', function(callback) {
                _testInvitationAcceptValidation('content', callback);
            });

            it('verify authorization of accepting an invitation with content', function(callback) {
                _testInvitationAcceptAuthorization('content', 'viewer', callback);
            });
        });

        describe('Discussion', function() {

            it('verify accepting an invitation with discussions', function(callback) {
                _testInvitationAccept('discussion', 'member', callback);
            });

            it('verify validation of accepting an invitation with discussions', function(callback) {
                _testInvitationAcceptValidation('discussion', callback);
            });

            it('verify authorization of accepting an invitation with discussions', function(callback) {
                _testInvitationAcceptAuthorization('discussion', 'member', callback);
            });
        });

        describe('Folder', function() {

            it('verify accepting an invitation with folders', function(callback) {
                _testInvitationAccept('folder', 'viewer', callback);
            });

            it('verify validation of accepting an invitation with folders', function(callback) {
                _testInvitationAcceptValidation('folder', callback);
            });

            it('verify authorization of accepting an invitation with folders', function(callback) {
                _testInvitationAcceptAuthorization('folder', 'viewer', callback);
            });
        });

        describe('Group', function() {

            it('verify accepting an invitation with groups', function(callback) {
                _testInvitationAccept('group', 'member', callback);
            });

            it('verify validation of accepting an invitation with groups', function(callback) {
                _testInvitationAcceptValidation('group', callback);
            });

            it('verify authorization of accepting an invitation with groups', function(callback) {
                _testInvitationAcceptAuthorization('group', 'member', callback);
            });
        });
    });

    describe('Email', function() {

        it('verify email invitation links to the proper tenant based on email domain', function(callback) {
            var fns = resourceFns.content;
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user) {
                assert.ok(!err);

                var cambridgeEmail = _emailForTenant(global.oaeTests.tenants.cam);
                var guestEmail = _emailForDomain(TenantsTestUtil.generateTestTenantHost());
                EmailTestUtil.collectAndFetchAllEmails(function() {

                    fns.createSucceeds(user.restContext, 'public', [cambridgeEmail], [guestEmail], function(resource) {

                        EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                            // There should be 2 emails, one for cambridgeEmail and one for guestEmail
                            assert.strictEqual(messages.length, 2);

                            var cambridgeMessage = _.find(messages, function(message) {
                                return (message.headers.to === cambridgeEmail);
                            });

                            var guestMessage = _.find(messages, function(message) {
                                return (message.headers.to === guestEmail);
                            });

                            // Grab the invitation link from the messages
                            var cambridgeInvitationUrl = AuthzTestUtil.parseInvitationUrlFromMessage(cambridgeMessage);
                            var guestInvitationUrl = AuthzTestUtil.parseInvitationUrlFromMessage(guestMessage);

                            // Ensure the links are to the proper tenancy
                            assert.strictEqual(cambridgeInvitationUrl.host, global.oaeTests.tenants.cam.host);
                            assert.strictEqual(guestInvitationUrl.host, TenantsAPI.getTenant('guest').host);

                            return callback();
                        });
                    });
                });
            });
        });

        it('verify it sends an aggregated email for all resource types', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
                assert.ok(!err);

                // Generate the email to invite and ensure we start with an empty email queue
                var email = _emailForTenant(global.oaeTests.tenants.cam);
                EmailTestUtil.collectAndFetchAllEmails(function() {

                    // Create a resource of each known type, aggregating them into the `createResults`
                    // object
                    var createResults = [];
                    var _doneCreate = _.chain(resourceFns)
                        .size()
                        .after(function() {
                            var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                            _assertAcceptEmailInvitation(creatingUser, acceptingUser, _.values(createResults), assertions, function() {
                                return callback();
                            });
                        })
                        .value();

                    // Perform all the creates and kick off the assertions on the created resources
                    // and invitations
                    PrincipalsTestUtil.assertGetMeSucceeds(creatingUser.restContext, function(me) {
                        _.each(resourceFns, function(fns) {
                            fns.createSucceeds(creatingUser.restContext, 'public', [email], [], function(resource) {
                                createResults.push(resource);
                                return _doneCreate();
                            });
                        });
                    });
                });
            });
        });

        describe('Content', function() {

            it('verify it sends an aggregated invitation for content of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('content', callback);
            });

            it('verify it sends an aggregated invitation for content of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('content', callback);
            });

            it('verify it sends an aggregated invitation for content of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('content', 'viewer', callback);
            });
        });

        describe('Discussion', function() {

            it('verify it sends an aggregated invitation for discussions of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('discussion', callback);
            });

            it('verify it sends an aggregated invitation for discussions of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('discussion', callback);
            });

            it('verify it sends an aggregated invitation for discussions of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('discussion', 'member', callback);
            });
        });

        describe('Folder', function() {

            it('verify it sends an aggregated invitation for folders of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('folder', callback);
            });

            it('verify it sends an aggregated invitation for folders of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('folder', callback);
            });

            it('verify it sends an aggregated invitation for folders of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('folder', 'viewer', callback);
            });
        });

        describe('Group', function() {

            it('verify it sends an aggregated invitation for groups of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('group', callback);
            });

            it('verify it sends an aggregated invitation for groups of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('group', callback);
            });
        });
    });

    var _testInvitationEmailVisibilityForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {

                fns.createSucceeds(creatingUser.restContext, 'public', [email], [], function(resource1) {
                    fns.createSucceeds(creatingUser.restContext, 'loggedin', [email], [], function(resource2) {
                        fns.createSucceeds(creatingUser.restContext, 'private', [email], [], function(resource3) {
                            var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                            _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailVisibilityForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {

                // Create a resource of each visibility
                fns.createSucceeds(creatingUser.restContext, 'public', [], [], function(resource1) {
                    fns.createSucceeds(creatingUser.restContext, 'loggedin', [], [], function(resource2) {
                        fns.createSucceeds(creatingUser.restContext, 'private', [], [], function(resource3) {
                            var roleChange = _.object([[email, 'manager']]);

                            // Set the accepting user as a manager on all 3 using set roles
                            fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource1.id, roleChange, function() {
                                fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource2.id, roleChange, function() {
                                    fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource3.id, roleChange, function() {

                                        // Ensure the user can accept the email invitation
                                        var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                                        _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailVisibilityForShare = function(resourceType, memberRole, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {

                // Create a resource of each visibility
                fns.createSucceeds(creatingUser.restContext, 'public', [], [], function(resource1) {
                    fns.createSucceeds(creatingUser.restContext, 'loggedin', [], [], function(resource2) {
                        fns.createSucceeds(creatingUser.restContext, 'private', [], [], function(resource3) {

                            // Share with each resource
                            fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource1.id, [email], function() {
                                fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource2.id, [email], function() {
                                    fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource3.id, [email], function() {
                                        var assertions = {'role': memberRole, 'membersSize': 2, 'librarySize': 3};
                                        // Ensure the user can accept the email invitation
                                        _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAccept = function(resourceType, memberRole, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, userManager, userViewer) {
            assert.ok(!err);

            var managerEmail = _emailForTenant(global.oaeTests.tenants.cam);
            var viewerEmail = _emailForTenant(global.oaeTests.tenants.cam);

            // Create a resource. 2 separate invitations will go out
            fns.createSucceeds(user0.restContext, 'public', [managerEmail], [viewerEmail], function(resource) {
                var resourceAuthzId = AuthzUtil.getAuthzId(resource);

                // Accept the manager invitation and ensure they show up in the members
                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(userManager.restContext, managerEmail, function(invitations) {
                    assert.strictEqual(invitations.length, 1);

                    var invitation = _.first(invitations);
                    assert.strictEqual(invitation.resourceId, resourceAuthzId);
                    assert.strictEqual(invitation.email, managerEmail);
                    assert.strictEqual(invitation.inviterUserId, user0.user.id);
                    assert.strictEqual(invitation.role, 'manager');

                    var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                    _assertRole(user0, userManager, resource, assertions, function() {
                        // Accept the viewer invitation and ensure they show up in the members
                        AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(userViewer.restContext, viewerEmail, function(invitations) {
                            assert.strictEqual(invitations.length, 1);

                            var invitation = _.first(invitations);
                            assert.strictEqual(invitation.resourceId, resourceAuthzId);
                            assert.strictEqual(invitation.email, viewerEmail);
                            assert.strictEqual(invitation.inviterUserId, user0.user.id);
                            assert.strictEqual(invitation.role, memberRole);

                            assertions = {'role': memberRole, 'membersSize': 3, 'librarySize': 1};
                            _assertRole(user0, userViewer, resource, assertions, function() {
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAcceptAuthorization = function(resourceType, memberRole, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 6, function(err, users, user0, user1, user2, user3, user4, user5) {
            assert.ok(!err);

            var email1 = _emailForTenant(global.oaeTests.tenants.cam);
            var email2 = _emailForTenant(global.oaeTests.tenants.cam);
            var email3 = _emailForTenant(global.oaeTests.tenants.cam);
            var email4 = _emailForTenant(global.oaeTests.tenants.cam);
            var email5 = _emailForTenant(global.oaeTests.tenants.cam);

            fns.createSucceeds(user0.restContext, 'private', [email1], [], function(resource) {

                // Accept as user1
                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user1.restContext, email1, function() {

                    // Ensure user1 can now set roles since they should be manager
                    var roles = {};
                    roles[email2] = 'manager';
                    roles[email3] = memberRole;
                    roles[email4] = memberRole;
                    roles[email5] = memberRole;
                    fns.setRolesSucceeds(user0.restContext, user1.restContext, resource.id, roles, function() {

                        // Remove the user who invited email2 and ensure email2 invitation can still be accepted
                        roles = {};
                        roles[user1.user.id] = false;
                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, roles, function() {

                            // Ensure email2 can still be accepted and makes user2 a manager
                            AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user2.restContext, email2, function() {
                                _assertRole(user0, user2, resource, {'role': 'manager'}, function() {

                                    // Accept the "member" role invitation for email3 as user2, ensuring their role
                                    // on the resource does not get demoted to the "member" role
                                    AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user2.restContext, email3, function() {
                                        _assertRole(user0, user2, resource, {'role': 'manager'}, function() {

                                            // Delete user1 from the system, and ensure the user they
                                            // invited can still accept their invitation
                                            PrincipalsTestUtil.assertDeleteUserSucceeds(camAdminRestContext, camAdminRestContext, user1.user.id, function() {

                                                // Accept the invitation for email4 and ensure it succeeds despite the fact that
                                                // the user that invited them was deleted
                                                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user4.restContext, email4, function() {
                                                    _assertRole(user0, user4, resource, {'role': memberRole}, function() {

                                                        // Remove the invitation for email5, ensuring an invitation for email5 can still
                                                        // be accepted, but it doesn't grant any access to the resource
                                                        roles = {};
                                                        roles[email5] = false;
                                                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, roles, function() {
                                                            AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user5.restContext, email5, function() {
                                                                _assertRole(user0, user5, resource, {'role': false}, function() {
                                                                    return callback();
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAcceptValidation = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, acceptingUser, sneakyUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Token is required
            AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, null, 400, function() {
                // Token must exist
                AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, 'nonexistingtoken', 404, function() {

                    // Create a resource with an invitation
                    fns.createSucceeds(user0.restContext, 'public', [email], [], function(resource) {
                        AuthzInvitationsDAO.getTokensByEmails([email], function(err, tokensByEmail) {
                            assert.ok(!err);

                            var token = tokensByEmail[email];

                            // User must be logged in to accept
                            AuthzTestUtil.assertAcceptInvitationFails(anonymousRestContext, token, 401, function() {

                                // Sanity check we can accept with this token as authenticated user
                                AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUser.restContext, token, function() {

                                    // Ensure re-accepting this token as a sneaky user that intercepted it fails
                                    AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, token, 404, function() {

                                        // Ensure the accepting user became a manager of the resource
                                        _assertRole(user0, acceptingUser, resource, {'role': 'manager'}, function() {

                                            // Ensure the sneaky user does not have the resource
                                            _assertRole(user0, sneakyUser, resource, {'role': false, 'membersSize': 2}, function() {
                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, userManager, userViewer) {
            assert.ok(!err);

            // Ensure a simple create mixed with a couple member users succeeds
            fns.createSucceeds(user0.restContext, 'public', ['manager@oae.local', userManager.user.id], [userViewer.user.id, 'viewer@oae.local'], function(resource) {
                return callback();
            });
        });
    };

    var _testInvitationsValidationForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);

            // Ensure variations of email addresses fail
            fns.createFails(user0.restContext, 'public', ['invalid@email'], [], 400, function(resource) {

                // Sanity check can be created with valid email
                fns.createSucceeds(user0.restContext, 'public', ['manager@oae.local'], [], function(resource) {
                    return callback();
                });
            });
        });
    };

    var _testInvitationsAuthorizationForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {

            // Ensure cannot create content associated to an email from a private tenant
            fns.createFails(privateTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(publicTenant0)], [], 401, function(resource) {
                // Ensure cannot create content associated to a private tenant
                fns.createFails(publicTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(privateTenant0)], [], 401, function(resource) {
                    // Sanity check we can create content on our own private tenant
                    fns.createSucceeds(privateTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(privateTenant0)], [], function(resource) {
                        // Ensure a user can create a loggedin item and share it with an email of a user from another tenant
                        fns.createSucceeds(publicTenant0.publicUser.restContext, 'loggedin', [_emailForTenantInfo(publicTenant1)], [], function(resource) {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, userSharer, user0, user1) {
            assert.ok(!err);
            fns.createSucceeds(userSharer.restContext, 'public', ['email1@oae.local'], [], function(resource) {
                // Ensure a simple share works as expected. It should add the new email (email2) and
                // not demote the existing email (email1)
                fns.shareSucceeds(userSharer.restContext, userSharer.restContext, resource.id, [user0.user.id, 'email1@oae.local', 'email2@oae.local', user1.user.id], function() {
                    return callback();
                });
            });
        });
    };

    var _testInvitationsValidationForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);
            fns.createSucceeds(user0.restContext, 'public', [], [], function(resource) {
                // Ensure cannot share with a variation of an email address
                fns.shareFails(user0.restContext, user0.restContext, resource.id, ['email1@oae'], 400, function() {
                    // Sanity check share succeeds
                    fns.shareSucceeds(user0.restContext, user0.restContext, resource.id, ['email1@oae.local'], function() {
                        return callback();
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {
            _testInvitationsAuthorizationForPublicShare(fns, publicTenant0, publicTenant1, privateTenant0, function() {
                _testInvitationsAuthorizationForLoggedinShare(fns, publicTenant0, publicTenant1, privateTenant0, function() {
                    _testInvitationsAuthorizationForPrivateShare(fns, publicTenant0, publicTenant1, privateTenant0, callback);
                });
            });
        });
    };

    var _testInvitationsAuthorizationForPublicShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create public resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'public', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail0@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can invite users from all tenants except private
                            fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                                fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                                    fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail1@defaultstoguest.local'], function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForLoggedinShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create loggedin resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'loggedin', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail0@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can invite users from only their own tenant
                            fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                                fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], 401, function() {
                                    fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail1@defaultstoguest.local'], 401, function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForPrivateShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create private resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'private', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can't invite anyone into a private item
                            fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], 401, function() {
                                fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], 401, function() {
                                    fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail@defaultstoguest.local'], 401, function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsForSetRoles = function(resourceType, memberRole, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, userSetRoles, user0, user1) {
            assert.ok(!err);
            fns.createSucceeds(userSetRoles.restContext, 'public', ['email1@oae.local'], [], function(resource) {

                // Ensure a simple set roles works as expected. email1 should be demoted to the
                // member role, and email2 should be added as a manager
                var roles = {};
                roles[user0.user.id] = 'manager';
                roles[user1.user.id] = memberRole;
                roles['email1@oae.local'] = memberRole;
                roles['email2@oae.local'] = 'manager';

                // Set the roles for both members and invitations
                fns.setRolesSucceeds(userSetRoles.restContext, userSetRoles.restContext, resource.id, roles, function() {

                    // Now remove them all, ensuring the states are updated appropriately
                    var rolesRemove = AuthzTestUtil.createRoleChange(_.keys(roles), false);
                    fns.setRolesSucceeds(userSetRoles.restContext, userSetRoles.restContext, resource.id, rolesRemove, function() {
                        return callback();
                    });
                });
            });
        });
    };

    var _testInvitationsValidationForSetRoles = function(resourceType, memberRole, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);
            fns.createSucceeds(user0.restContext, 'public', [], [], function(resource) {

                // Ensure invalid email is rejected
                fns.setRolesFails(user0.restContext, user0.restContext, resource.id, {'email1@oae': 'manager'}, 400, function() {
                    // Ensure invalid role for email is rejected
                    fns.setRolesFails(user0.restContext, user0.restContext, resource.id, {'email1@oae.local': 'invalidrole'}, 400, function() {
                        // Sanity check we can set roles with a valid role
                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, {'email1@oae.local': 'manager'}, function() {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForSetRoles = function(resourceType, memberRole, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {
            var managerUser = publicTenant0.publicUser;
            var viewerUser = publicTenant0.loggedinUser;

            // Create public resource with a viewer
            fns.createSucceeds(managerUser.restContext, 'public', [], [viewerUser.user.id], function(resource) {

                // Ensure viewer cannot invite VIA set roles
                fns.setRolesFails(managerUser.restContext, viewerUser.restContext, resource.id, {'email1@oae.local': memberRole}, 401, function() {
                    var rolesSameTenant = {};
                    var rolesExternalPublicTenant = {};
                    var rolesGuestTenant = {'email1@oae.local': memberRole};
                    var rolesExternalPrivateTenant = {};

                    rolesSameTenant[_emailForTenantInfo(publicTenant0)] = memberRole;
                    rolesExternalPublicTenant[_emailForTenantInfo(publicTenant1)] = memberRole;
                    rolesExternalPrivateTenant[_emailForTenantInfo(privateTenant0)] = memberRole;

                    // Ensure manager can set invitation roles for all emails they can interact with
                    fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesSameTenant, function() {
                        fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesExternalPublicTenant, function() {
                            fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesGuestTenant, function() {
                                fns.setRolesFails(managerUser.restContext, managerUser.restContext, resource.id, rolesExternalPrivateTenant, 401, function() {
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _assertAcceptEmailInvitation = function(invitingUser, acceptingUser, resources, assertions, callback) {
        // Receive the email invitation, ensuring we only have 1
        EmailTestUtil.collectAndFetchAllEmails(function(messages) {
            assert.strictEqual(_.size(messages), 1);

            var message = _.first(messages);

            // Ensure the subject contains the display name of the sender
            assert.notEqual(message.subject.indexOf(invitingUser.user.displayName), -1);

            // Ensure all resource profile paths are contained in the email, and that at least one
            // resource display name appears in the subject
            var hasOne = false;
            _.each(resources, function(resource) {
                 assert.notEqual(message.html.indexOf(resource.profilePath), -1);
                 if (message.subject.indexOf(resource.displayName)) {
                    hasOne = true;
                 }
            });
            assert.ok(hasOne);

            // Ensure the token in the email is functional
            var token = AuthzTestUtil.parseInvitationUrlFromMessage(message).query.invitationToken;
            AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUser.restContext, token, function() {
                // Ensure the user has the specified role on all the resources
                var _done = _.chain(resources).size().after(callback).value();
                _assertRole(invitingUser, acceptingUser, resources, assertions, function() {
                    return callback();
                });
            });
        });
    };

    var _assertRole = function(managerUserInfo, memberUserInfo, resources, opts, callback) {
        opts = opts || {};
        if (!_.isArray(resources)) {
            return _assertRole(managerUserInfo, memberUserInfo, [resources], opts, callback);
        } else if (_.isEmpty(resources)) {
            return callback();
        }

        resources = resources.slice();
        var resource = resources.shift();
        var fns = resourceFns[resource.resourceType];
        fns.getMembersSucceeds(managerUserInfo.restContext, resource.id, function(members) {
            if (_.isNumber(opts.membersSize)) {
                assert.strictEqual(members.length, opts.membersSize);
            }

            var memberInfo = _.find(members, function(memberInfo) {
                return (memberInfo.profile.id === memberUserInfo.user.id);
            });

            if (opts.role) {
                assert.ok(memberInfo);
                assert.strictEqual(memberInfo.role, opts.role);
            } else {
                assert.ok(!memberInfo);
            }

            fns.getLibrarySucceeds(memberUserInfo.restContext, memberUserInfo.user.id, function(libraryItems) {
                if (_.isNumber(opts.librarySize)) {
                    assert.strictEqual(libraryItems.length, opts.librarySize);
                }

                var resourceItem = _.findWhere(libraryItems, {'id': resource.id});
                if (opts.role) {
                    assert.ok(resourceItem);
                } else {
                    assert.ok(!resourceItem);
                }

                return _assertRole(managerUserInfo, memberUserInfo, resources, opts, callback);
            });
        });
    };

    var _emailForTenantInfo = function(tenantInfo, username) {
        return _emailForTenant(tenantInfo.tenant, username);
    };

    var _emailForTenant = function(tenant, username) {
        return _emailForDomain(tenant.emailDomain, username);
    };

    var _emailForDomain = function(host, username) {
        return util.format('%s@%s', username || TestsUtil.generateTestUserId(), host);
    };
});
