/*
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var assert = require('assert');
var util = require('util');

var ActivityTestUtil = require('oae-activity/lib/test/util');
var ContentTestUtil = require('oae-content/lib/test/util');
var DiscussionsTestUtil = require('oae-discussions/lib/test/util');
var EmailTestUtil = require('oae-email/lib/test/util');
var FoldersTestUtil = require('oae-folders/lib/test/util');
var PrincipalsTestUtil = require('oae-principals/lib/test/util');
var RestAPI = require('oae-rest');
var RestContext = require('oae-rest/lib/model').RestContext;
var SearchTestUtil = require('oae-search/lib/test/util');
var TenantsAPI  = require('oae-tenants');
var TenantsTestUtil = require('oae-tenants/lib/test/util');
var TestsUtil = require('oae-tests');

var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var AuthzTestUtil = require('oae-authz/lib/test/util');
var AuthzUtil = require('oae-authz/lib/util');

describe('Invitations', function() {

    // Initialize some rest contexts for anonymous and admin users
    var anonymousRestContext = null;
    var camAdminRestContext = null;
    var gtAdminRestContext = null;
    var globalAdminRestContext = null;

    var randomString = TestsUtil.generateRandomText(1);

    var resourceFns = {
        'content': {
            'createSucceeds': _.partial(ContentTestUtil.assertCreateLinkSucceeds, _, randomString, randomString, _, 'http://oae.local', _, _, [], _),
            'createFails': _.partial(ContentTestUtil.assertCreateLinkFails, _, randomString, randomString, _, 'http://oae.local', _, _, [], _, _),
            'shareSucceeds': ContentTestUtil.assertShareContentSucceeds,
            'shareFails': ContentTestUtil.assertShareContentFails,
            'setRolesSucceeds': ContentTestUtil.assertUpdateContentMembersSucceeds,
            'setRolesFails': ContentTestUtil.assertUpdateContentMembersFails,
            'getMembersSucceeds': _.partial(ContentTestUtil.getAllContentMembers, _, _, null, _),
            'getLibrarySucceeds': _.partial(ContentTestUtil.assertGetAllContentLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': function(adminRestContext, deleterRestContext, contentId, callback) {
                ContentTestUtil.assertDeleteContentSucceeds(deleterRestContext, contentId, callback);
            }
        },
        'discussion': {
            'createSucceeds': _.partial(DiscussionsTestUtil.assertCreateDiscussionSucceeds, _, randomString, randomString, _, _, _, _),
            'createFails': _.partial(DiscussionsTestUtil.assertCreateDiscussionFails, _, randomString, randomString, _, _, _, _, _),
            'shareSucceeds': DiscussionsTestUtil.assertShareDiscussionSucceeds,
            'shareFails': DiscussionsTestUtil.assertShareDiscussionFails,
            'setRolesSucceeds': DiscussionsTestUtil.assertUpdateDiscussionMembersSucceeds,
            'setRolesFails': DiscussionsTestUtil.assertUpdateDiscussionMembersFails,
            'getMembersSucceeds': _.partial(DiscussionsTestUtil.getAllDiscussionMembers, _, _, null, _),
            'getLibrarySucceeds': _.partial(DiscussionsTestUtil.assertGetAllDiscussionsLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': function(adminRestContext, deleterRestContext, discussionId, callback) {
                DiscussionsTestUtil.assertDeleteDiscussionSucceeds(deleterRestContext, discussionId, callback);
            }
        },
        'folder': {
            'createSucceeds': _.partial(FoldersTestUtil.assertCreateFolderSucceeds, _, randomString, randomString, _, _, _, _),
            'createFails': _.partial(FoldersTestUtil.assertCreateFolderFails, _, randomString, randomString, _, _, _, _, _),
            'shareSucceeds': FoldersTestUtil.assertShareFolderSucceeds,
            'shareFails': FoldersTestUtil.assertShareFolderFails,
            'setRolesSucceeds': FoldersTestUtil.assertUpdateFolderMembersSucceeds,
            'setRolesFails': FoldersTestUtil.assertUpdateFolderMembersFails,
            'getMembersSucceeds': _.partial(FoldersTestUtil.assertGetAllFolderMembersSucceeds, _, _, null, _),
            'getLibrarySucceeds': _.partial(FoldersTestUtil.assertGetAllFoldersLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': function(adminRestContext, deleterRestContext, folderId, callback) {
                FoldersTestUtil.assertDeleteFolderSucceeds(deleterRestContext, folderId, true, callback);
            }
        },
        'group': {
            'createSucceeds': _.partial(PrincipalsTestUtil.assertCreateGroupSucceeds, _, randomString, randomString, _, 'no', _, _, _),
            'createFails': _.partial(PrincipalsTestUtil.assertCreateGroupFails, _, randomString, randomString, _, 'no', _, _, _, _),
            'setRolesSucceeds': PrincipalsTestUtil.assertSetGroupMembersSucceeds,
            'setRolesFails': PrincipalsTestUtil.assertSetGroupMembersFails,
            'getMembersSucceeds': _.partial(PrincipalsTestUtil.assertGetAllMembersLibrarySucceeds, _, _, null, _),
            'getLibrarySucceeds': _.partial(PrincipalsTestUtil.assertGetAllMembershipsLibrarySucceeds, _, _, null, _),
            'deleteSucceeds': PrincipalsTestUtil.assertDeleteGroupSucceeds,
            'restoreSucceeds': PrincipalsTestUtil.assertRestoreGroupSucceeds
        }
    };

    var resourceMemberRoles = {
        'content': 'viewer',
        'discussion': 'member',
        'folder': 'viewer',
        'group': 'member'
    };

    var resourceAcceptActivityInfo = {
        'content': {
            'activityType': 'content-share',
            'verb': 'share'
        },
        'discussion': {
            'activityType': 'discussion-share',
            'verb': 'share'
        },
        'folder': {
            'activityType': 'folder-share',
            'verb': 'share'
        },
        'group': {
            'activityType': 'group-add-member',
            'verb': 'add'
        },
    };

    var resourceLibraryInfo = {
        'content': 'content-library',
        'discussion': 'discussion-library',
        'folder': 'folder-library',
        'group': 'memberships-library'
    };

    before(function(callback) {
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();
        return callback();
    });

    describe('Create', function() {

        describe('Content', function() {

            it('verify creating content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('content', callback);
            });

            it('verify validation of creating content with invitations', function(callback) {
                return _testInvitationsValidationForCreate('content', callback);
            });

            it('verify authorization of creating content with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify creating discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('discussion', callback);
            });

            it('verify validation of creating discussion with invitations', function(callback) {
                return _testInvitationsValidationForCreate('discussion', callback);
            });

            it('verify authorization of creating discussion with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify creating folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('folder', callback);
            });

            it('verify validation of creating folder with invitations', function(callback) {
                return _testInvitationsValidationForCreate('folder', callback);
            });

            it('verify authorization of creating folder with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('folder', callback);
            });
        });

        describe('Group', function() {

            it('verify creating group with members and invitations saves invitations', function(callback) {
                return _testInvitationsForCreate('group', callback);
            });

            it('verify validation of creating group with invitations', function(callback) {
                return _testInvitationsValidationForCreate('group', callback);
            });

            it('verify authorization of creating group with invitations', function(callback) {
                return _testInvitationsAuthorizationForCreate('group', callback);
            });
        });
    });

    describe('Share', function() {

        describe('Content', function() {

            it('verify sharing content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('content', callback);
            });

            it('verify validation of content share with invitations', function(callback) {
                return _testInvitationsValidationForShare('content', callback);
            });

            it('verify authorization of content share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify sharing discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('discussion', callback);
            });

            it('verify validation of discussion share with invitations', function(callback) {
                return _testInvitationsValidationForShare('discussion', callback);
            });

            it('verify authorization of discussion share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify sharing folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForShare('folder', callback);
            });

            it('verify validation of folder share with invitations', function(callback) {
                return _testInvitationsValidationForShare('folder', callback);
            });

            it('verify authorization of folder share with invitations', function(callback) {
                return _testInvitationsAuthorizationForShare('folder', callback);
            });
        });
    });

    describe('Set Roles', function() {

        describe('Content', function() {

            it('verify setting roles of content with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('content', callback);
            });

            it('verify validation of setting roles of content with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('content', callback);
            });

            it('verify authorization of setting roles of content with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify setting roles of discussion with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('discussion', callback);
            });

            it('verify validation of setting roles of discussion with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('discussion', callback);
            });

            it('verify authorization of setting roles of discussion with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify setting roles of folder with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('folder', callback);
            });

            it('verify validation of setting roles of folder with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('folder', callback);
            });

            it('verify authorization of setting roles of folder with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('folder', callback);
            });
        });

        describe('Group', function() {

            it('verify setting roles of group with members and invitations saves invitations', function(callback) {
                return _testInvitationsForSetRoles('group', callback);
            });

            it('verify validation of setting roles of group with invitations', function(callback) {
                return _testInvitationsValidationForSetRoles('group', callback);
            });

            it('verify authorization of setting roles of group with invitations', function(callback) {
                return _testInvitationsAuthorizationForSetRoles('group', callback);
            });
        });
    });

    describe('Accept', function() {

        describe('Content', function() {

            it('verify accepting an invitation with content', function(callback) {
                _testInvitationAccept('content', callback);
            });

            it('verify validation of accepting an invitation with content', function(callback) {
                _testInvitationAcceptValidation('content', callback);
            });

            it('verify authorization of accepting an invitation with content', function(callback) {
                _testInvitationAcceptAuthorization('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify accepting an invitation with discussions', function(callback) {
                _testInvitationAccept('discussion', callback);
            });

            it('verify validation of accepting an invitation with discussions', function(callback) {
                _testInvitationAcceptValidation('discussion', callback);
            });

            it('verify authorization of accepting an invitation with discussions', function(callback) {
                _testInvitationAcceptAuthorization('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify accepting an invitation with folders', function(callback) {
                _testInvitationAccept('folder', callback);
            });

            it('verify validation of accepting an invitation with folders', function(callback) {
                _testInvitationAcceptValidation('folder', callback);
            });

            it('verify authorization of accepting an invitation with folders', function(callback) {
                _testInvitationAcceptAuthorization('folder', callback);
            });
        });

        describe('Group', function() {

            it('verify accepting an invitation with groups', function(callback) {
                _testInvitationAccept('group', callback);
            });

            it('verify validation of accepting an invitation with groups', function(callback) {
                _testInvitationAcceptValidation('group', callback);
            });

            it('verify authorization of accepting an invitation with groups', function(callback) {
                _testInvitationAcceptAuthorization('group', callback);
            });
        });
    });

    describe('Email', function() {

        it('verify email invitation links to the proper tenant based on email domain', function(callback) {
            var fns = resourceFns.content;
            TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user) {
                assert.ok(!err);

                var cambridgeEmail = _emailForTenant(global.oaeTests.tenants.cam);
                var guestEmail = _emailForDomain(TenantsTestUtil.generateTestTenantHost());
                EmailTestUtil.collectAndFetchAllEmails(function() {

                    fns.createSucceeds(user.restContext, 'public', [cambridgeEmail], [guestEmail], function(resource) {

                        EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                            // There should be 2 emails, one for cambridgeEmail and one for guestEmail
                            assert.strictEqual(messages.length, 2);

                            var cambridgeMessage = _.find(messages, function(message) {
                                return (message.headers.to === cambridgeEmail);
                            });

                            var guestMessage = _.find(messages, function(message) {
                                return (message.headers.to === guestEmail);
                            });

                            // Grab the invitation link from the messages
                            var cambridgeInvitationUrl = AuthzTestUtil.parseInvitationUrlFromMessage(cambridgeMessage);
                            var guestInvitationUrl = AuthzTestUtil.parseInvitationUrlFromMessage(guestMessage);

                            // Ensure the links are to the proper tenancy
                            assert.strictEqual(cambridgeInvitationUrl.host, global.oaeTests.tenants.cam.host);
                            assert.strictEqual(guestInvitationUrl.host, TenantsAPI.getTenant('guest').host);

                            return callback();
                        });
                    });
                });
            });
        });

        it('verify it sends an aggregated email for all resource types', function(callback) {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
                assert.ok(!err);

                // Generate the email to invite and ensure we start with an empty email queue
                var email = _emailForTenant(global.oaeTests.tenants.cam);
                EmailTestUtil.collectAndFetchAllEmails(function() {

                    // Create one of each resource type with the creating user
                    _createOneOfEachResourceType(creatingUser, 'public', [email], [], function(resources) {

                        // Ensure when the invitation is accepted from the email, all resources are
                        // added to the user's respective libraries
                        var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                        _assertAcceptEmailInvitation(creatingUser, acceptingUser, resources, assertions, function() {
                            return callback();
                        });
                    });
                });
            });
        });

        describe('Content', function() {

            it('verify it sends an aggregated invitation for content of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('content', callback);
            });

            it('verify it sends an aggregated invitation for content of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('content', callback);
            });

            it('verify it sends an aggregated invitation for content of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('content', callback);
            });
        });

        describe('Discussion', function() {

            it('verify it sends an aggregated invitation for discussions of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('discussion', callback);
            });

            it('verify it sends an aggregated invitation for discussions of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('discussion', callback);
            });

            it('verify it sends an aggregated invitation for discussions of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('discussion', callback);
            });
        });

        describe('Folder', function() {

            it('verify it sends an aggregated invitation for folders of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('folder', callback);
            });

            it('verify it sends an aggregated invitation for folders of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('folder', callback);
            });

            it('verify it sends an aggregated invitation for folders of all visibilities on share', function(callback) {
                _testInvitationEmailVisibilityForShare('folder', callback);
            });
        });

        describe('Group', function() {

            it('verify it sends an aggregated invitation for groups of all visibilities on create', function(callback) {
                _testInvitationEmailVisibilityForCreate('group', callback);
            });

            it('verify it sends an aggregated invitation for groups of all visibilities on set roles', function(callback) {
                _testInvitationEmailVisibilityForSetRoles('group', callback);
            });
        });
    });

    describe('Activity', function() {

        it('verify activity for all resource types and visibilities when an invitation is accepted', function(callback) {
            _testActivityVisibilityForAccept('public', function() {
                _testActivityVisibilityForAccept('loggedin', function() {
                    return _testActivityVisibilityForAccept('private', callback);
                });
            });
        });
    });

    describe('Delete', function() {

        describe('Content', function() {

            it('verify content that gets deleted simply gets removed from invitations', function(callback) {
                _testHardDeleteForAccept('content', function() {
                    return callback();
                });
            });
        });

        describe('Discussion', function() {

            it('verify discussion that gets deleted simply gets removed from invitations', function(callback) {
                _testHardDeleteForAccept('discussion', function() {
                    return callback();
                });
            });
        });

        describe('Folder', function() {

            it('verify folder that gets deleted simply gets removed from invitations', function(callback) {
                _testHardDeleteForAccept('folder', function() {
                    return callback();
                });
            });
        });

        describe('Group', function() {

            it('verify deleted group does not get added with invitation, but restoring adds it', function(callback) {
                _testSoftDeleteForAccept('group', callback);
            });
        })
    });

    var _testSoftDeleteForAccept = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        _testHardDeleteForAccept(resourceType, function(creatingUserInfo, acceptingUserInfo, resource) {
            fns.restoreSucceeds(camAdminRestContext, camAdminRestContext, resource.id, function() {

                // Ensure that when the item is restored, the user becomes a member
                var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                _assertRole(creatingUserInfo, acceptingUserInfo, resource, assertions, function() {
                    return callback();
                });
            });
        });
    };

    var _testHardDeleteForAccept = function(resourceType, callback) {
        var fns = resourceFns[resourceType];

        // Create a resource with an email invited into it
        var email = _emailForTenant(global.oaeTests.tenants.cam);
        EmailTestUtil.collectAndFetchAllEmails(function() {
            TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUserInfo, acceptingUserInfo) {
                assert.ok(!err);

                // Create the resource, sending an invite to the target user
                fns.createSucceeds(creatingUserInfo.restContext, 'public', [email], [], function(resource) {
                    EmailTestUtil.collectAndFetchAllEmails(function(messages) {
                        assert.strictEqual(messages.length, 1);

                        var message = _.first(messages);
                        var token = AuthzTestUtil.parseInvitationUrlFromMessage(message).query.invitationToken;

                        // Delete the resource before we have a chance to accept
                        fns.deleteSucceeds(camAdminRestContext, creatingUserInfo.restContext, resource.id, function() {

                            // Now accept the invitation, ensuring no resources are reported as being
                            // added
                            AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUserInfo.restContext, token, function(result) {
                                assert.strictEqual(result.email, email);
                                assert.strictEqual(result.resources.length, 0);

                                // Ensure nothing went into the user's library
                                fns.getLibrarySucceeds(acceptingUserInfo.restContext, acceptingUserInfo.user.id, function(libraryItems) {
                                    assert.strictEqual(libraryItems.length, 0);
                                    return callback(creatingUserInfo, acceptingUserInfo, resource);
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testActivityVisibilityForAccept = function(visibility, callback) {
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUserInfo, acceptingUserInfo) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {
                _createOneOfEachResourceType(creatingUserInfo, visibility, [email], [], function(resources) {
                    var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                    _assertAcceptEmailInvitation(creatingUserInfo, acceptingUserInfo, resources, assertions, function() {

                        ActivityTestUtil.collectAndGetActivityStream(acceptingUserInfo.restContext, acceptingUserInfo.user.id, null, function(err, result) {
                            assert.ok(!err);

                            var activities = result.items;

                            // One activity for each resource type
                            assert.strictEqual(activities.length, _.size(resourceAcceptActivityInfo));
                            _.each(resources, function(resource) {
                                var activityInfo = resourceAcceptActivityInfo[resource.resourceType];
                                var matchingActivities = null;
                                if (activityInfo.verb === 'add') {
                                    // For an "add" activity, the user added is the object and
                                    // the resource is the target
                                    matchingActivities = _.filter(activities, function(activity) {
                                        return (
                                            activity['oae:activityType'] === activityInfo.activityType &&
                                            activity.verb === activityInfo.verb &&
                                            activity.actor['oae:id'] === creatingUserInfo.user.id &&
                                            activity.object['oae:id'] === acceptingUserInfo.user.id &&
                                            activity.target['oae:id'] === resource.id
                                        );
                                    });
                                } else if (activityInfo.verb === 'share') {
                                    // For a "share" activity, the resource shared is the object
                                    // and the user is the target
                                    matchingActivities = _.filter(activities, function(activity) {
                                        return (
                                            activity['oae:activityType'] === activityInfo.activityType &&
                                            activity.verb === activityInfo.verb &&
                                            activity.actor['oae:id'] === creatingUserInfo.user.id &&
                                            activity.object['oae:id'] === resource.id &&
                                            activity.target['oae:id'] === acceptingUserInfo.user.id
                                        );
                                    });
                                } else {
                                    assert.fail('Unexpected verb in the resource type list');
                                }

                                assert.ok(matchingActivities);
                                assert.strictEqual(matchingActivities.length, 1);
                            });

                            return callback();
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailVisibilityForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {

                fns.createSucceeds(creatingUser.restContext, 'public', [email], [], function(resource1) {
                    fns.createSucceeds(creatingUser.restContext, 'loggedin', [email], [], function(resource2) {
                        fns.createSucceeds(creatingUser.restContext, 'private', [email], [], function(resource3) {
                            var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                            _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailVisibilityForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {

                // Create a resource of each visibility
                fns.createSucceeds(creatingUser.restContext, 'public', [], [], function(resource1) {
                    fns.createSucceeds(creatingUser.restContext, 'loggedin', [], [], function(resource2) {
                        fns.createSucceeds(creatingUser.restContext, 'private', [], [], function(resource3) {
                            var roleChange = _.object([[email, 'manager']]);

                            // Set the accepting user as a manager on all 3 using set roles
                            fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource1.id, roleChange, function() {
                                fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource2.id, roleChange, function() {
                                    fns.setRolesSucceeds(creatingUser.restContext, creatingUser.restContext, resource3.id, roleChange, function() {

                                        // Ensure the user can accept the email invitation
                                        var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 3};
                                        _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationEmailVisibilityForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 2, function(err, users, creatingUser, acceptingUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);
            EmailTestUtil.collectAndFetchAllEmails(function() {

                // Create a resource of each visibility
                fns.createSucceeds(creatingUser.restContext, 'public', [], [], function(resource1) {
                    fns.createSucceeds(creatingUser.restContext, 'loggedin', [], [], function(resource2) {
                        fns.createSucceeds(creatingUser.restContext, 'private', [], [], function(resource3) {

                            // Share with each resource
                            fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource1.id, [email], function() {
                                fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource2.id, [email], function() {
                                    fns.shareSucceeds(creatingUser.restContext, creatingUser.restContext, resource3.id, [email], function() {
                                        var assertions = {'role': memberRole, 'membersSize': 2, 'librarySize': 3};
                                        // Ensure the user can accept the email invitation
                                        _assertAcceptEmailInvitation(creatingUser, acceptingUser, [resource1, resource2, resource3], assertions, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAccept = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, userManager, userViewer) {
            assert.ok(!err);

            var managerEmail = _emailForTenant(global.oaeTests.tenants.cam);
            var viewerEmail = _emailForTenant(global.oaeTests.tenants.cam);

            // Create a resource. 2 separate invitations will go out
            fns.createSucceeds(user0.restContext, 'public', [managerEmail], [viewerEmail], function(resource) {
                var resourceAuthzId = AuthzUtil.getAuthzId(resource);

                // Accept the manager invitation and ensure they show up in the members
                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(userManager.restContext, managerEmail, function(result, invitations) {
                    assert.strictEqual(invitations.length, 1);

                    var invitation = _.first(invitations);
                    assert.strictEqual(invitation.resourceId, resourceAuthzId);
                    assert.strictEqual(invitation.email, managerEmail);
                    assert.strictEqual(invitation.inviterUserId, user0.user.id);
                    assert.strictEqual(invitation.role, 'manager');

                    var assertions = {'role': 'manager', 'membersSize': 2, 'librarySize': 1};
                    _assertRole(user0, userManager, resource, assertions, function() {
                        // Accept the viewer invitation and ensure they show up in the members
                        AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(userViewer.restContext, viewerEmail, function(result, invitations) {
                            assert.strictEqual(invitations.length, 1);

                            var invitation = _.first(invitations);
                            assert.strictEqual(invitation.resourceId, resourceAuthzId);
                            assert.strictEqual(invitation.email, viewerEmail);
                            assert.strictEqual(invitation.inviterUserId, user0.user.id);
                            assert.strictEqual(invitation.role, memberRole);

                            assertions = {'role': memberRole, 'membersSize': 3, 'librarySize': 1};
                            _assertRole(user0, userViewer, resource, assertions, function() {
                                return callback();
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAcceptAuthorization = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 6, function(err, users, user0, user1, user2, user3, user4, user5) {
            assert.ok(!err);

            var email1 = _emailForTenant(global.oaeTests.tenants.cam);
            var email2 = _emailForTenant(global.oaeTests.tenants.cam);
            var email3 = _emailForTenant(global.oaeTests.tenants.cam);
            var email4 = _emailForTenant(global.oaeTests.tenants.cam);
            var email5 = _emailForTenant(global.oaeTests.tenants.cam);

            fns.createSucceeds(user0.restContext, 'private', [email1], [], function(resource) {

                // Accept as user1
                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user1.restContext, email1, function() {

                    // Ensure user1 can now set roles since they should be manager
                    var roles = {};
                    roles[email2] = 'manager';
                    roles[email3] = memberRole;
                    roles[email4] = memberRole;
                    roles[email5] = memberRole;
                    fns.setRolesSucceeds(user0.restContext, user1.restContext, resource.id, roles, function() {

                        // Remove the user who invited email2 and ensure email2 invitation can still be accepted
                        roles = {};
                        roles[user1.user.id] = false;
                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, roles, function() {

                            // Ensure email2 can still be accepted and makes user2 a manager
                            AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user2.restContext, email2, function() {
                                _assertRole(user0, user2, resource, {'role': 'manager'}, function() {

                                    // Accept the "member" role invitation for email3 as user2, ensuring their role
                                    // on the resource does not get demoted to the "member" role
                                    AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user2.restContext, email3, function() {
                                        _assertRole(user0, user2, resource, {'role': 'manager'}, function() {

                                            // Delete user1 from the system, and ensure the user they
                                            // invited can still accept their invitation
                                            PrincipalsTestUtil.assertDeleteUserSucceeds(camAdminRestContext, camAdminRestContext, user1.user.id, function() {

                                                // Accept the invitation for email4 and ensure it succeeds despite the fact that
                                                // the user that invited them was deleted
                                                AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user4.restContext, email4, function() {
                                                    _assertRole(user0, user4, resource, {'role': memberRole}, function() {

                                                        // Remove the invitation for email5, ensuring an invitation for email5 can still
                                                        // be accepted, but it doesn't grant any access to the resource
                                                        roles = {};
                                                        roles[email5] = false;
                                                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, roles, function() {
                                                            AuthzTestUtil.assertAcceptInvitationForEmailSucceeds(user5.restContext, email5, function() {
                                                                _assertRole(user0, user5, resource, {'role': false}, function() {
                                                                    return callback();
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationAcceptValidation = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, acceptingUser, sneakyUser) {
            assert.ok(!err);

            var email = _emailForTenant(global.oaeTests.tenants.cam);

            // Token is required
            AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, null, 400, function() {
                // Token must exist
                AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, 'nonexistingtoken', 404, function() {

                    // Create a resource with an invitation
                    fns.createSucceeds(user0.restContext, 'public', [email], [], function(resource) {
                        AuthzInvitationsDAO.getTokensByEmails([email], function(err, tokensByEmail) {
                            assert.ok(!err);

                            var token = tokensByEmail[email];

                            // User must be logged in to accept
                            AuthzTestUtil.assertAcceptInvitationFails(anonymousRestContext, token, 401, function() {

                                // Sanity check we can accept with this token as authenticated user
                                AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUser.restContext, token, function() {

                                    // Ensure re-accepting this token as a sneaky user that intercepted it fails
                                    AuthzTestUtil.assertAcceptInvitationFails(sneakyUser.restContext, token, 404, function() {

                                        // Ensure the accepting user became a manager of the resource
                                        _assertRole(user0, acceptingUser, resource, {'role': 'manager'}, function() {

                                            // Ensure the sneaky user does not have the resource
                                            _assertRole(user0, sneakyUser, resource, {'role': false, 'membersSize': 2}, function() {
                                                return callback();
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, user0, userManager, userViewer) {
            assert.ok(!err);

            // Ensure a simple create mixed with a couple member users succeeds
            fns.createSucceeds(user0.restContext, 'public', ['manager@oae.local', userManager.user.id], [userViewer.user.id, 'viewer@oae.local'], function(resource) {
                return callback();
            });
        });
    };

    var _testInvitationsValidationForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);

            // Ensure variations of email addresses fail
            fns.createFails(user0.restContext, 'public', ['invalid@email'], [], 400, function(resource) {

                // Sanity check can be created with valid email
                fns.createSucceeds(user0.restContext, 'public', ['manager@oae.local'], [], function(resource) {
                    return callback();
                });
            });
        });
    };

    var _testInvitationsAuthorizationForCreate = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {

            // Ensure cannot create content associated to an email from a private tenant
            fns.createFails(privateTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(publicTenant0)], [], 401, function(resource) {
                // Ensure cannot create content associated to a private tenant
                fns.createFails(publicTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(privateTenant0)], [], 401, function(resource) {
                    // Sanity check we can create content on our own private tenant
                    fns.createSucceeds(privateTenant0.publicUser.restContext, 'public', [_emailForTenantInfo(privateTenant0)], [], function(resource) {
                        // Ensure a user can create a loggedin item and share it with an email of a user from another tenant
                        fns.createSucceeds(publicTenant0.publicUser.restContext, 'loggedin', [_emailForTenantInfo(publicTenant1)], [], function(resource) {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, userSharer, user0, user1) {
            assert.ok(!err);
            fns.createSucceeds(userSharer.restContext, 'public', ['email1@oae.local'], [], function(resource) {
                // Ensure a simple share works as expected. It should add the new email (email2) and
                // not demote the existing email (email1)
                fns.shareSucceeds(userSharer.restContext, userSharer.restContext, resource.id, [user0.user.id, 'email1@oae.local', 'email2@oae.local', user1.user.id], function() {
                    return callback();
                });
            });
        });
    };

    var _testInvitationsValidationForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);
            fns.createSucceeds(user0.restContext, 'public', [], [], function(resource) {
                // Ensure cannot share with a variation of an email address
                fns.shareFails(user0.restContext, user0.restContext, resource.id, ['email1@oae'], 400, function() {
                    // Sanity check share succeeds
                    fns.shareSucceeds(user0.restContext, user0.restContext, resource.id, ['email1@oae.local'], function() {
                        return callback();
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForShare = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {
            _testInvitationsAuthorizationForPublicShare(fns, publicTenant0, publicTenant1, privateTenant0, function() {
                _testInvitationsAuthorizationForLoggedinShare(fns, publicTenant0, publicTenant1, privateTenant0, function() {
                    _testInvitationsAuthorizationForPrivateShare(fns, publicTenant0, publicTenant1, privateTenant0, callback);
                });
            });
        });
    };

    var _testInvitationsAuthorizationForPublicShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create public resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'public', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail0@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can invite users from all tenants except private
                            fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                                fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                                    fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail1@defaultstoguest.local'], function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForLoggedinShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create loggedin resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'loggedin', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail0@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can invite users from only their own tenant
                            fns.shareSucceeds(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                                fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], 401, function() {
                                    fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail1@defaultstoguest.local'], 401, function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForPrivateShare = function(fns, publicTenant0, publicTenant1, privateTenant0, callback) {
        var managerUser = publicTenant0.publicUser;
        var viewerUser = publicTenant0.loggedinUser;
        // Create private resource with a viewer
        fns.createSucceeds(managerUser.restContext, 'private', [], [viewerUser.user.id], function(resource) {
            // Ensure manager user can invite users from all tenants except private
            fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], function() {
                fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], function() {
                    fns.shareSucceeds(managerUser.restContext, managerUser.restContext, resource.id, ['thisemail@defaultstoguest.local'], function() {
                        fns.shareFails(managerUser.restContext, managerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                            // Ensure viewer user can't invite anyone into a private item
                            fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant0)], 401, function() {
                                fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(publicTenant1)], 401, function() {
                                    fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, ['thisemail@defaultstoguest.local'], 401, function() {
                                        fns.shareFails(managerUser.restContext, viewerUser.restContext, resource.id, [_emailForTenantInfo(privateTenant0)], 401, function() {
                                            return callback();
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.generateTestUsers(camAdminRestContext, 3, function(err, users, userSetRoles, user0, user1) {
            assert.ok(!err);
            fns.createSucceeds(userSetRoles.restContext, 'public', ['email1@oae.local'], [], function(resource) {

                // Ensure a simple set roles works as expected. email1 should be demoted to the
                // member role, and email2 should be added as a manager
                var roles = {};
                roles[user0.user.id] = 'manager';
                roles[user1.user.id] = memberRole;
                roles['email1@oae.local'] = memberRole;
                roles['email2@oae.local'] = 'manager';

                // Set the roles for both members and invitations
                fns.setRolesSucceeds(userSetRoles.restContext, userSetRoles.restContext, resource.id, roles, function() {

                    // Now remove them all, ensuring the states are updated appropriately
                    var rolesRemove = AuthzTestUtil.createRoleChange(_.keys(roles), false);
                    fns.setRolesSucceeds(userSetRoles.restContext, userSetRoles.restContext, resource.id, rolesRemove, function() {
                        return callback();
                    });
                });
            });
        });
    };

    var _testInvitationsValidationForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        TestsUtil.generateTestUsers(camAdminRestContext, 1, function(err, users, user0) {
            assert.ok(!err);
            fns.createSucceeds(user0.restContext, 'public', [], [], function(resource) {

                // Ensure invalid email is rejected
                fns.setRolesFails(user0.restContext, user0.restContext, resource.id, {'email1@oae': 'manager'}, 400, function() {
                    // Ensure invalid role for email is rejected
                    fns.setRolesFails(user0.restContext, user0.restContext, resource.id, {'email1@oae.local': 'invalidrole'}, 400, function() {
                        // Sanity check we can set roles with a valid role
                        fns.setRolesSucceeds(user0.restContext, user0.restContext, resource.id, {'email1@oae.local': 'manager'}, function() {
                            return callback();
                        });
                    });
                });
            });
        });
    };

    var _testInvitationsAuthorizationForSetRoles = function(resourceType, callback) {
        var fns = resourceFns[resourceType];
        var memberRole = resourceMemberRoles[resourceType];

        TestsUtil.setupMultiTenantPrivacyEntities(function(publicTenant0, publicTenant1, privateTenant0) {
            var managerUser = publicTenant0.publicUser;
            var viewerUser = publicTenant0.loggedinUser;

            // Create public resource with a viewer
            fns.createSucceeds(managerUser.restContext, 'public', [], [viewerUser.user.id], function(resource) {

                // Ensure viewer cannot invite VIA set roles
                fns.setRolesFails(managerUser.restContext, viewerUser.restContext, resource.id, {'email1@oae.local': memberRole}, 401, function() {
                    var rolesSameTenant = {};
                    var rolesExternalPublicTenant = {};
                    var rolesGuestTenant = {'email1@oae.local': memberRole};
                    var rolesExternalPrivateTenant = {};

                    rolesSameTenant[_emailForTenantInfo(publicTenant0)] = memberRole;
                    rolesExternalPublicTenant[_emailForTenantInfo(publicTenant1)] = memberRole;
                    rolesExternalPrivateTenant[_emailForTenantInfo(privateTenant0)] = memberRole;

                    // Ensure manager can set invitation roles for all emails they can interact with
                    fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesSameTenant, function() {
                        fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesExternalPublicTenant, function() {
                            fns.setRolesSucceeds(managerUser.restContext, managerUser.restContext, resource.id, rolesGuestTenant, function() {
                                fns.setRolesFails(managerUser.restContext, managerUser.restContext, resource.id, rolesExternalPrivateTenant, 401, function() {
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    var _createOneOfEachResourceType = function(creatingUserInfo, visibility, managerIds, memberIds, callback) {
        // Create a resource of each known type, aggregating them into the `createResults`
        // object
        var resources = [];
        var _done = _.chain(resourceFns).size().after(function() {
            return callback(resources);
        }).value();

        // Perform all the creates and kick off the assertions on the created resources
        // and invitations
        PrincipalsTestUtil.assertGetMeSucceeds(creatingUserInfo.restContext, function(me) {
            _.each(resourceFns, function(fns) {
                fns.createSucceeds(creatingUserInfo.restContext, visibility, managerIds, memberIds, function(resource) {
                    resources.push(resource);
                    return _done();
                });
            });
        });
    };

    var _assertAcceptEmailInvitation = function(invitingUser, acceptingUser, resources, assertions, callback) {
        // Receive the email invitation, ensuring we only have 1
        EmailTestUtil.collectAndFetchAllEmails(function(messages) {
            assert.strictEqual(_.size(messages), 1);

            var message = _.first(messages);

            // Ensure the subject contains the display name of the sender
            assert.notEqual(message.subject.indexOf(invitingUser.user.displayName), -1);

            // Ensure all resource profile paths are contained in the email, and that at least one
            // resource display name appears in the subject
            var hasOne = false;
            _.each(resources, function(resource) {
                 assert.notEqual(message.html.indexOf(resource.profilePath), -1);
                 if (message.subject.indexOf(resource.displayName)) {
                    hasOne = true;
                 }
            });
            assert.ok(hasOne);

            // Ensure the token in the email is functional
            var token = AuthzTestUtil.parseInvitationUrlFromMessage(message).query.invitationToken;
            AuthzTestUtil.assertAcceptInvitationSucceeds(acceptingUser.restContext, token, function() {
                // Ensure the user has the specified role on all the resources
                var _done = _.chain(resources).size().after(callback).value();
                _assertRole(invitingUser, acceptingUser, resources, assertions, function() {
                    return callback();
                });
            });
        });
    };

    var _assertRole = function(managerUserInfo, memberUserInfo, resources, opts, callback) {
        opts = opts || {};
        if (!_.isArray(resources)) {
            return _assertRole(managerUserInfo, memberUserInfo, [resources], opts, callback);
        } else if (_.isEmpty(resources)) {
            return callback();
        }

        resources = resources.slice();
        var resource = resources.shift();
        var fns = resourceFns[resource.resourceType];

        // Ensure the members library feed has the user with the specified role
        fns.getMembersSucceeds(managerUserInfo.restContext, resource.id, function(members) {
            if (_.isNumber(opts.membersSize)) {
                assert.strictEqual(members.length, opts.membersSize);
            }

            var memberInfo = _.find(members, function(memberInfo) {
                return (memberInfo.profile.id === memberUserInfo.user.id);
            });

            if (opts.role) {
                assert.ok(memberInfo);
                assert.strictEqual(memberInfo.role, opts.role);
            } else {
                assert.ok(!memberInfo);
            }

            fns.getLibrarySucceeds(memberUserInfo.restContext, memberUserInfo.user.id, function(libraryItems) {
                if (_.isNumber(opts.librarySize)) {
                    assert.strictEqual(libraryItems.length, opts.librarySize);
                }

                var resourceItem = _.findWhere(libraryItems, {'id': resource.id});
                if (opts.role) {
                    assert.ok(resourceItem);
                } else {
                    assert.ok(!resourceItem);
                }

                // If we expect the user to have a role, we should ensure their respective resource
                // library has the item in it when searching. Otherwise, ensure it does not contain
                // the resource
                var searchAssertFn = (opts.role) ? SearchTestUtil.assertSearchContains :
                    SearchTestUtil.assertSearchNotContains;

                var libraryName = resourceLibraryInfo[resource.resourceType];
                searchAssertFn(memberUserInfo.restContext, libraryName, [memberUserInfo.user.id], null, [resource.id], function() {
                    return _assertRole(managerUserInfo, memberUserInfo, resources, opts, callback);
                });
            });
        });
    };

    var _emailForTenantInfo = function(tenantInfo, username) {
        return _emailForTenant(tenantInfo.tenant, username);
    };

    var _emailForTenant = function(tenant, username) {
        return _emailForDomain(tenant.emailDomain, username);
    };

    var _emailForDomain = function(host, username) {
        return util.format('%s@%s', username || TestsUtil.generateTestUserId(), host);
    };
});
