/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var Context = require('oae-context').Context;
var Validator = require('oae-util/lib/validator').Validator;
var Cassandra = require('oae-util/lib/cassandra');
var PrincipalUtil = require('oae-principals/lib/utils');
var RolesAPI = require('oae-roles');
var PermissionsAPI = require('oae-permissions');
var RolesUtil = require('oae-roles/lib/util');

var Content = require('./model').Content;
var ContentConstants = require('./model').Constants;


///////////////////////////////////
// Retrieving a piece of content //
///////////////////////////////////

/**
 * Get a content's basic profile information based on a pooled content id
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to retrieve
 * @param  {Function(err, contentObj)}  callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Content}                    callback.contentObj Retrieved content object
 */
var getContent = module.exports.getContent = function(ctx, contentId, callback) {
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'contentId': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Retrieve the piece of content from Cassandra
    Cassandra.runQuery('SELECT * FROM Content WHERE contentId = ?', [contentId], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        // Cassandra always returns the key as a column so the _colCount will always be 1.
        if (rows[0]._colCount === 1) {
            return callback({'code': 404, 'msg': "Couldn't find content: " + contentId}, null);
        }

        var contentObj = _rowToContent(rows[0]);
        _hasAccess(ctx, contentObj, function(err, hasAccess) {
            if (err) {
                return callback(err);
            }
            callback(null, contentObj);
        });
    });
};

/**
 * Internal function used to get multiple content basic profiles at the same time based on their content ids.
 * @param  {Array<String>}              contentIds          Array of content object ids we want to retrieve. 
 *                                                          The content profiles will be returned in the same order
 * @param  {Function(err, content)}     callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Array<Content>}             callback.contentObj Retrieved content objects
 */
var _getMultipleContentItems = function(contentIds, callback) {
    if (contentIds.length) {
        Cassandra.runQuery("SELECT * FROM Content WHERE contentId IN (?)", [contentIds], function(err, rows) {
            if (err) {
                return callback(err);
            }
            // Iterate over the content items.
            for (var i = 0; i < rows.rowCount(); i++) {
                var contentObj = _rowToContent(rows[i]);
                contentIds[_.indexOf(contentIds, contentObj.contentId)] = contentObj;
            }
            callback(null, contentIds);
        });
    } else {
        callback(null, []);
    }
};

/////////////////////////////////////
// Creating a new piece of content //
/////////////////////////////////////

/**
 * Create a new piece of pooled content
 * @param  {Context}                 ctx               Standard context object containing the current user and the current tenant
 * @param  {User}                    currentUser       The principal uuid of the user creating the content. This user will also be added as a 
 *                                                     manager of the content
 * @param  {String}                  visibility        The visibility setting for the piece of content. Possible values are "public", "loggedin" 
 *                                                     and "private" [optional]
 * @param  {String}                  title             The display title for the piece of content
 * @param  {String}                  description       The description of the piece of content [optional]
 * @param  {String}                  contentType       The content type. Possible values are "file", "sakaidoc" and "link"
 * @param  {Function(err, content)}  callback          Standard callback function
 * @param  {Object}                  callback.err      Error object containing the error message
 * @param  {Object}                  callback.content  JSON object containing the pool id of the created content
 */
var createContent = module.exports.createContent = function(ctx, visibility, title, description, contentType, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(title, {'code': 400, 'msg': 'A tenant must be provided'}).notEmpty();
    validator.check(title, {'code': 400, 'msg': 'A content title must be provided'}).notEmpty();
    validator.check(contentType, {'code': 400, 'msg': 'A content type must be provided. This can be "file", "sakaidoc" or "link"'}).notEmpty();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a content item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Setting content to public if no privacy setting is provided
    visibility = visibility || ContentConstants.permissions.PUBLIC;

    // Generate the content id
    var contentId = RolesUtil.toUuid('c', ctx.tenant().alias, ShortId.generate());
    var lastModified = new Date().getTime();
    description = description || '';

    // Create the content
    Cassandra.runQuery('INSERT INTO Content (contentId, tenant, visibility, title, description, contentType, lastModified) VALUES (?, ?, ?, ?, ?, ?, ?)', [contentId, ctx.tenant().alias, visibility, title, description, contentType, lastModified], function (err) {
        if (err) {
            callback({'code': 500, 'msg': err});
        } else {
            var contentObj = new Content(ctx.tenant().alias, contentId, visibility, title, description, contentType, lastModified);
            // Now make the current user a manager of the content
            var newPermissions = {};
            newPermissions[ctx.user().id] = ContentConstants.roles.MANAGER;
            _setContentPermissions(contentObj, newPermissions, null, function(err) {
                if (err) {
                    callback({'code': 500, 'msg': err});
                } else {
                    // Call the callback function and return the generated id
                    callback(false, {'contentId': contentId});
                }
            });
        }
    });
};

/////////////////////////////////
// Removing a piece of content //
/////////////////////////////////

/**
 * TODO
 */
module.exports.deleteContent = function(ctx, contentId, callback) {
    callback = callback || function() {};

    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to create a conten item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Fist check whether or not the current user is a manager of the piece of content
    canManage(ctx, contentId, function(err, canManage) {
        if (err) {
            return callback(err);
        }
        // Get the members
        // Delete this from everyone's library
        // Delete the membersOf row
        // Delete the content
    });
};

////////////////////////////
// Content access control //
////////////////////////////

/**
 * TODO
 */
var shareContent = module.exports.shareContent = function(ctx, contentId, principalIds, callback) {
    
};

/**
 * Check whether or not the current user can manage a piece of content
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, canManage)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.canManage  Whether or not the user can manage the content
 */
var canManage = module.exports.canManage = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        _canManage(ctx, contentId, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            callback(null, true);
        });
    });
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, canManage)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.canManage  Whether or not the user can manage the content
 */
var _canManage = function(ctx, contentId, callback) {
    PermissionsAPI.isAllowed(ctx.user().id, ContentConstants.roles.MANAGER, contentId, function(err, canManage) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not a manager of this piece of content'});
        }
        callback(null, canManage);
    });
};

/**
 * Check whether or not the current user has access to a piece of content
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, hasAccess)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.hasAccess  Whether or not the user has access to the content
 */
var hasAccess = module.exports.hasAccess = function(ctx, contentId, callback) {
    getContent(ctx, contentId, function(err, contentObj) {
        if (err) {
            return callback(err);
        }
        callback(null, true);
    });
};

/**
 * Internal function that checks whether or not the current user has access to a piece of content. This function assumes that
 * the piece of content passed in actually exists
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to check
 * @param  {Function(err, canManage)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.canManage  Whether or not the user has access to the content
 */
var _hasAccess = function(ctx, contentObj, callback) {
    // If the content is public, I always get access
    if (contentObj.visibility === ContentConstants.permissions.PUBLIC) {
        callback(null, contentObj);
    // If the content is visible to logged in people, I get access if I'm logged in
    } else if (contentObj.visibility === ContentConstants.permissions.LOGGEDIN) {
        if (ctx.user()) {
            callback(null, contentObj);
        } else {
            callback({'code': 403, 'msg': "You don't have access to this piece of content. Please try logging in"});
        }
    // If the content is private
    } else if (ctx.user()) {
        PermissionsAPI.isAllowedAny(ctx.user().id, contentObj.contentId, function(err, hasAccess, two, three) {
            if (err) {
                return callback(err);
            } else if (!hasAccess) {
                return callback({'code': 401, 'msg': 'You are not a manager of this piece of content'});
            }
            callback(null, true);
        });
    } else {
        callback({'code': 403, 'msg': "You don't have access to this piece of content. Please try logging in"});
    }
};

/**
 * 
 * @param  {Context}                    ctx                 Standard context object, representing the currently logged user and its tenant
 * @param  {String}                     contentId           The id of the content object we want to set permissions on
 * @param  {Object}                     newPermissions      
 * @param  {Function(err, canManage)}   callback            Standard callback function
 * @param  {Object}                     callback.err        Error object containing the error message
 * @param  {Boolean}                    callback.canManage  Whether or not the user has access to the content
 */
var setContentPermissions = module.exports.setContentPermissions = function(ctx, contentId, newPermissions, callback) {
    callback = callback || {};
    // Parameter validation
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    validator.check(null, {'code': 403, 'msg': 'You have to be logged in to be able to create a conten item'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Check if the content exists
    getContent(ctx, contentId, function(err, contentObj) {
        var oldLastModified = contentObj.lastModified;
        if (err) {
            return callback(err);
        }
        // Check if the current user can manage the content
        _canManage(ctx, contentId, function(err, canManage) {
            if (err) {
                return callback(err);
            }
            // Check if all of the provided principals exist
            var todo = 0; var done = _.keys(newPermissions).length;
            var principalsNotFound = [];
            for (var p in newPermissions) {
                if (newPermissions.hasOwnProperty) {
                    // Check if all of the principals actually exist
                    // TODO: Move this out to a principal API function
                    PrincipalUtil.getPrincipal(p, function(err, principal) {
                        if (err) {
                            principalsNotFound.push(err);
                        }
                        done++;
                        if (todo === done) {
                            if (principalsNotFound.length) {
                                callback({'code': 500, 'msg': principalsNotFound});
                            } else {
                                // Update the last modified
                                _updateContentLastModified(contentObj, function(err) {
                                    if (err) {
                                        return callback(err);
                                    }
                                    // Add the new permissions to the content. This will then update the libraries as well
                                    _setContentPermissions(contentObj, newPermissions, oldLastModified, function(err) {
                                        if (err) {
                                            return callback(err);
                                        }
                                        callback(null);
                                    });
                                });
                            }
                        }
                    });
                }
            }
        });
    });
};

/**
 * TODO
 */
var _setContentPermissions = function(contentObj, newPermissions, oldLastModified, callback) {
    var queries = [];
    // First split all the ones that need to be added/updated from those that need to be deleted
    for (var p in newPermissions) {
        if (newPermissions.hasOwnProperty(p)) {
            if (newPermissions[p]) {
                queries.push({
                    'query': 'UPDATE ContentMembers SET ? = ? WHERE contentId = ?',
                    'parameters': [p, newPermissions[p], contentObj.contentId]
                });
            } else {
                queries.push({
                    'query': 'DELETE ? FROM ContentMembers WHERE contentId = ?',
                    'parameters': [p, contentObj.contentId]
                });
            }
        }
    };
    // Updates the ContentMembers CF
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }
        // Reflect this into the main roles CF as well
        RolesAPI.setRoles(contentObj.contentId, newPermissions, function(err) {
            if (err) {
                return callback(err);
            }
            // Now update all of the libraries this affects
            _updateLibraries(contentObj, oldLastModified, function(err) {
                if (err) {
                    return callback(err);
                }
                callback(null);
            });
        });
    });
};

/**
 * TODO
 */
var getContentMembers = module.exports.getContentMembers = function(ctx, contentId, callback) {
    
};

/**
 * TODO
 */
var _getContentMembers = function(contentId, callback) {
    Cassandra.runQuery("SELECT * FROM ContentMembers WHERE contentId = ?", [contentId], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var members = [];
        for (var r = 0; r < rows[0].cols.length; r++) {
            if (rows[0].cols[r].name !== "contentId") {
                members.push(rows[0].cols[r].name);
            }
        }
        callback(null, members);
    });
};

/////////////////////////////
// Update content metadata //
/////////////////////////////

/**
 * TODO
 */
var _updateContentLastModified = function(contentObj, callback) {
    contentObj.lastModified = new Date().getTime();
    Cassandra.runQuery('UPDATE ContentMembers SET ? = ? WHERE contentId = ?', ['lastModified', contentObj.lastModified, contentObj.contentId], function (err, rows) {
        if (err) {
            return callback(err);
        }
        callback(null);
    });
};

/**
 * TODO
 */
var updateContentProfile = module.exports.updateContentProfile = function(ctx, contentId, profileFields, callback) {
    
};

/**
 * TODO
 */
var updatePrivacySettings = module.exports.updatePrivacySettings = function(ctx, contentId, visibility, callback) {
    
};

///////////////////////////
// Library functionality //
///////////////////////////

/**
 * TODO
 */
var _updateLibraries = function(contentObj, oldLastModified, callback) {
    // Remove all of the old lastModified from everyone's library and add the new lastModified based one
    _getContentMembers(contentObj.contentId, function(err, members) {
        if (err) {
            return callback(err);
        }
        var queries = [];
        for (var m = 0; m < members.length; m++) {
            // Only remove the old entries if the piece of content existed before and
            // the old lastModified date has been provided
            if (oldLastModified) {
                // Remove the old entry in the private row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrinciple WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.contentId, members[m]]
                });
                // Remove the old entry in the loggedin row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrinciple WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.contentId, members[m] + ':loggedin']
                });
                // Remove the old entry in the public row
                queries.push({
                    'query': 'DELETE ? FROM LibraryByPrinciple WHERE principalId = ?',
                    'parameters': [oldLastModified + ':' + contentObj.contentId, members[m] + ':public']
                });
            }
            // Add it back to the public row
            queries.push({
                'query': 'UPDATE LibraryByPrinciple SET ? = ? WHERE principalId = ?',
                'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, members[m]]
            });
            // Add it back to the logged in row
            if (contentObj.visibility === ContentConstants.permissions.LOGGEDIN || contentObj.visibility === ContentConstants.permissions.PUBLIC) {
                queries.push({
                    'query': 'UPDATE LibraryByPrinciple SET ? = ? WHERE principalId = ?',
                    'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, members[m] + ':loggedin']
                });
            }
            // Add it back to the public row
            if (contentObj.visibility === ContentConstants.permissions.PUBLIC) {
                queries.push({
                    'query': 'UPDATE LibraryByPrinciple SET ? = ? WHERE principalId = ?',
                    'parameters': [contentObj.lastModified + ':' + contentObj.contentId, contentObj.contentId, members[m] + ':public']
                });
            }
        };
        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                return callback(err);
            }
            callback(null);
        });
    });
};

/**
 * TODO
 */
var getLibraryItems = module.exports.getLibraryItems = function(ctx, principalId, start, limit, callback) {
    limit = limit || 10;

    var validator = new Validator();
    validator.check(principalId, {'code': 400, 'msg': 'A content id must be provided'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // We give the user the public content stream in case the user is not logged in
    if (!ctx.user()) {
        principalId = principalId + ':public';
    // We give the user the logged in content stream in case the current user is not
    // the same as the library we're looking at
    } else if (ctx.user().id !== principalId) {
        principalId = principalId + ':loggedin';
    }

    // Page the query.
    var startColumnIndex = 0;
    if (start) {
        limit++;
        startColumnIndex = 1;
    } else {
        start = '';
    }

    Cassandra.runQuery("SELECT first " + limit + " ?..\'\' FROM LibraryByPrinciple WHERE principalId = ?", [limit, principalId], function (err, rows) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }

        var items = [];
        for (var r = startColumnIndex; r < rows[0].cols.length; r++) {
            if (rows[0].cols[r].name !== "principalId") {
                items.push(rows[0].cols[r].value);
            }
        }
        // Get the content profiles of the content items, assuming that
        // we have access to all of the returned items
        _getMultipleContentItems(items, function(err, contentItems) {
            if (err) {
                return callback(err);
            }
            callback(null, contentItems);
        });
    });
};

///////////////////////
// Utility functions //
///////////////////////

/**
 * Creates a Content item from a Cassandra row.
 * @param  {Row}    row    Cassandra Row
 * @return {Group}         Converted content object
 */
var _rowToContent = function (row) {
    return new Content(row.colHash.tenant, row.colHash.contentId, row.colHash.visibility, row.colHash.title, row.colHash.description, row.colHash.contentType, row.colHash.lastModified);
};