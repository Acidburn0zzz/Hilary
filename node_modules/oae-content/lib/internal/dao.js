/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('content-dao');

/**
 * Get the previews object of all the content items listed by id in `contentIds`. The returned `previews` object
 * contains the standard `previews` object of the content, as well as the lastModified date of the content item
 * so that the preview URL may be determined:
 *
 * ```javascript
 *  {
 *      '<ContentId0>' {
 *          'lastModified': 123456789,
 *          'previews': { <ContentPreviews> }
 *      },
 *      ...
 *  }
 * ```
 *
 * @param  {String[]}   contentIds                  The list of content ids whose previews to get
 * @param  {Function}   callback                    Invoked when the process compeletes
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Object}     callback.contentPreviews    An object keyed by `contentId` whose value contains the lastModified date of the content and its associated previews. If the content has no valid preview object, then its id will not be found as a key in this object.
 */
var getContentPreviews = module.exports.getContentPreviews = function(contentIds, callback) {
    if (!contentIds || !contentIds.length) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT lastModified, previews FROM Content WHERE contentId IN (?)', [contentIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var previews = {};
        rows.forEach(function(row) {
            var lastModified = row.get('lastModified');
            var preview = row.get('previews');
            if (preview && preview.value && lastModified && lastModified.value) {
                lastModified = lastModified.value;
                try {
                    preview = JSON.parse(preview.value);
                } catch (err) {
                    log().warn({'contentId': row.key, 'previews': preview.value}, 'Could not parse preview data for content item.');
                    return;
                }

                previews[row.key] = {'lastModified': lastModified, 'previews': preview};
            }
        });

        return callback(null, previews);
    });
};

/**
 * Iterate through all the content items. This will return just the raw content properties that are specified in the `properties`
 * parameter, and only `batchSize` content items at a time. On each iteration of `batchSize` content items, the `onEach` callback
 * will be executed. When completed (e.g., there are 0 content items left to iterate through), the `onEach` callback will be
 * executed with 3rd parameter `true`. Content items will be fetched in a completely random order.
 *
 * Note that the completion of `onEach` invocation (and subsequently completion of iteration) happens when either an `err`
 * occurs, OR `complete` is set to `true`. One MUST happen, and once one has happened, the other will not. This is how you can
 * avoid a callback from being executed multiple times.
 *
 * If an exception is thrown in `onEach` in the *same process tick* that the function was executed, then `onEach` will be invoked
 * with `err === thrown exception` and processing will not continue.
 *
 * @param  {String[]}   [properties]        The names of the content properties to return in the content objects. If not specified (or is empty array), it returns just the `contentId`s
 * @param  {Number}     [batchSize]         The number of content items to fetch at a time. Defaults to 100.
 * @param  {Function}   onEach              Invoked with each batch of content items that are fetched from storage. If an exception is thrown in the *same process tick* in which it is invoked, onEach will be invoked with the `err` object that was thrown and no more iterations will complete.
 * @param  {Object}     onEach.err          An error that occurred, if any. If an error occurs and this is invoked, iteration will stop and there will be NO subsequent invocation of `onEach` where `complete === true`.
 * @param  {Object}     onEach.principals   An object holding the raw content data that was fetched from storage
 * @param  {Boolean}    onEach.complete     If `true`, indicates that there are no more content items to iterate over. Otherwise, indicates we have not completed iterating.
 */
var iterateAll = module.exports.iterateAll = function(properties, batchSize, onEach) {
    if (!properties || !properties.length) {
        properties = ['contentId'];
    }

    Cassandra.iterateAll(properties, 'Content', 'contentId', batchSize, 'ONE', function(err, rows, complete) {
        if (err) {
            return onEach(err);
        } else if (complete === true) {
            return onEach(null, null, true);
        }

        // Invoke the callback with the row hash
        var hashedRows = [];
        rows.forEach(function(row) {
            hashedRows.push(Cassandra.rowToHash(row));
        });

        return onEach(null, hashedRows);
    });
};
