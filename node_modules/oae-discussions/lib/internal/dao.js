/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var TenantsAPI = require('oae-tenants');

var Discussion = require('oae-discussions/lib/model').Discussion;

/**
 * Create a new discussion.
 *
 * @param  {String}     createdBy           The id of the user creating the discussion
 * @param  {String}     displayName         The display name of the discussion
 * @param  {String}     [description]       A longer description for the discussion
 * @param  {String}     [visibility]        The visibility of the discussion. One of public, loggedin, private. Defaults to the configured tenant default.
 * @param  {Object}     [opts]              Additional optional parameters
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object that was created
 */
var createDiscussion = module.exports.createDiscussion = function(createdBy, displayName, description, visibility, opts, callback) {
    opts = opts || {};

    var now = Date.now();
    var tenantAlias = AuthzUtil.getPrincipalFromId(principalId).tenantAlias;
    var discussionId = _createDiscussionId(tenantAlias);
    var storageHash = {
        'tenantAlias': tenantAlias,
        'createdBy': principalId,
        'displayName': displayName,
        'description': description,
        'visibility': visibility,
        'created': opts.created || now,
        'lastModified': opts.created || now
    };

    var query = Cassandra.constructUpsertCQL('Discussions', 'id', discussionId, storageHash, 'QUORUM');
    Cassandra.runQuery(query.query, query.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, _storageHashToDiscussion(discussionId, storageHash));
    });
};

/**
 * Update the basic profile of the specified discussion.
 *
 * @param  {Discussion} discussion          The discussion to update
 * @param  {Object}     profileFields       An object whose keys are profile field names, and the value is the value to which you wish the field to change
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The updated discussion object
 */
var updateDiscussion = module.exports.updateDiscussion = function(discussion, profileFields, callback) {
    var storageHash = _.extend({}, profileFields);
    storageHash.lastModified = storageHash.lastModified || Date.now();

    var query = Cassandra.constructUpsertCQL('Discussions', 'id', discussion.id, storageHash, 'QUORUM');
    Cassandra.runQuery(query.query, query.parameters, function(err) {
        if (err) {
            return callback(err);
        }

        var updatedStorageHash = _.extend({}, discussion, fieldsToUpdate);
        return callback(null, _storageHashToDiscussion(discussion.id, updatedStorageHash));
    });
};

/**
 * Get a discussion basic profile by its id.
 *
 * @param  {String}     discussionId        The id of the discussion to get
 * @param  {Function}   callback            Invoked when the process completes
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Discussion} callback.discussion The discussion object requested
 */
var getDiscussion = module.exports.getDiscussion = function(discussionId, callback) {
    getDiscussionsById([discussionId], function(err, discussions) {
        if (err) {
            return callback(err);
        }

        return callback(null, discussions[0]);
    });
};

/**
 * Get multiple discussions by their ids
 *
 * @param  {String[]}       discussionIds           The ids of the discussions to get
 * @param  {Function}       callback                Invoked when the process completes
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {Discussion[]}   callback.discussions    The discussion objects requested, in the same order as the discussion ids
 */
var getDiscussionsById = module.exports.getDiscussionsById = function(discussionIds, callback) {
    Cassandra.runQuery('SELECT * FROM Discussions USING CONSISTENCY QUORUM WHERE id IN (?)', [discussionIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        // Convert the retrieved storage hashes into the Discussion model
        var discussions = {};
        rows.forEach(function(row) {
            var storageHash = Cassandra.rowToHash(row);
            discussions[row.key] = _storageHashToDiscussion(storageHash);
        });
        
        // Order the discussions according to the array of discussion ids
        var orderedDiscussions = [];
        _.each(discussionIds, function(discussionId) {
            orderedDiscussions.push(discussions[discussionId]);
        });

        return callback(null, orderedDiscussions);
    });
};

/**
 * Create a discussion model object from its id and the storage hash.
 *
 * @param  {String}     discussionId    The id of the discussion
 * @param  {Object}     hash            A simple object that represents the stored discussion object
 * @return {Discussion}                 The discussion model object
 * @api private
 */
var _storageHashToDiscussion = function(discussionId, hash) {
    return new Discussion(
        discussionId,
        TenantsAPI.getCachedTenantByAlias(hash.tenantAlias),
        hash.createdBy,
        hash.displayName,
        hash.description,
        hash.visibility,
        hash.created,
        hash.lastModified
    );
};

/**
 * Generate a new unique discussion id
 *
 * @param  {String}     tenantAlias     The tenant for which to to generate the id
 * @return {String}                     A unique discussion resource id
 * @api private
 */
var _createDiscussionId = function(tenantAlias) {
    return AuthzUtil.toId('d', tenantAlias, ShortId.generate());
};

