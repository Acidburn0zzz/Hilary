/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var Redis = require('oae-util/lib/redis');

var INDEX_ID = "v";
var LAST_MODIFIED_THRESHOLD_SECONDS = 60;

/*!
 * The visibility masks define the visibility groups that each visibility bucket contains
 */
var _visibilityMasks = {
    'private': ['public', 'loggedin', 'private'],
    'loggedin': ['public', 'loggedin'],
    'public': ['public']
};

var insert = module.exports.insert = function(keys, resourceId, visibility, lastModified, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'keys': keys,
                'resourceId': resourceId,
                'visibility': visibility,
                'lastModified': lastModified
            }, 'Error inserting library update');
        }
    };

    lastModified = _roundLastModified(lastModified);
    _getLatestLastModified(resourceId, function(err, latestLastModified) {
        // If there was an error, we ignore it as the lastModified we were provided will have to do until
        // Redis comes back online.

        // If we have a later date here, it's probably because we almost got stuck in a race condition where
        // a resource item was updated at the same time as it was "shared" with someone.
        if (latestLastModified && latestLastModified > lastModified) {
            lastModified = latestLastModified;
        }

        var valueKey = _createValueKey(resourceId, lastModified);

        // Allowing the caller to specify a value may prove to be a useful performance tool where there is
        // a "light-weight" version of an item desired, which could be achieved without having to follow with
        // a multi-get. The difficulty comes with managing race-conditions and stopping one value from
        // clobbering another. This is not supported for now.
        var value = '1';

        var queries = [];
        _.each(_visibilityMasks, function(mask, bucketName) {
            if (_.contains(mask, visibility)) {
                // If this bucket contains resources of this visibility, insert it for each key
                _.each(keys, function(key) {
                    queries.push({
                        'query': 'UPDATE IndexVisibilityMask SET ? = ? WHERE bucketKey = ?',
                        'parameters': [valueKey, value, _createBucketKey(key, bucketName)]
                    });
                });
            }
        });

        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    });
};

var update = module.exports.update = function(keys, resourceId, visibility, newLastModified, oldLastModified, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'keys': keys,
                'resourceId': resourceId,
                'visibility': visibility,
                'lastModified': lastModified
            }, 'Error inserting library update');
        }
    };

    newLastModified = _roundLastModified(newLastModified);
    oldLastModified = _roundLastModified(oldLastModified);

    // Immediately update the latest last modified so any race conditions that may occur can be taken care of
    _setLatestLastModified(resourceId, newLastModified, function(err, wasSet) {
        if (!err && !wasSet) {
            // If `wasSet` was already set, then this resource item was recently updated, no need to update
            // now and risk a race.
            return callback();
        }

        // What we will insert into the index
        var oldValueKey = _createValueKey(resourceId, oldLastModified);
        var newValueKey = _createValueKey(resourceId, newLastModified);
        var value = '1';

        // Either we had an error or successfully set the latest last modified, so we will perform the necessary index
        // updates.
        var mask = _visibilityMasks[visibility];
        var queries = [];

        // First delete the old version of this resource for all buckets
        _.each(_visibilityMasks, function(bucketName) {
            _.each(keys, function(key) {
                queries.push({
                    'query': 'DELETE ? FROM IndexVisibilityMask WHERE bucketKey = ?',
                    'parameters': [oldValueKey, _createBucketKey(key, bucketName)]
                });
            });
        });

        // Insert the new version of this resource for the buckets associated to the specified visibility
        _.each(keys, function(key) {
            _.each(mask, function(bucketName) {
                if (_.contains(mask, visibility)) {
                    queries.push({
                        'query': 'UPDATE IndexVisibilityMask SET ? = ? WHERE bucketKey = ?',
                        'parameters': [newValueKey, value, _createBucketKey(key, bucketName)]
                    });
                }
            });
        });

        Cassandra.runBatchQuery(queries, 'QUORUM', callback);
    });
};

var remove = module.exports.remove = function(keys, resourceId, lastModified, callback) {
    var valueKey = _createValueKey(resourceId, lastModified);
    
    // Delete this resource for all visibility buckets
    var queries = [];
    _.each(_visibilityMasks, function(bucketName) {
        _.each(keys, function(key) {
            queries.push({
                'query': 'DELETE ? FROM IndexVisibilityMask WHERE bucketKey = ?',
                'parameters': [valueKey, _createBucketKey(resourceId, bucketName)]
            });
        });
    });

    Cassandra.runBatchQuery(queries, 'QUORUM', callback);
};

var list = module.exports.list = function(key, visibility, start, limit, callback) {
    limit = limit || 10;
    var bucketKey = _createBucketKey(key, visibility);

    Cassandra.runPagedColumnQuery('IndexVisibilityMask', 'bucketKey', bucketKey, start, limit, null, function(err, row) {
        if (err) {
            return callback(err);
        }

        // For repair-on-read, we will keep track of duplicate keys and delete duplicates after
        var deletePlaceholders = [];
        var valueKeysToDelete = [];

        var lastValueKey = null;
        var resourceIds = [];
        row.forEach(function(valueKey) {
            lastValueKey = valueKey;
            var parts = valueKey.split(':');
            var timestamp = parts[0];
            var resourceId = parts.slice(1);
            if (!_.contains(resourceIds, resourceId)) {
                resourceIds.push(resourceId);
            } else {
                deletePlaceholders.push('?');
                valueKeysToDelete.push(valueKey);
            }
        });

        if (valueKeysToDelete.length > 0) {
            // Add the bucketKey as the next value and lazily delete the dupes
            valueKeysToDelete.push(bucketKey);
            Cassandra.runQuery('DELETE ' + deletePlaceholders.join (',') + ' FROM IndexVisibilityMask USING CONSISTENCY ONE WHERE bucketKey = ?', valueKeysToDelete);
        }

        return callback(null, resourceIds, lastValueKey);
    });
};

var _createBucketKey = function(key, bucketName) {
    return util.format('%s#%s', key, bucketName);
};

var _createValueKey = function(resourceId, lastModified) {
    return util.format('%s:%s', lastModified, resourceId);
};

var _splitValueKey = function(valueKey, callback) {
    var parts = valueKey.split(':');
    return callback(parts.slice(1).join(':'), parts[0]);
};

var _getLatestLastModified = function(resourceId, callback) {
    var cacheKey = _createLatestLastModifiedKey(resourceId);
    Redis.getClient().get(cacheKey, callback);
};

var _setLatestLastModified = function(resourceId, lastModified, callback) {
    var cacheKey = _createLatestLastModifiedKey(resourceId);
    Redis.getClient().set(cacheKey, lastModified, callback);
};

var _createLatestLastModifiedKey = function(resourceId) {
    // Looks like: oae-index#v#c:cam:lkfjEFoij#lastModified
    return util.format('oae-index#%s#%s#lastModified', INDEX_ID, resourceId);
};

var _roundLastModified = function(lastModified) {
    var thresholdMillis = LAST_MODIFIED_THRESHOLD_SECONDS * 1000;
    return lastModified - (lastModified % thresholdMillis);
};

































// Trashbin

var _trySetLatestLastModified = function(resourceId, lastModified, callback) {
    var cacheKey = _createLatestLastModifiedKey(resourceId);
    Redis.getClient().setnx(cacheKey, lastModified, function(err, hadValue) {
        if (err) {
            return callback(err);
        }

        if (!hadValue) {
            // We set a new value, make sure this key expires
            Redis.getClient().expire(cacheKey, LAST_MODIFIED_THRESHOLD_SECONDS, function(err) {
                if (err) {
                    log().warn({'err': err, 'cacheKey': cacheKey}, 'Error setting expiry on latest lastModified. Will try again later.');
                }

                return callback(null, true);
            });
        } else {
            // There was already a value. Make sure this value will expire eventually in case there was an issue before
            Redis.getClient().ttl(cacheKey, function(err, ttl) {
                if (err) {
                    log().warn({'err': err, 'cacheKey': cacheKey}, 'Failed to check ttl of latest lastModified value. Will try again later.');
                } else if (ttl < 0) {
                    // There was no ttl, reset the expiry
                    Redis.getClient().expire(cacheKey, LAST_MODIFIED_THRESHOLD_SECONDS, function(err) {
                        if (err) {
                            log().warn({'err': err, 'cacheKey': cacheKey}, 'Failed to set expiry on stale latest lastModified. Will try again later');
                        }
                    });
                }

                // Return indicating that we did not set the value
                return callback(null, false);
            });
        }
    });
};


