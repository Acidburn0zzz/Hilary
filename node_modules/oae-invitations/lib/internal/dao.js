/*!
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var Chance = require('chance');
var util = require('util');

var Cassandra = require('oae-util/lib/cassandra');
var Invitation = require('oae-invitations/lib/model').Invitation;
var OaeUtil = require('oae-util/lib/util');

var chance = new Chance();

var TOKEN_POOL = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';

var getOrCreateTokenByEmail = module.exports.getInvitationToken = function(email, callback) {
    Cassandra.runQuery('SELECT * FROM "InvitationsTokenByEmail" WHERE "email" = ?', [email], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (!_.isEmpty(rows)) {
            return callback(null, Cassandra.rowToHash(_.first(rows)).token);
        }

        // If there wasn't a token, we need to generate a new one
        var token = chance.string({'length': 12, 'pool': TOKEN_POOL});
        var queries = [
            Cassandra.constructUpsertCQL('InvitationsTokenByEmail', 'email', email, {'token': token}),
            Cassandra.constructUpsertCQL('InvitationsTokenByEmail', 'token', token, {'email': email})
        ];

        Cassandra.runBatchQuery(queries, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, token);
        });
    });
};

var getEmailByToken = module.exports.getInvitationEmailByToken = function(token, callback) {
    Cassandra.runQuery('SELECT * FROM "InvitationsEmailByToken" WHERE "token" = ?', [token], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            return callback({'code': 404, 'msg': util.format('There is no email associated to the email token "%s"', token)});
        }

        var row = _.first(rows);
        var hash = Cassandra.rowToHash(row);
        return callback(null, hash.email);
    });
};

var saveInvitation = module.exports.saveInvitation = function(resourceId, email, inviterUserId, role, callback) {
    var invitation = new Invitation(resourceId, email, inviterUserId, role);
    var queries = [
        Cassandra.constructUpsertCQL('Invitations', 'resourceId', resourceId, invitation.toStorage()),
        Cassandra.constructUpsertCQL('InvitationsResourceIdByEmail', 'email', email, {'reosurceId': resourceId});
    ];
    return Cassandra.runBatchQuery(queries, callback);
};

var getInvitationsByEmail = module.exports.getInvitationsByEmail = function(email, callback) {
    _getInvitiationResourceIdsByEmail(email, function(err, invitedResourceIds) {
        if (err) {
            return callback(err);
        }

        return _getInvitations(invitedResourceIds, email, callback);
    });
};

var getInvitationsByResourceId = module.exports.getInvitationsByResourceId = function(resourceId, opts, callback) {
    opts = opts || {};
    opts.start = opts.start || '';
    opts.limit = OaeUtil.getNumberParam(limit, 10, 1, 25);

    Cassandra.runQuery('SELECT * FROM "Invitations" WHERE "resourceId" = ? AND "email" > ? ORDER BY "email" ASC LIMIT ' + opts.limit, [resourceId, email], function(err, rows) {
        if (err) {
            return callback(err);
        } else if (_.isEmpty(rows)) {
            return callback(null, [], null);
        }

        var invitations = _.chain(rows)
            .map(Cassandra.rowToHash)
            .map(Invitation.fromStorage)
            .value();
        var nextToken = _.last(invitations).email;
        return callback(null, invitations, nextToken);
    });
};

var deleteInvitation = module.exports.deleteInvitation = function(resourceId, email, callback) {
    var queries = [
        {
            'query': 'DELETE FROM "Invitations" WHERE "resourceId" = ? AND "email" = ?',
            'parameters': [resourceId, email]
        },
        {
            'query': 'DELETE FROM "InvitationsResourceIdByEmail" WHERE "email" = ?',
            'parameters': [email]
        }
    ];

    return Cassandra.runBatchQuery(queries);
};

var _getInvitiationResourceIdsByEmail = function(email, callback, _resourceIds, _nextToken) {
    var cql = 'SELECT "resourceId" FROM "InvitationsResourceIdByEmail" WHERE "email" = ?';
    var params = [email];
    if (_nextToken) {
        cql += ' AND "resourceId" > ?'
        params.push(_nextToken);
    }

    cql += ' ORDER BY "email" ASC LIMIT 100';
    Cassandra.runQuery(cql, params, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var resourceIds = _.chain(rows)
            .map(Cassandra.rowToHash)
            .pluck('resourceId')
            .value();
        _resourceIds = _.union(_resourceIds, resourceIds);
        if (_.isEmpty(resourceIds)) {
            return callback(null, _resourceIds);
        } else {
            _nextToken = _.last(resourceIds);
            return getInvitiationResourceIdsByEmail(email, callback, _resourceIds, _nextToken);
        }
    });
};

var _getInvitations = function(resourceIds, email, callback) {
    Cassandra.runQuery('SELECT * FROM "Invitations" WHERE "resourceId" IN (?) AND email = ?', [resourceIds, email], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var invitations = _.chain(rows)
            .map(Cassandra.rowToHash)
            .map(Invitation.fromStorage)
            .value();
        return callback(null, invitations);
    });
};
