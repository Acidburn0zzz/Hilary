/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var PrincipalsGroupAPI = require('oae-principals/lib/api.group');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsUtil = require('oae-tenants/lib/util');

/**
 * Determine which visibility level of library the user in context should receive from the target library owner. The following
 * table presents a visibility matrix of how a feed would be issued for a group.
 *
 * Assume that Tenant A and B both have enabled tenant permeability and Tenant C has it disabled. The column headers defined the
 * status of the current user (whether he is anonymous, an authenticated user or if he's a member), the rows express the
 * visibility setting of the library owner. Each cell will then express which library stream should be returned. A `/` means
 * the user does not have access to the library
 *
 *
 *                ||                Public Tenant A                  ||                 Public Tenant B                ||      Private Tenant C
 *                ||     Anon    |   Loggedin user   |   Member      ||      Anon    |   Loggedin user   |   Member    ||      Anon    |   Loggedin user   |   Member
 * ------------------------------------------------------------------------------------------------------------------- -------------------------------------------------
 * public group   ||     public  |     logged in     |  private      ||     public   |      public       |   private   ||     public   |      public           private
 *                ||             |                                   ||              |                   |             ||              |
 * loggedin group ||       /     |     logged in     |  private      ||        /     |        /          |   private   ||        /     |        /              private
 *                ||             |                                   ||              |                   |             ||              |
 * private group  ||       /     |        /          |  private      ||        /     |        /          |   private   ||        /     |        /              private
 *
 *
 * @param  {Context}    ctx                         Standard context object containing the current user and the current tenant
 * @param  {String}     libraryId                   The authz id used to index the library. Note that this is not always the id of the "library owner" resource, as in cases like folders, it uses a surrogate group id to be represented in authz
 * @param  {Object}     libraryOwner                A standard resource object that represents the resource that "owns" the library
 * @param  {Tenant}     libraryOwner.tenant         The tenant of the resource that owns the library
 * @param  {String}     libraryOwner.visibility     The visibility of the resource that owns the library
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error that occurred, if any
 * @param  {Boolean}    callback.hasAccess          A boolean flag that expresses whether the current user has access to the library
 * @param  {String}     callback.visibility         The best visibility (as enumerated in `AuthzConstants.visibility`) of library the user in context can see from the target library owner. If the user has no access, this value will be falsey
 */
var resolveTargetLibraryAccess = module.exports.resolveTargetLibraryAccess = function(ctx, libraryId, libraryOwner, callback) {
    var libraryTenantAlias = libraryOwner.tenant.alias

    // Admin users always get private libraries if they are admin of the tenant to which the library
    // belongs
    if (ctx.user() && (ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(libraryTenantAlias))) {
        return callback(null, true, AuthzConstants.visibility.PRIVATE);
    }

    // The current user is not an admin of the target library tenant, so we'll have to do some
    // acrobatics to resolve the visibility
    if (PrincipalsUtil.isUser(libraryId)) {
        // If the current user is requesting a library they own, we can return the private items
        if (ctx.user() && ctx.user().id === libraryId) {
            return callback(null, true, AuthzConstants.visibility.PRIVATE);

        // The user is looking at a library that belongs to another user. Ensure the current user
        // has any access to it
        } else if (libraryOwner.visibility === AuthzConstants.visibility.PRIVATE || (libraryOwner.visibility === AuthzConstants.visibility.LOGGEDIN && !TenantsUtil.isLoggedIn(ctx, libraryTenantAlias))) {
            return callback(null, false);

        // If we are authenticated to the target library's tenant, we are able to see its loggedin
        // items
        } else if (TenantsUtil.isLoggedIn(ctx, libraryTenantAlias)) {
            return callback(null, true, AuthzConstants.visibility.LOGGEDIN);

        // If we get here, we only have access to the public items in the library
        } else {
            return callback(null, true, AuthzConstants.visibility.PUBLIC);
        }

    // If we are looking at a library that belongs to a non-user resource. This basically means that
    // explicit access (e.g., role association) can play a part in what items in the library we can
    // have access to, so we have to treat the logic significantly different
    } else {
        // Anonymous users can only access the public stream if the resource has been set to public
        if (!ctx.user()) {
            if (libraryOwner.visibility === AuthzConstants.visibility.PUBLIC) {
                return callback(null, true, AuthzConstants.visibility.PUBLIC);
            } else {
                // Anonymous users cannot have a role on any resource, so we can short-circuit
                // access checks without looking for role associations
                return callback(null, false);
            }
        }

        // We've established that the user is logged in, so we'll need to determine the role the
        // user has in the group so we can show the correct library
        AuthzAPI.hasAnyRole(ctx.user().id, libraryId, function(err, hasAnyRole) {
            if (err) {
                return callback(err);
            }

            if (hasAnyRole) {
                // If the current user has any role on the owner of the target resource, they can
                // always see the private items in the library
                return callback(null, true, AuthzConstants.visibility.PRIVATE);
            } else if (!TenantsUtil.isLoggedIn(ctx, libraryTenantAlias)) {
                if (libraryOwner.visibility === AuthzConstants.visibility.PUBLIC) {
                    // If the current user is not authenticated to the target library's tenant, they
                    // can only see public items, but only if the owner's visibility is public
                    return callback(null, true, AuthzConstants.visibility.PUBLIC);
                } else {
                    // If the current user is not authenticated to the target library's tenant, they
                    // can't see the library if the library owner is not public
                    return callback(null, false);
                }
            } else if (libraryOwner.visibility === AuthzConstants.visibility.PRIVATE) {
                // The current user does not have any role on the library's owner, therefore if it
                // is private, we cannot see its items
                return callback(null, false);
            } else {
                // At this point, the library owner has loggedin visibility and we are authenticated
                // to its tenant (but not a member), therefore we can see just the loggedin items
                return callback(null, true, AuthzConstants.visibility.LOGGEDIN);
            }
        });
    }
};

/**
 * Determines whether or not the user in context can remove an item from the specified library.
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     libraryOwnerId      The owner of the library from which we wish to remove item(s)
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Boolean}    callback.canRemove  Whether or not the user in context cgan remove an item from the library
 */
var canRemoveFromLibrary = module.exports.canRemoveFromLibrary = function(ctx, libraryOwnerId, callback) {
    var user = ctx.user();

    if (!user) {
        // Anonymous can never remove a discussion from a library
        return callback(null, false);
    }

    // Admin check. Admins can do all the things
    var libraryTenantAlias = AuthzUtil.getPrincipalFromId(libraryOwnerId).tenantAlias;
    if (ctx.user().isGlobalAdmin() || ctx.user().isTenantAdmin(libraryTenantAlias)) {
        return callback(null, true);
    }

    if (PrincipalsUtil.isUser(libraryOwnerId)) {
        if (ctx.user().id === libraryOwnerId) {
            // Only admins and the user themself can delete an item from their discussion library
            return callback(null, true);
        } else {
            return callback (null, false);
        }
    } else if (PrincipalsUtil.isGroup(libraryOwnerId)) {
        // If this is a group, only managers can remove items from its library
        return PrincipalsGroupAPI.canManage(ctx, libraryOwnerId, callback);
    } else {
        return callback({'err': 400, 'code': 'Invalid library owner specified'});
    }
};
