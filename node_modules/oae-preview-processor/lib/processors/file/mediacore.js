/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var crypto = require('crypto');
var fs = require('fs');
var request = require('request');

var log = require('oae-logger').logger('oae-preview-processor');

var PreviewConfig = require('oae-config').config('oae-preview-processor');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var PreviewUtil = require('oae-preview-processor/lib/util');

/**
 * @borrows Interface.test as Videos.test
 */
var test = module.exports.test = function(ctx, contentObj, callback) {
    debugger;
    if (contentObj.resourceSubType === 'file' && PreviewConstants.TYPES.VIDEO.indexOf(contentObj.mime) !== -1 && PreviewConfig.getValue('admin', 'mediacore', 'enabled')) {
        callback(null, 20);
    } else {
        callback(null, -1);
    }
};

/**
 * @borrows Interface.generatePreviews as Videos.generatePreviews
 */
var generatePreviews = module.exports.generatePreviews = function(ctx, contentObj, callback) {
    // Download the file.
    ctx.download(function(err, path) {
        if (err) {
            return callback(err);
        }

        var mcConf = _getConfig();

        var createMediaUrl = mcConf.url + '/api2/media';
        createMediaUrl += '?' + _getSignedUrl(createMediaUrl, '', mcConf.keyId, mcConf.secret);
        // Create a media item
        request.post({
            'url': createMediaUrl,
            'json': {
                'collection_id': mcConf.collectionId,
                'title': contentObj.displayName,
                'byline': contentObj.createdBy.displayName,
                'description': null,
                'tags': null
            }
        }, function(err, res, body) {
            if (err) {
                return callback(err);
            }

            log().trace(res.headers);
            log().trace(body);
            if (res.statusCode !== 200) {
                return callback({'code': res.statusCode, 'msg': body});
            }

            var mediaId = body.id;
            var createMediaFileUrl = mcConf.url + '/api2/media/' + mediaId + '/files'
            createMediaFileUrl += '?' + _getSignedUrl(createMediaFileUrl, '', mcConf.keyId, mcConf.secret);
            // Ask mediacore to let us upload a file to the media item
            request.post({
                'url': createMediaFileUrl,
                'json': {
                    'upload_type': 'video',
                    'upload_name': contentObj.displayName,
                    'upload_size': contentObj.size
                }
            }, function(err, res, body) {
                if (err) {
                    return callback(err);
                }

                log().trace(res.headers);
                log().trace(body);
                if (res.statusCode !== 200) {
                    return callback({'code': res.statusCode, 'msg': body});
                }

                var uploadProtocol = body.upload.protocols.form_data;
                // Upload the file as multipart/form-data
                var req = request.post(uploadProtocol.upload_url, function(err, res, body) {
                    if (err) {
                        return callback(err);
                    }

                    log().trace(res.headers);
                    log().trace(body);
                    if (res.statusCode !== 200) {
                        return callback({'code': res.statusCode, 'msg': body});
                    }

                    // Notify mediacore that we're done uploading the file
                    if (uploadProtocol.postprocess_url) {
                        var postprocessUrl = mcConf.url + uploadProtocol.postprocess_url;
                        postprocessUrl += '?' + _getSignedUrl(postprocessUrl, '', mcConf.keyId, mcConf.secret);
                        request.post({
                            'url': postprocessUrl,
                            'json': {
                                'response_status': res.statusCode,
                                'response_body': body
                            }
                        }, function(err, res, body) {
                            if (err) {
                                log().error(err);
                                return callback(err);
                            }

                            log().trace(res.headers);
                            log().trace(body);
                            if (res.statusCode !== 200) {
                                return callback({'code': res.statusCode, 'msg': body});
                            }

                            ctx.addPreview(mediaId, 'mediacoreId');
                            callback();
                        });
                    } else {
                        ctx.addPreview(mediaId, 'mediacoreId');
                        callback();
                    }
                });
                var form = req.form();
                for (param in uploadProtocol.upload_post_params) {
                    if (uploadProtocol.upload_post_params.hasOwnProperty(param)) {
                        form.append(param, uploadProtocol.upload_post_params[param]);
                    }
                }
                form.append(uploadProtocol.upload_file_param, fs.createReadStream(path));
            });
        });
    });
};

/**
 * Get the mediacore API values that have been configured in the Admin UI.
 *
 * @return {Object} The url, keyID and secret from the Admin UI.
 * @api private
 */
var _getConfig = function() {
    return {
        'url': PreviewConfig.getValue('admin', 'mediacore', 'url'),
        'keyId': PreviewConfig.getValue('admin', 'mediacore', 'keyId'),
        'secret': PreviewConfig.getValue('admin', 'mediacore', 'secret'),
        'collectionId': PreviewConfig.getValue('admin', 'mediacore', 'collectionId')
    };
};


/**
 * Signs a url with HMAC for mediacore
 *
 * @param  {String}     url               The url to be signed
 * @param  {String}     queryString       The queryString for the url
 * @param  {String}     keyId             The mediacore key id
 * @param  {String}     secretKey         The mediacore secret key
 * @param  {Integer}    [tll]             The number of seconds this signature should be valid for
 * @param  {String}     [ipMask]          The mediacore ipMask
 * @return {String}                       A signed url
 * @api private
 */
var _getSignedUrl = function(url, queryString, keyId, secretKey, tll, ipMask) {
    var expiryEpoch = null;
    if (tll){
        expiryEpoch = ((Date.now()/100) + tll);
    }

    var policyString = _makePolicyString(url, queryString, expiryEpoch, ipMask);
    log().trace(policyString);
    var encodedPolicyString = _urlSafeB64Encode(policyString);
    var signature = _getSignature(secretKey, encodedPolicyString);

    var newQs = '_Policy=' + encodedPolicyString + '&_Signature=' + signature + '&_KeyId=' + keyId;

    if (queryString !== '' && queryString !== '*') {
        newQs = queryString + '&' + newQs;
    }
    return newQs;
};

/**
 * Build a mediacore policy JSON
 *
 * @param  {String}        url            The url of the policy resource
 * @param  {String}        [queryString]  The queryString for the url
 * @param  {Integer}       [expiryEpoch]  Unix epoch timestamp for when this policy expires
 * @param  {String}        [ipMask]       The mediacore ipMask for this policy
 * @return {String}                       A JSON representation of the policy
 * @api private
 */
var _makePolicyString = function(url, queryString, expiryEpoch, ipMask) {
    policy = {
        'resource': url
    };
    if (queryString && queryString !== '') {
        policy.query_string = queryString;
    }
    if (ipMask) {
        policy.ip_range = ipMask;
    }
    if (expiryEpoch) {
        policy.expiry_epoch = expiryEpoch;
    }
    return JSON.stringify(policy);
};

/**
 * Base64 encode a string with url safe characters
 *
 * @param  {String}    unencoded         The string to be encoded
 * @return {String}                      The base64 encoded string
 * @api private
 */
var _urlSafeB64Encode = function(unencoded) {
    var encoded = new Buffer(unencoded || '').toString('base64');
    // replace '+' with '-', '/' with '_', and strip padding '=' chars
    var urlSafe = encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return urlSafe;
};

/**
 * Get an HMAC signature
 *
 * @param  {String}  secretKey       A url safe base64 encoded secret key
 * @param  {String}  value           A string to sign
 * @return {String}                  The HMAC hash
 * @api private
 */
var _getSignature = function(secretKey, value) {
    var sKeyBytes = new Buffer(secretKey, 'base64');
    var algo = 'sha256';
    if (sKeyBytes.toString('hex').length == 256) {
        algo = 'sha512';
    }
    var hash = crypto.createHmac(algo, sKeyBytes).update(value).digest('base64');
    // replace '+' with '-', '/' with '_', and strip padding '=' chars
    hash = hash.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return hash;
};
