/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var gm = require('gm');
var Path = require('path');
var temp = require('temp');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var ContentAPI = require('oae-content');
var Resource = require('oae-authz/lib/model').Resource;
var Signature = require('oae-util/lib/signature');
var Validator = require('oae-util/lib/validator').Validator;
var log = require('oae-logger').logger('oae-principals-shared');

var GroupApi = require('./api.group');
var PrincipalsUtil = require('./util');
var UserApi = require('./api.user');


/**
 * Store a picture for a principal that can be re-used later on.
 *
 * @param {Context}     ctx             Context that holds the current user and tenant.
 * @param {String}      principalId     The ID of the principal you wish to store a picture for.
 * @param {File}        file            The picture
 * @param {String}      file.name       The name of the file you wish to store.
 * @param {String}      file.type       The mimetype of the file. Only images are accepted.
 * @param {String}      file.path       The path on disk where the file is stored.
 * @param {Number}      file.size       The filesize. A maximum of 5MB is imposed.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    Standard error object (if any.)
 */
var storePicture = module.exports.storePicture = function(ctx, principalId, file, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to store picture %s for %s', file.path, principalId);
        }
    };
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a picture'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A principal ID must be provided'}).isPrincipalId();
    validator.check(file, {'code': 400, 'msg': 'A file must be provided'}).notNull();
    if (file) {
        validator.check(file.type, {'code': 400, 'msg': 'Missing mimetype on the file object.'}).notEmpty();
        validator.check(file.type, {'code': 400, 'msg': 'Only images are accepted files.'}).isIn(['image/jpg', 'image/jpeg', 'image/png', 'image/gif', 'image.bmp']);
        validator.check(file.size, {'code': 400, 'msg': 'Missing size on the file object.'}).notEmpty();
        validator.check(file.size, {'code': 400, 'msg': 'The size of a picture has an upper limit of 5MB.'}).max(5242880);
        validator.check(file.name, {'code': 400, 'msg': 'Missing name on the file object.'}).notEmpty();
    }
    if (validator.hasErrors()) {
        // Unlink the file if the request is invalid.
        if (file && file.path) {
            fs.unlink(file.path);
        }
        return callback(validator.getFirstError());
    }

    var store = function(err, principal) {
        if (err) {
            return callback(err);
        }
        ContentAPI.getStorageBackend(ctx).store(ctx, file, function(err, largePictureUri) {
            if (err) {
                return callback(err);
            }

            // Save in Cassandra.
            var values = {'largePictureUri': largePictureUri};
            var q = Cassandra.constructUpsertCQL('Principals', 'principalId', principalId, values, 'QUORUM');
            if (!q) {
                return callback({'code': 500, 'msg': 'Unable to store picture uri'});
            }
            Cassandra.runQuery(q.query, q.parameters, function(err) {
                if (err) {
                    return callback(err);
                }
                if (PrincipalsUtil.isUser(principalId)) {
                    PrincipalsUtil.invalidateCachedUser(principalId, callback);
                } else {
                    callback(null);
                }
            });
        });
    };

    canManagePrincipal(ctx, principalId, store);
};

/**
 * Crops a part out of a picture.
 *
 * @param {String}      path                    The path on disk of the file that needs to be cropped.
 * @param {Object}      selectedArea            The area that needs to be cropped out.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {String}      callback.path           The path where the cropped file has been written to.
 * @api private
 */
var cropPicture = function(path, selectedArea, callback) {
    // Pipe it trough imagemagick.
    var tempPath = temp.path({'suffix': '.png'});
    var imageMagick = gm.subClass({ 'imageMagick': true });
    imageMagick(path)
        .crop(selectedArea.width, selectedArea.height, selectedArea.x, selectedArea.y)
        .noProfile()
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not crop the profile picture %s', path);
                return callback({'code': 500, 'msg': err});
            }
            callback(null, tempPath);
        });
};

/**
 * Resizes a picture to the specified size.
 *
 * @param {String}      path                The path on disk of the file that needs to be resized.
 * @param {Object}      size                The new size of the image.
 * @param {Number}      size.width          The width that the image should be resized to.
 * @param {Number}      size.height         The height that the image should be resized to.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        An error object (if any.)
 * @param {Object}      callback.file       A file object with some metadata of the resized file.
 * @param {Object}      callback.file.path  The path where the file has been written to.
 * @param {Object}      callback.file.name  The name of the file
 * @param {Object}      callback.file.size  The size of the resized image (in bytes).
 * @api private
 */
var resizePicture = function(path, size, callback) {
    var suffix = size.width + 'x' + size.height + '.png';
    var tempPath = temp.path({'suffix': suffix});
    var imageMagick = gm.subClass({ 'imageMagick': true });
    imageMagick(path)
        .resize(size.width, size.height)
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not resize the profile picture %s', path);
                return callback({'code': 500, 'msg': err});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath);
                    return callback({'code': 500, 'msg': err});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': Path.basename(tempPath)
                };
                callback(null, file);
            });
        });
};

/**
 * Crops and resizes an image.
 *
 * @param {String}      path                    The path on disk of the image to crop.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {File}        callback.smallPicture   The file object representing the small image.
 * @param {File}        callback.mediumPicture  The file object representing the medium image.
 * @api private
 */
var getResizedImages = function(path, selectedArea, callback) {
    // Crop and resize them.
    cropPicture(path, selectedArea, function(err, croppedPath) {
        if (err) {
            return callback(err);
        }

        // Generate a small one.
        resizePicture(croppedPath, {'width': 32, 'height': 32}, function(err, smallPicture) {
            if (err) {
                return callback(err);
            }

            // Generate a medium sized one.
            resizePicture(croppedPath, {'width': 256, 'height': 256}, function(err, mediumPicture) {
                if (err) {
                    return callback(err);
                }

                // Remove the cropped one.
                fs.unlink(croppedPath, function(err) {
                    if (err) {
                        return callback({'code': 500, 'msg': err});
                    }
                    callback(null, smallPicture, mediumPicture);
                });
            });
        });
    });
};

/**
 * Crops the picture attached to this principal and generates 32x32 and 256x256 versions of it.
 *
 * @param {Context}     ctx             Context that holds the current user and tenant.
 * @param {String}      principalId     The ID of the principal to crop the large picture for.
 * @param {Number}      x               The x coordinate of the topleft corner to start cropping
 * @param {Number}      y               The y coordinate of the topleft corner to start cropping
 * @param {Number}      width           The width of the box that needs to be cropped out.
 * @param {Number}      width           The height of the box that needs to be cropped out.
 * @param {Function}    callback        Standard callback method.
 * @param {Object}      callback.err    An error object (if any.)
 * @api private
 */
var generateSizes = module.exports.generateSizes = function(ctx, principalId, x, y, width, height, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to crop picture %s for %s', fileUri, principalId);
        }
    };

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a picture'}).isLoggedInUser(ctx);
    validator.check(principalId, {'code': 400, 'msg': 'A principal id must be provided'}).isPrincipalId();
    validator.check(x, {'code': 400, 'msg': 'The x value must be a positive integer'}).isInt();
    validator.check(x, {'code': 400, 'msg': 'The x value must be a positive integer'}).min(0);
    validator.check(y, {'code': 400, 'msg': 'The y value must be a positive integer'}).isInt();
    validator.check(y, {'code': 400, 'msg': 'The y value must be a positive integer'}).min(0);
    validator.check(width, {'code': 400, 'msg': 'The width value must be a positive integer'}).isInt();
    validator.check(width, {'code': 400, 'msg': 'The width value must be a positive integer'}).min(10);
    validator.check(height, {'code': 400, 'msg': 'The height value must be a positive integer'}).isInt();
    validator.check(height, {'code': 400, 'msg': 'The height value must be a positive integer'}).min(10);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var cropAndResize = function(err, principal) {
        if (err) {
            return callback(err);
        } else if (!principal.largePictureUri) {
            return callback({'code': 400, 'msg': 'This principal has no large picture associated with it.'});
        }

        // Retrieve the raw image.
        ContentAPI.getStorageBackend(ctx).get(ctx, principal.largePictureUri, function(err, file) {
            if (err) {
                return callback(err);
            }

            // Get the resized images.
            var selectedArea = {
                'x': x,
                'y': y,
                'width': width,
                'height': height
            };
            getResizedImages(file.path, selectedArea, function(err, smallPicture, mediumPicture) {
                if (err) {
                    return callback(err);
                }

                // Store them.
                ContentAPI.getStorageBackend(ctx).store(ctx, smallPicture, function(err, smallPictureUri) {
                    if (err) {
                        return callback(err);
                    }
                    ContentAPI.getStorageBackend(ctx).store(ctx, mediumPicture, function(err, mediumPictureUri) {
                        if (err) {
                            return callback(err);
                        }

                        // Save in Cassandra.
                        var values = {
                            'smallPictureUri': smallPictureUri,
                            'mediumPictureUri': mediumPictureUri
                        };
                        var q = Cassandra.constructUpsertCQL('Principals', 'principalId', principalId, values, 'QUORUM');
                        if (!q) {
                            return callback({'code': 500, 'msg': 'Unable to store cropped picture URIs'});
                        }
                        Cassandra.runQuery(q.query, q.parameters, function(err) {
                            if (err) {
                                return callback(err);
                            }
                            if (PrincipalsUtil.isUser(principalId)) {
                                PrincipalsUtil.invalidateCachedUser(principalId, callback);
                            } else {
                                callback(null);
                            }
                        });
                    });
                });
            });
        });
    };

    canManagePrincipal(ctx, principalId, cropAndResize);
};

/**
 * Checks if the current user can edit the principal.
 * If he or she cannot edit the principal, a 401 error object will be passed back.
 *
 * @param {Context}     ctx                 Context that holds the current user and tenant.
 * @param {String}      principalId         The ID of the principal to check.
 * @param {Function}    callback            Standard callback method.
 * @param {Object}      callback.err        Standard error object.
 * @param {Group|User}  callback.principal  The group or user object if the user can manage it.
 * @api private
 */
var canManagePrincipal = function(ctx, principalId, callback) {
    // Only the current user or an admin can update a user.
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (PrincipalsUtil.isUser(principalId) && ctx.user().id === principalId || ctx.user().isAdmin(principalResource.tenantAlias)) {
        // Get the user's information.
        PrincipalsUtil.getPrincipal(ctx, principalId, callback);

    // We'll need to check a group explicitly.
    } else if (PrincipalsUtil.isGroup(principalId)) {
        GroupApi.canManage(ctx, principalId, function(err, canManage, group) {
            if (err) {
                return callback(err);
            } else if (!canManage) {
                return callback({'code': 401, 'msg': 'You cannot update the picture of this group.'});
            }

            callback(null, group);
        });
    } else {
        callback({'code': 401, 'msg': 'You cannot update the picture of this principal.'});
    }
};