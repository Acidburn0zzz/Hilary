/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var clone = require('clone');
var fs = require('fs');
var Path = require('path');
var ShortId = require('shortid');

var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var Config = require('oae-config/lib/api').config('oae-principals');
var log = require('oae-logger').logger('oae-principals');
var Redis = require('oae-util/lib/redis');
var Validator = require('oae-util/lib/validator').Validator;
var TZ = require('oae-util/lib/tz');
var Validator = require('oae-util/lib/validator').Validator;

var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var PrincipalsEmitter = require('./internal/emitter');
var PrincipalsModel = require('./model');
var PrincipalsUtil = require('./util');

var fullUserProfileDecorators = {};

/**
 * Register a decorator for the full user profile. A decorator will, at read time, provide additional data about the user
 * that will be returned to the client
 *
 * @param  {String}     namespace                   The unique namespace for this decorator
 * @param  {Function}   decorator                   The function that will provide additional data for the user profile
 * @param  {Context}    decorator.ctx               The context of the current request
 * @param  {User}       decorator.user              The user being decorated
 * @param  {Function}   decorator.callback          This function should be invoked with the decoration object when complete
 * @param  {Object}     decorator.callback.err      An error that occurred during decoration, if any
 * @param  {Object}     decorator.callback.data     The decoration data to bind to the full user profile
 */
var registerFullUserProfileDecorator = module.exports.registerFullUserProfileDecorator = function(namespace, decorator) {
    if (fullUserProfileDecorators[namespace]) {
        throw new Error(util.format('Attempted to register duplicate full user profile decorator with namespace "%s"', namespace));
    } else if (!_.isFunction(decorator)) {
        throw new Error(util.format('Attempted to register full user profile decorator for namespace "%s" without a decorator function', namespace));
    }

    fullUserProfileDecorators[namespace] = decorator;
};

/**
 * Create a new user on the current tenant.
 *
 * @param  {Context}   ctx                     The current context
 * @param  {String}    displayName             A display name to represent the user on the UI
 * @param  {Object}    [opts]                  Optional parameters for the user
 * @param  {String}    [opts.visibility]       The user's visibility setting (One of AuthzConstants.visibility)
 * @param  {String}    [opts.locale]           The user's locale
 * @param  {String}    [opts.timezone]         The user's timezone
 * @param  {String}    [opts.publicAlias]      This name will be what is seen when when the user is displayed to someone who does not have access to the profile
 * @param  {String}    [opts.smallPictureUri]  The URI for the small picture
 * @param  {String}    [opts.mediumPictureUri] The URI for the medium picture
 * @param  {String}    [opts.largePictureUri]  The URI for the large picture
 * @param  {Function}  callback                Standard callback function
 * @param  {Object}    callback.err            Error object containing the error message
 * @param  {User}      callback.createdUser    A User object representing the created user
 */
var createUser = module.exports.createUser = function(ctx, displayName, opts, callback) {
    opts = opts || {};
    callback = callback || function(err) {
        if (err) {
            log().error({
                'err': err,
                'displayName': displayName
            }, 'Error creating user.');
        }
    };

    var tenantAlias = ctx.tenant().alias;

    opts.locale = opts.locale || Config.getValue(tenantAlias, 'user', 'defaultLanguage');
    opts.timezone = TZ.getClosestSupportedTimezone(opts.timezone);
    opts.visibility = opts.visibility || AuthzConstants.visibility.PUBLIC;
    opts.publicAlias = opts.publicAlias || displayName;

    var validator = new Validator();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be provided'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    validator.check(opts.visibility, {'code': 400, 'msg': 'The specified visibility setting is unknown.'}).isIn(_.values(AuthzConstants.visibility));
    validator.check(opts.timezone, {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var id = AuthzUtil.toId('u', tenantAlias, ShortId.generate());

    var values = {
        'tenantAlias': tenantAlias,
        'displayName': displayName,
        'visibility': opts.visibility,
        'email': opts.email,
        'locale': opts.locale,
        'timezone': opts.timezone,
        'publicAlias': opts.publicAlias,
        'smallPictureUri': opts.smallPictureUri,
        'mediumPictureUri': opts.mediumPictureUri,
        'largePictureUri': opts.lagePictureUri
    };

    var q = Cassandra.constructUpsertCQL('Principals', 'principalId', id, values);
    if (!q) {
        return callback({'code': 500, 'msg': 'Could not create a proper CQL query.'});
    }

    // Create the user
    Cassandra.runQuery(q.query, q.parameters, function (err) {
        if (err) {
            return callback(err);
        }

        var createdUser = new PrincipalsModel.User(tenantAlias, id, displayName, opts);
        PrincipalsEmitter.emit(PrincipalsConstants.events.CREATED_USER, ctx, createdUser);
        return callback(null, createdUser);
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx             The current context
 * @param  {String}         userId          The userId of the user you wish to update
 * @param  {Object}         profileFields   Object that represent the profile fields that should be updated. Possible keys are visibility, displayName, publicAlias, locale and timezone
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Error object containing the error message
 * @param  {User}           callback.user   A user object representing the updated profile
 */
var updateUser = module.exports.updateUser = function(ctx, userId, profileFields, callback) {
    callback = callback || function() {};
    profileFields = profileFields || {};

    var profileFieldKeys = _.keys(profileFields);

    // Parameter validation
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'A user id must be provided'}).notEmpty();
    // Check that there is at least one updated profile field.
    validator.check(profileFieldKeys.length, {'code': 400, 'msg': 'At least one basic profile field should be specified'}).min(1);

    // verify that restricted properties aren't set here
    var invalidKeys = _.intersection(PrincipalsDAO.getRestrictedFields(), profileFieldKeys);
    validator.check(invalidKeys.length, {'code': 400, 'msg': 'Restricted property was attempted to be set.'}).max(0);

    if (profileFields['displayName']) {
        validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A displayName cannot be empty'}).notEmpty();
        validator.check(profileFields['displayName'], {'code': 400, 'msg': 'A displayName can only be 1000 characters long'}).isShortString();
    }

    // In case a new visibility has been passed in, we check for its validity
    if (profileFields['visibility']) {
        validator.check(profileFields['visibility'], {'code': 400, 'msg': 'An invalid visibility option has been specified'}).isIn(_.values(AuthzConstants.visibility));
    }
    if (profileFields['timezone']) {
        validator.check(profileFields['timezone'], {'code': 400, 'msg': 'The specified timezone is invalid'}).isValidTimeZone();
        profileFields.timezone = TZ.getClosestSupportedTimezone(profileFields.timezone);
    }
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to update a user'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Only update existing users.
    getUser(ctx, userId, function(err, oldUser) {
        if (err) {
            return callback(err);
        }

        // Only the current user or an admin can update a user.
        var principalResource = AuthzUtil.getResourceFromId(userId);
        if (ctx.user().id === userId || ctx.user().isAdmin(principalResource.tenantAlias)) {
            PrincipalsDAO.updatePrincipal(userId, profileFields, function(err) {
                if (err) {
                    return callback(err);
                }

                var newUser = PrincipalsUtil.createUpdatedUser(oldUser, profileFields);
                PrincipalsEmitter.emit(PrincipalsConstants.events.UPDATED_USER, ctx, newUser, oldUser);
                return getUser(ctx, userId, callback);
            });
        } else {
            callback({'code': 401, 'msg': 'You are not authorized to update this user\'s profile.'});
        }
    });
};

/**
 * Get a user from the DB
 *
 * @param  {Context}   ctx             The current context
 * @param  {String}    userId          The userId for the user you wish to retrieve
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    Error object containing the error message
 * @param  {User}      callback.user   The user object
 */
var getUser = module.exports.getUser = function(ctx, userId, callback) {

    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Must provide a user id'}).isValidId();
    validator.check(userId, {'code': 400, 'msg': 'The provided userId is not a user identifier'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PrincipalsUtil.getPrincipal(ctx, userId, callback);
};

/**
 * Get the full user profile of a user. In addition to the basic profile, this also fetches the
 * decorated properties.
 *
 * @param  {Context}    ctx             The current context
 * @param  {String}     userId          The id of the user whose full profile to fetch
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    Error object containing the error code and message
 * @param  {Object}     callback.user   The decorated user object
 */
var getFullUserProfile = module.exports.getFullUserProfile = function(ctx, userId, callback) {

    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Must provide a user id'}).isValidId();
    validator.check(userId, {'code': 400, 'msg': 'The provided userId is not a user identifier'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the basic user profile to decorate
    getUser(ctx, userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Keep track of how many decorators still need to return
        var numDecorators = _.keys(fullUserProfileDecorators).length;
        if (numDecorators === 0) {
            return callback(null, user);
        }

        // Hold all decorations for the user profile until we've collected them all
        var decorations = {};

        /*!
         * Complete one iteration of the decorators loop. Will invoke the method callback when all decorations have completed
         */
        var _finishDecorator = function() {
            numDecorators--;
            if (numDecorators === 0) {
                // Apply all the decorations to the user object
                return callback(null, _.extend(user, decorations));
            }
        };

        // Concurrently apply all decorators to the user object
        _.each(fullUserProfileDecorators, function(decorator, namespace) {
            if (user[namespace] !== undefined) {
                log().warn('Skipping full user profile decorator "%s" which overwrites an existing user profile value', namespace);
                return _finishDecorator();
            }

            decorator(ctx, clone(user), function(err, decoration) {
                if (err) {
                    log().warn({'err': err}, 'Skipping decorator because of an error in the decoration method');
                    return _finishDecorator();
                } else if (decoration === undefined) {
                    // If the decoration wasn't specified, do not apply it to the decorations. However null is a valid
                    // value
                    return _finishDecorator();
                }

                decorations[namespace] = decoration;
                return _finishDecorator();
            });
        });
    });
};

/**
 * Gets the me feed for the current user, if anonymous returns 'anon': true
 * If logged in returns structured me feed object in the callback
 *
 *     {
 *         "profilePath": "/person/u:global:bert",
 *         "id": "u:global:bert",
 *         "displayName": "Bert Pareyn",
 *         "publicAlias": "Bert the Merciful"
 *         "visibility": "private",
 *         "isTenantAdmin": true,
 *         "isGlobalAdmin": false,
 *         "resourceType": "user"
 *         "extra": {
 *             <Extra basic profile fields>
 *         },
 *         "locale": {
 *             "locale": "en_GB",
 *             "timezone": {
 *                 "name": "Europe/London",
 *                 "offset": 1
 *             }
 *         }
 *     }
 *
 * If error returns error object
 *
 * @param  {Context}   ctx            The current context
 * @param  {Function}  callback       Standard callback function
 * @param  {Object}    callback.err   Error object containing the error message
 * @param  {Object}    callback.data  The me feed data for the user
 */
var getMe = module.exports.getMe = function(ctx, callback) {
    if (!ctx.user()) {
        return callback({'code': 200,'msg': {
                'anon': true,
                'tenant': ctx.tenant().compact()
            }
        });
    }

    getUser(ctx, ctx.user().id, function(err, data) {
        if (err) {
            return callback(err);
        }

        // Calculate timezone offset in hours.
        var now = new TZ.Date(ctx.user().timezone);
        var offset = -1 * now.getTimezoneOffset() / 60;

        data.isTenantAdmin = ctx.user().isTenantAdmin(ctx.user().tenant.alias);
        data.isGlobalAdmin = ctx.user().isGlobalAdmin();

        data.locale = {
            'locale': ctx.user().locale,
            'timezone': {
                'name': ctx.user().timezone,
                'offset': offset
            }
        };

        callback(null, data);
    });
};

/**
 * Set a flag that indicates whether a user is a tenant admin.
 * The ctx user must be a tenant or global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant
 * @param  {User}      principalId     The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a tenant admin
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    Error object containing the error message
 */
var setTenantAdmin = module.exports.setTenantAdmin = function(ctx, principalId, isAdmin, callback) {
    var principalResource = AuthzUtil.getResourceFromId(principalId);
    if (ctx.user() && ctx.user().isAdmin(principalResource.tenantAlias)) {
        _setAdmin(ctx, 'admin:tenant', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Set a flag that indicates whether a user is a glbal admin.
 * The ctx user must be a global admin to be able to do this.
 *
 * @param  {Context}   ctx             Context that holds the tenant
 * @param  {User}      user            The user that needs the flag
 * @param  {Boolean}   isAdmin         Flag that indicates whether the provided user should be a global admin
 * @param  {Function}  callback        Standard callback function
 * @param  {Object}    callback.err    Error object containing the error message
 */
var setGlobalAdmin = module.exports.setGlobalAdmin = function(ctx, principalId, isAdmin, callback) {
    if (ctx.user() && ctx.user().isGlobalAdmin && ctx.user().isGlobalAdmin()) {
        _setAdmin(ctx, 'admin:global', isAdmin, principalId, callback);
    } else {
        return callback({'code': 401, 'msg': 'You do not have sufficient rights to make someone an admin.'});
    }
};

/**
 * Internal method that makes a user an admin. This method will do all the necessary validation
 * of the user ctx and passed in parameters.
 *
 * @param  {Context}        ctx             Context that holds the current user and tenant
 * @param  {String}         adminType       One of `admin:global` or `admin:tenant`
 * @param  {Boolean}        isAdmin         Flag that indicates whether this user should be an admin or not
 * @param  {String}         principalId     The uuid of the user that needs to be made an admin
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Error object containing the error message
 * @api private
 */
var _setAdmin = function(ctx, adminType, isAdmin, principalId, callback) {
    if (!PrincipalsUtil.isUser(principalId)) {
        return callback({'code': 400, 'msg': 'The provided principalId is not a user.'});
    }

    // Double-check that this user exists.
    getUser(ctx, principalId, function(err, user) {
        if (err) {
            return callback(err);
        }

        PrincipalsDAO.setAdmin(adminType, isAdmin, principalId, callback);
    });
};
