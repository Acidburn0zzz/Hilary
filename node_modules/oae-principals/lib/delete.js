/*!
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');
var Counter = require('oae-util/lib/counter');
var LibraryAPI = require('oae-library');
var OaeUtil = require('oae-util/lib/util');
var SearchAPI = require('oae-search');

var PrincipalsAPI = require('./api');
var PrincipalsConstants = require('./constants').PrincipalsConstants;
var PrincipalsUtil = require('./util');

var groupDeleteLog = require('oae-logger').logger('group-delete');
var groupRestoreLog = require('oae-logger').logger('group-restore');
var userDeleteLog = require('oae-logger').logger('user-delete');
var userRestoreLog = require('oae-logger').logger('user-restore');

// Manage all handlers that have been registered for performing operations when a principal has been
// deleted or restored in the system
var _groupDeleteHandlers = {};
var _groupRestoreHandlers = {};

// Keep track of in-flight local deletes for test purposes
var deleteCounter = new Counter();


/////////////////
// API METHODS //
/////////////////

/**
 * Register a handler that will be invoked when a group is deleted. This provides the ability to
 * destroy caches and associations as necessary when a group has been marked as deleted in the
 * system.
 *
 * Note that it is important for the handler to be idempotent, so that in the case of historical
 * bugs or system failures during delete processing, the handlers may be re-executed without a
 * detrimental impact on application data.
 *
 * @param  {String}         name                        The name of the handler. This is relevant for logging and diagnostic purposes
 * @param  {Function}       handler                     The handler that will be invoked when a group is deleted
 * @param  {Group}          handler.group               The group basic profile that was deleted
 * @param  {AuthzGraph}     handler.membershipsGraph    The full graph of memberships, containing all the groups to which the deleted group belonged either directly or indirectly
 * @param  {AuthzGraph}     handler.membersGraph        The full graph of members, containing all the groups and users that belonged to the deleted group either directly or indirectly
 * @param  {Function}       handler.callback            Standard consumer callback. Your handler method should invoke this callback when processing has completed
 * @param  {Object[]}       handler.callback.errs       An array of errors that occurred while trying to perform the group delete processing. Your handler should provide this to the caller so centralized error logging can be performed
 */
var registerGroupDeleteHandler = module.exports.registerGroupDeleteHandler = function(name, handler) {
    if (_groupDeleteHandlers[name]) {
        throw new Error(util.format('Attempted to register multiple group delete handlers for name "%s"', name));
    } else if (!_.isFunction(handler)) {
        throw new Error(util.format('Attempted to register non-function group delete handler for name "%s"', name));
    }

    _groupDeleteHandlers[name] = handler;
};

/**
 * Register a handler that will be invoked when a group is restored. This provides the ability to
 * restore caches and associations as necessary when a group has been unmarked as deleted in the
 * system.
 *
 * Note that it is important for the handler to be idempotent, so that in the case of historical
 * bugs or system failures during restore processing, the handlers may be re-executed without a
 * detrimental impact on application data.
 *
 * @param  {String}         name                        The name of the handler. This is relevant for logging and diagnostic purposes
 * @param  {Function}       handler                     The handler that will be invoked when a group is restored
 * @param  {Group}          handler.group               The group basic profile that was restored
 * @param  {AuthzGraph}     handler.membershipsGraph    The full graph of memberships, containing all the groups to which the restored group belonged either directly or indirectly
 * @param  {AuthzGraph}     handler.membersGraph        The full graph of members, containing all the groups and users that belonged to the restored group either directly or indirectly
 * @param  {Function}       handler.callback            Standard consumer callback. Your handler method should invoke this callback when processing has completed
 * @param  {Object[]}       handler.callback.errs       An array of errors that occurred while trying to perform the group restore processing. Your handler should provide this to the caller so centralized error logging can be performed
 */
var registerGroupRestoreHandler = module.exports.registerGroupRestoreHandler = function(name, handler) {
    if (_groupRestoreHandlers[name]) {
        throw new Error(util.format('Attempted to register multiple group restore handlers for name "%s"', name));
    } else if (!_.isFunction(handler)) {
        throw new Error(util.format('Attempted to register non-function group restore handler for name "%s"', name));
    }

    _groupRestoreHandlers[name] = handler;
};

/**
 * Invoke the group delete handlers, suggesting that the given group has been deleted
 *
 * @param  {Group}  group   The group for which to invoke the delete handlers
 */
var invokeGroupDeleteHandlers = module.exports.invokeGroupDeleteHandlers = function(group) {
    _invokeGroupHandlers(groupDeleteLog, _groupDeleteHandlers, group);
};

/**
 * Invoke the group restore handlers, suggesting that the given group has been restored
 *
 * @param  {Group}  group   The group for which to invoke the delete handlers
 */
var invokeGroupRestoreHandlers = module.exports.invokeGroupRestoreHandlers = function(group) {
    _invokeGroupHandlers(groupRestoreLog, _groupRestoreHandlers, group);
};

/**
 * Attach a listener that will be fired when there are no pending delete jobs to finish
 *
 * @param  {Function}   callback    Invoked when all delete tasks have completed. If there are no pending delete tasks, it will be invoked immediately
 */
var whenDeletesComplete = module.exports.whenDeletesComplete = function(callback) {
    deleteCounter.whenZero(callback);
};

/**
 * Generic group operation to gather the necessary group information and invoke the operation-
 * specific handlers
 *
 * @param  {Logger}     log         The logger ot use to report progress
 * @param  {Object}     handlers    The handlers to invoke
 * @param  {Group}      group       The group that is the target of the operation
 * @api private
 */
var _invokeGroupHandlers = function(log, handlers, group) {

    // Indicate we have an asynchronous task that needs to complete before deletes are finished
    // processing
    deleteCounter.incr();

    // Get both the members and memberships graph of the group so that the handlers can use that
    // information to determine if any associations need to be destroyed
    AuthzAPI.getPrincipalMembershipsGraph(group.id, function(err, membershipsGraph) {
        if (err) {
            return log().error({'err': err, 'groupId': group.id}, 'An unexpected error occurred while getting the authz memberships graph');
        }

        AuthzAPI.getAuthzMembersGraph([group.id], function(err, membersGraph) {
            if (err) {
                return log().error({'err': err, 'groupId': group.id}, 'An unexpected error occurred while getting the authz members graph');
            }

            // Get the potentially asynchronous handler operations running
            _invokeHandlers(log, handlers, group, membershipsGraph, membersGraph);

            // Indicate we have finished the asynchronous task of acquiring memerships and members
            // graphs
            deleteCounter.decr();
        });
    });
};

/**
 * Generic operation to invoke the given handlers, reporting errors or success with the given named
 * logger
 *
 * @param  {Logger}         log         The logger to use to report progress
 * @param  {Object}         handlers    The handler functions keyed by their handler name, indicating which handlers to invoke
 * @param  {User|Group}     principal   The user or group that was the target of the operation
 * @param  {Object...}      args...     A variable number of arguments for the handler depending on its type
 * @api private
 */
var _invokeHandlers = function(log, handlers, principal /*, args... */) {
    var args = Array.prototype.slice.call(arguments);
    // The arguments for the handler (including the `principal`) start from the 2nd argument and
    // continue until the end of the arguments list
    var handlerArgs = args.slice(2);

    // Invoke each handler
    _.each(handlers, function(handler, name) {
        // Increment the delete counter, as all handlers need to complete before we can indicate
        // that we have 0 pending delete jobs
        deleteCounter.incr();

        // Add the callback function to the handlerArgs
        var thisHandlerArgs = handlerArgs.concat(function(errs) {
            // Decrement the delete counter to indicate we've finished processing this handler
            deleteCounter.decr();

            if (!_.isEmpty(errs)) {
                return log().error({'principalId': principal.id, 'handlerName': name, 'errs': errs}, 'Error(s) occurred while trying to process a handler');
            }

            return log().info({'principalId': principal.id, 'handlerName': name}, 'Successfully processed handler');
        });

        // Invoke the handler with our arguments array
        handler.apply(handler, thisHandlerArgs);
    });
};


////////////
// EVENTS //
////////////

/*!
 * When a group is deleted, we must invoke the handlers that were registered to be triggered when
 * a group is deleted
 */
PrincipalsAPI.on(PrincipalsConstants.events.DELETED_GROUP, function(ctx, group) {
    // Invoke all group delete handlers
    invokeGroupDeleteHandlers(group);
});

/*!
 * When a group is restored, we must invoke the handlers that were registered to be triggered when
 * a group is restored
 */
PrincipalsAPI.on(PrincipalsConstants.events.RESTORED_GROUP, function(ctx, group) {
    // Invoke all group restore handlers
    invokeGroupRestoreHandlers(group);
});


/////////////////////
// DELETE HANDLERS //
/////////////////////

/**
 * Handler to invalidate the memberships libraries of all user ids in the group's memberships graph
 *
 * @param  {Group}          group               The group that needs to be invalidated
 * @param  {AuthzGraph}     membershipsGraph    The graph of group memberships of the group
 * @param  {AuthzGraph}     membersGraph        The graph of group members of the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object[]}       callback.errs       All errs that occurred while trying to invalidate the group memberships library
 * @api private
 */
var _handleInvalidateMembershipsLibraries = function(group, membershipsGraph, membersGraph, callback, _errs, _userIds) {
    _userIds = _userIds || _.chain(membersGraph.getNodes()).pluck('id').filter(PrincipalsUtil.isUser).value();
    if (_.isEmpty(_userIds)) {
        return callback(_errs, _userIds);
    }

    // Purge the memberships library for the next user
    var userId = _userIds.shift();
    LibraryAPI.Index.purge(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, userId, function(err) {
        if (err) {
            _errs = _errs || [];
            _errs.push(err);
        }

        return _handleInvalidateMembershipsLibraries(group, membershipsGraph, membersGraph, callback, _errs, _userIds);
    });
};

/**
 * Handler to invoke the search tasks required to invalidate search documents necessary
 *
 * @param  {Group}          group               The group that needs to be invalidated
 * @param  {AuthzGraph}     membershipsGraph    The graph of group memberships of the group
 * @param  {AuthzGraph}     membersGraph        The graph of group members of the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object[]}       callback.errs       All errs that occurred while trying to fire the search update tasks, if any
 * @api private
 */
var _handleInvalidateSearch = function(group, membershipsGraph, membersGraph, callback) {
    // All members (direct and indirect, users and groups) of the group that was deleted need to
    // have their memberships child search documents invalidated
    var groupAndUserIds =
        _.chain(membersGraph.getNodes())
            .pluck('id')
            .filter(AuthzUtil.isPrincipalId)
            .without(group.id)
            .partition(AuthzUtil.isGroupId)
            .value();
    var memberGroupIds = groupAndUserIds[0];
    var memberUserIds = groupAndUserIds[1];

    // Create the index task that will tell search to update the deleted group's resource document
    var resourceGroupIndexTask = [{'id': group.id}];

    // Create the index tasks that will tell search which resource's memberships document to update
    var memberGroupIndexTasks = _.map(memberGroupIds, function(groupId) {
        return {'id': groupId};
    });

    var memberUserIndexTasks = _.map(memberUserIds, function(userId) {
        return {'id': userId};
    });

    // The index operation that tells search to update only the resource document of the target
    // resources. This is needed for the group being deleted only
    var resourceIndexOp = {'resource': true};

    // The index operation that tells search to only update the memberships child document of the
    // target resources
    var membershipsIndexOp = {
        'children': {
            'resource_memberships': true
        }
    };

    var allErrs = null;

    // Update the resource document of the group that was deleted so its `deleted` flag may be
    // set/unset for the updated delete date
    SearchAPI.postIndexTask('group', resourceGroupIndexTask, resourceIndexOp, function(err) {
        if (err) {
            allErrs = _.union(allErrs, [err]);
        }

        // If there are group index tasks to invoke, do it
        OaeUtil.invokeIfNecessary(!_.isEmpty(memberGroupIndexTasks), SearchAPI.postIndexTask, 'group', memberGroupIndexTasks, membershipsIndexOp, function(err) {
            if (err) {
                allErrs = _.union(allErrs, [err]);
            }

            // If there are user index tasks to invoke, do it
            OaeUtil.invokeIfNecessary(!_.isEmpty(memberUserIndexTasks), SearchAPI.postIndexTask, 'user', memberUserIndexTasks, membershipsIndexOp, function(err) {
                if (err) {
                    allErrs = _.union(allErrs, [err]);
                }

                return callback(allErrs);
            });
        });
    });
};

/*!
 * Register delete handlers for internal principals operations
 */
registerGroupDeleteHandler('memberships-library', _handleInvalidateMembershipsLibraries);
registerGroupDeleteHandler('search', _handleInvalidateSearch);

/*!
 * Register restore handlers for internal principals operations
 */
registerGroupRestoreHandler('memberships-library', _handleInvalidateMembershipsLibraries);
registerGroupRestoreHandler('search', _handleInvalidateSearch);
