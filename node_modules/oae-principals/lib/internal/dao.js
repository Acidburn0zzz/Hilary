/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var sanitize = require('validator').sanitize;

var AuthzUtil = require('oae-authz/lib/util')
var Cassandra = require('oae-util/lib/cassandra');
var tz = require('oae-util/lib/tz');

var Group = require('oae-principals/lib/model').Group;
var User = require('oae-principals/lib/model').User;

/**
 * Query a principal row from storage and map it to the appropriate principal object (user or group).
 *
 * @param   {String}        principalId         The id of the principal to query
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {User|Group}    callback.prinicpal  The principal, either a user or a group, depending on the type of entity to which the id mapped. If the principal does not exist, this will be `null`
 */
var getPrincipal = module.exports.getPrincipal = function(principalId, callback) {
    Cassandra.runQuery('SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principalId = ?', [principalId], function (err, rows) {
        if (err) {
            return callback(err);
        } else if (rows[0].count === 1) {
            return callback();
        }

        return callback(null, rowToPrincipal(rows[0]));
    });
};

/**
 * Query a set of principal row from storage and map it to the appropriate principal object (user or group).
 *
 * @param   {String[]}      principalIds        The ids of the principals to query
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {Object[]}      callback.prinicpals A hash of principals, keyed by the principal id, and whose value is the principal (either user or group) to which the id mapped. If the value is `null` for a principal, it indicates that a principal did not exist
 */
var getPrincipals = module.exports.getPrincipals = function(principalIds, callback) {
    Cassandra.runQuery("SELECT * FROM Principals USING CONSISTENCY QUORUM WHERE principalId IN (?)", [principalIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        var principals = {};
        for (var i = 0; i < rows.length; i++) {
            principals[rows[i].get('principalId').value] = rowToPrincipal(rows[i]);
        }

        return callback(err, principals);
    });
}

/**
 * Creates a User or Group from a cassandra row.
 *
 * @param  {Row}        row     Cassandra Row
 * @return {User|Group}         A user or group object.
 * @api private
 */
var rowToPrincipal = function(row) {
    if (row.count <= 1) {
        return null;
    }
    return isGroup(row.get('principalId').value) ? rowToGroup(row) : rowToUser(row);
}

/**
 * Creates a Group from a Cassandra row.
 * 
 * @param  {Row}    row     Cassandra Row
 * @return {Group}          A group object.
 * @api private
 */
var rowToGroup = function(row) {
    var hash = Cassandra.rowToHash(row);
    return new Group(hash.tenant, hash.principalId, hash.alias, hash.name, hash.description, hash.visibility, hash.joinable);
};

/**
 * Creates a User from a Cassandra row.
 * 
 * @param  {Row}    row     Cassandra Row
 * @return {User}           A User object.
 * @api private
 */
var rowToUser = function(row) {
    var hash = Cassandra.rowToHash(row);
    var isGlobalAdmin = (row.get('admin:global') && sanitize(row.get('admin:global').value).toBooleanStrict());
    var isTenantAdmin = (row.get('admin:tenant') && sanitize(row.get('admin:tenant').value).toBooleanStrict());

    // Ensure that the timezone we're setting is something the app
    // can deal with.
    var timezone = hash.timezone;
    if (timezone === 'UTC') {
        timezone = 'Etc/UTC';
    }
    try {
        var date = new tz.Date(null, timezone);
        if (date.getTimezone === null) {
            throw new Error();
        }
    } catch (err) {
        log().warn({
            'err': err,
            'principalId': hash.principalId,
            'timezone': hash.timezone
        }, 'Error parsing stored timezone, defaulting to Etc/UTC');

        // We can't deal with this timezone.
        // default to UTC
        timezone = 'Etc/UTC';
    }

    var user = new User(hash.tenant, hash.principalId, hash.displayName, {
        visibility: hash.visibility,
        locale: hash.locale,
        timezone: timezone,
        publicAlias: hash.publicAlias,
        isGlobalAdmin: isGlobalAdmin,
        isTenantAdmin: isTenantAdmin
    });

    // The row might contain extra data that we wish to pass back.
    user.extra = {};
    var keys = _.keys(hash);
    var blacklist = ['tenant', 'principalId', 'displayName', 'visibility', 'locale', 'timezone', 'publicAlias', 'admin:global', 'admin:tenant'];
    for (var i = 0; i < keys.length; i++) {
        if (blacklist.indexOf(keys[i]) === -1) {
            user.extra[keys[i]] = hash[keys[i]];
        }
    }
    return user;
};

/**
 * Check if an identifier really is a group identifier.
 * 
 * @param  {String}  groupId    An identifier
 * @return {Boolean}            Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(groupId) {
    var principal = AuthzUtil.getPrincipalFromId(groupId);
    return (principal.principalType === "g");
};

/**
 * Check if an identifier really is a user identifier.
 * 
 * @param  {String}  userId     An identifier
 * @return {Boolean}            Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(userId) {
    var principal = AuthzUtil.getPrincipalFromId(userId);
    return (principal.principalType === "u");
};
