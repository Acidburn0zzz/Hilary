/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzDelete = require('oae-authz/lib/delete');
var LibraryAPI = require('oae-library');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchUtil = require('oae-search/lib/util');

var PrincipalsEmitter = require('oae-principals/lib/internal/emitter');
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

var log = require('oae-logger').logger('principals-memberslibrary');

/////////
// API //
/////////

/**
 * Get the ids of the members in the members library of a group
 *
 * @param  {Group}      group                           The group whose members library to list
 * @param  {String}     visibility                      The effective library visibility to list
 * @param  {Object}     [opts]                          Optional arguments for listing the library items
 * @param  {String}     [opts.start]                    The token that indicates from where to start listing items
 * @param  {Number}     [opts.limit]                    The maximum number of items to list
 * @param  {Function}   callback                        Standard callback function
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {String[]}   callback.memberEntries          The member entries in the library
 * @param  {String}     callback.memberEntries[i].id    The id of the member principal in the group
 * @param  {String}     callback.memberEntries[i].role  The role of the member principal in the group
 * @param  {String}     callback.nextToken              The token to use for the `start` parameter for the next invocation to get the next page of results. If `null`, indicates that there are no more items to list
 */
var list = module.exports.list = function(group, visibility, opts, callback) {
    LibraryAPI.Index.list(PrincipalsConstants.library.MEMBERS_INDEX_NAME, group.id, visibility, opts, function(err, entries, nextToken) {
        if (err) {
            return callback(err);
        }

        var memberEntries = _.map(entries, function(entry) {
            return {'id': entry.resourceId, 'role': entry.value};
        });

        return callback(null, memberEntries, nextToken);
    });
};


///////////////////
// REGISTRATIONS //
///////////////////

/*!
 * Register a library indexer that can provide resources to reindex the members library
 */
LibraryAPI.Index.registerLibraryIndex(PrincipalsConstants.library.MEMBERS_INDEX_NAME, {
    'pageResources': function(libraryId, start, limit, callback) {
        AuthzAPI.getAuthzMembers(libraryId, start, limit, function(err, memberEntries) {
            if (err) {
                return callback(err);
            }

            PrincipalsDAO.getPrincipals(_.pluck(memberEntries, 'id'), ['principalId', 'tenantAlias', 'visibility', 'smallPictureUri'], function(err, members) {
                if (err) {
                    return callback(err);
                }

                var resources = _.map(memberEntries, function(memberEntry) {
                    var member = members[memberEntry.id];
                    var role = memberEntry.role;
                    return {
                        'rank': _getMembersLibraryRank(member, role),
                        'resource': member,
                        'value': role
                    };
                });

                return callback(null, resources);
            });
        });
    }
});

/*!
 * Register a library search for group members
 */
LibraryAPI.Search.registerLibrarySearch('group-members-library', ['user', 'group'], {
    'association': {
        'name': AuthzConstants.search.MAPPING_RESOURCE_MEMBERSHIPS,
        'field': 'direct_memberships'
    }
});


////////////
// EVENTS //
////////////

/*!
 * When a user updates their profile or visibility, we have to update their rank in the members
 * libraries to which they belong
 */
PrincipalsEmitter.on(PrincipalsConstants.events.UPDATED_USER, function(ctx, updatedUser, oldUser) {
    // If there is no change in state of their profile picture or visibility, we don't have to make
    // any updates
    if (!_xor(updatedUser.smallPictureUri, oldUser.smallPictureUri) &&
        oldUser.visibility === updatedUser.visibility) {
        return;
    }

    // If the user updated their profile picture, we need to recalculate their rank for every group
    // members library to which they belong
    AuthzAPI.getAllRolesForPrincipalAndResourceType(updatedUser.id, AuthzConstants.resourceTypes.GROUP, function(err, allRoles) {
        if (err) {
            // We should log that an error happened, but we shouldn't fail the user update process
            // if members libraries didn't update properly
            return log().error({'err': err, 'userId': user.id}, 'An error occurred while trying to update all members libraries to which a user belongs');
        }

        var entries = _.map(allRoles, function(groupRole) {
            return {
                'id': groupRole.id,
                'oldRank': _getMembersLibraryRank(oldUser, groupRole.role),
                'newRank': _getMembersLibraryRank(newUser, groupRole.role),
                'resource': newUser,
                'value': groupRole.role
            };
        });

        return LibraryAPI.Index.update(PrincipalsConstants.library.MEMBERS_INDEX_NAME, entries);
    });
});

/*!
 * When a group's members are updated, we should update the members library
 */
PrincipalsEmitter.when(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, function(ctx, group, memberChanges, newMemberIds, updatedMemberIds, removedMemberIds, callback) {
    // When group members are updated (users are removed / roles updated, etc...) it's just easier
    // to purge the library unless there is good reason to do surgical library updates (e.g., known
    // performance issues with many group members updates)
    LibraryAPI.Index.purge(PrincipalsConstants.library.MEMBERS_INDEX_NAME, group.id, function(err) {
        if (err) {
            log().error({'err': err, 'groupId': group.id}, 'An unexpected error occurred trying to purge a group members library');
            return callback(err);
        }

        return callback();
    });
});

/*!
 * When someone joins a group, we should add them to the group's members library
 */
PrincipalsEmitter.when(PrincipalsConstants.events.JOINED_GROUP, function(ctx, group, joinRole, callback) {
    var entry = {
        'id': group.id,
        'rank': _getMembersLibraryRank(ctx.user(), joinRole),
        'resource': ctx.user(),
        'value': joinRole
    };

    LibraryAPI.Index.insert(PrincipalsConstants.library.MEMBERS_INDEX_NAME, [entry], function(err) {
        if (err) {
            log().error({'err': err, 'groupId': group.id, 'userId': ctx.user().id}, 'An unexpected error occurred trying to insert a user into a group members library');
            return callback(err);
        }

        return callback();
    });
});

/*!
 * When someone leaves a group, we should remove them from the group's members library. We don't
 * have to do this with a synchronous `when` handler because the user generally won't notice within
 * such small latency if the members library hasn't been updated
 */
PrincipalsEmitter.on(PrincipalsConstants.events.LEFT_GROUP, function(ctx, group, leaveRole) {
    var entry = {
        'id': group.id,
        'rank': _getMembersLibraryRank(ctx.user(), leaveRole),
        'resource': ctx.user()
    };

    LibraryAPI.Index.remove(PrincipalsConstants.library.MEMBERS_INDEX_NAME, [entry]);
});


////////////////////////
// INTERNAL FUNCTIONS //
////////////////////////

/**
 * Get the numeric rank of a principal given the principal and their role in the members library
 * they appear
 *
 * @param  {User|Group}     principal   The user or group for which to get their members library rank
 * @param  {String}         role        The role for the principal in the members library
 * @return {Number}                     The numeric rank to use for the principal in a members list
 * @api private
 */
var _getMembersLibraryRank = function(principal, role) {
    var rank = 0;
    if (role === PrincipalsConstants.roles.MANAGER && principal.smallPictureUri) {
        // Managers with profile pictures appear first
        rank = 3;
    } else if (!_.isEmpty(principal.picture)) {
        // Users with profile pictures appear second
        rank = 2;
    } else if (role === PrincipalsConstants.roles.MANAGER) {
        // Managers without profile pictures appear third
        rank = 1;
    }

    // Lastly, members without profile pictures appear at the bottom
    return rank;
};

/**
 * Convenience function to do a logical xor
 *
 * @param  {Object}     one     One item to xor
 * @param  {Object}     other   The other item to xor
 * @return {Boolean}            Whether or not the exclusive OR check passed
 * @api private
 */
var _xor = function(one, other) {
    return ((one && !other) || (!one && other));
};
