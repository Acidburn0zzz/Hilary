/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzDelete = require('oae-authz/lib/delete');
var LibraryAPI = require('oae-library');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchUtil = require('oae-search/lib/util');

var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsDelete = require('oae-principals/lib/delete');
var PrincipalsUtil = require('oae-principals/lib/util');

/*!
 * Register a library indexer that can provide resources to reindex the memberships library
 */
LibraryAPI.Index.registerLibraryIndex(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, {
    'pageResources': function(libraryId, start, limit, callback) {
        // For memberships, we always just get all of them because we need a full graph. So ignore
        // the suggested `limit` and just return all memberships when asked to page. The `null`
        // `nextToken` we give back will tell the pager to stop looking for more
        _getAllGroupMembershipsFromAuthz(libraryId, function(err, groupIdRoles) {
            if (err) {
                return callback(err);
            }

            // Get the properties of the groups in the library that are relevant to building the library
            PrincipalsDAO.getPrincipals(_.keys(groupIdRoles), ['principalId', 'tenantAlias', 'visibility', 'lastModified'], function(err, groups) {
                if (err) {
                    return callback(err);
                }

                // Map the groups to library entry items with just the properties needed to populate
                // the library index
                var resources = _.map(groups, function(group) {
                    return {
                        'rank': group.lastModified,
                        'resource': group,
                        'value': groupIdRoles[group.id]
                    };
                });

                return callback(null, resources);
            });
        });
    }
});

/*!
 * Register a library search that will search a principal's group memberships
 */
LibraryAPI.Search.registerLibrarySearch('memberships-library', ['group'], {
    'searches': {
        'private': function(ctx, libraryOwner, opts, callback) {
            // The memberships library search is in essence a graph index, which our search platform
            // does not support. In its place, we will get all our memberships from the memberships
            // library and simply throw them at search to join onto :(
            _getAllGroupMembershipsFromLibrary(libraryOwner.id, function(err, groupIds) {
                if (err) {
                    return callback(err);
                }

                // Target the full set of groups that are in this user's memberships to search through
                return callback(null, SearchUtil.filterAnd(
                    SearchUtil.filterTerm('_type', SearchConstants.search.MAPPING_RESOURCE),
                    SearchUtil.filterTerms('resourceType', ['group']),
                    SearchUtil.filterIds(groupIds)
                ));
            });
        }
    }
});

/**
 * Get all the group memberships for a principal from the memberships library. This index is built
 * VIA `_getAllGroupMembershipsFromAuthz` but can be thought of as an indirect memberships cache
 * that takes into consideration deleted groups.
 *
 * @param  {String}     principalId             The id of the principal whose memberships to get
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {String[]}   callback.memberships    The ids of the groups of which the principal is directly or indirectly a member
 * @api private
 */
var _getAllGroupMembershipsFromLibrary = function(principalId, callback, _groupIds, _nextToken) {
    _groupIds = _groupIds || [];
    if (_nextToken === null) {
        return callback(null, _groupIds);
    }

    // Get the next batch of memberships from the library
    var opts = {'start': _nextToken, 'limit': 100};
    LibraryAPI.Index.list(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, principalId, AuthzConstants.visibility.PRIVATE, opts, function(err, entries, nextToken) {
        if (err) {
            return callback(err);
        }

        _groupIds = _.union(_groupIds, _.pluck(entries, 'resourceId'));
        return _getAllGroupMembershipsFromLibrary(principalId, callback, _groupIds, nextToken);
    });
};

/**
 * Get all the group memberships for a principal from the AuthzAPI. This will take into
 * consideration group deletes that have happened in the system. Not only must deleted groups not
 * show in the library, indirect group membership that has been broken by a deleted group must not
 * show, which is the rationale of using the memberships graph
 *
 * @param  {String}     principalId             The id of the principal whose memberships to get
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.memberships    An object whose keys are the ids of the groups in the memberships graph, and the values are the applicable role principal has on the group
 * @api private
 */
var _getAllGroupMembershipsFromAuthz = function(principalId, callback) {
    // Get the full memberships graph from the AuthzAPI. Note that this includes all groups
    // including those that have since been marked as deleted
    AuthzAPI.getPrincipalMembershipsGraph(principalId, function(err, graph) {
        if (err) {
            return callback(err);
        }

        // Extract all group ids from the graph, excluding the principal id we actually searched for
        var allGroupIds = _.chain(graph.getNodes())
            .pluck('id')
            .without(principalId)
            .value();

        // Determine which of the groups in the memberships graph have been deleted
        AuthzDelete.isDeleted(allGroupIds, function(err, deleted) {
            if (err) {
                return callback(err);
            }

            // Delete all group nodes from the graph that have been deleted
            _.chain(deleted)
                .keys()
                .each(function(deletedGroupId) {
                    graph.removeNode(deletedGroupId);
                });

            // The resulting membership will be all group nodes that are reachable VIA a full
            // outbound edge traversal ("member of") starting from the `principalId`
            var membershipIds = _.chain(graph.traverseOut(principalId))
                .pluck('id')
                .without(principalId)
                .value();

            // Delete all groups from the graph that did not have a path to the principal
            _.chain(graph.getNodes())
                .pluck('id')
                .filter(function(nodeId) {
                    return (!_.contains(membershipIds, nodeId));
                })
                .each(function(nodeId) {
                    graph.removeNode(nodeId);
                });

            // For the remaining nodes, get the maximum role available in their inbound edges, this
            // will tell us the applicable role the user has on the group
            var memberRoles = {};
            _.each(membershipIds, function(membershipId) {
                var hasManager = _.chain(graph.getInEdgesOf(membershipId))
                    .pluck('role')
                    .contains(PrincipalsConstants.roles.MANAGER)
                    .value();
                if (hasManager) {
                    memberRoles[membershipId] = PrincipalsConstants.roles.MANAGER;
                } else {
                    memberRoles[membershipId] = PrincipalsConstants.roles.MEMBER;
                }
            });

            return callback(null, memberRoles);
        });
    });
};


/////////////////////
// DELETE HANDLERS //
/////////////////////

/**
 * Handler to invalidate the memberships libraries of all user ids in the group's memberships graph
 *
 * @param  {Group}          group               The group that needs to be invalidated
 * @param  {AuthzGraph}     membershipsGraph    The graph of group memberships of the group
 * @param  {AuthzGraph}     membersGraph        The graph of group members of the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object[]}       callback.errs       All errs that occurred while trying to invalidate the group memberships library
 * @api private
 */
var _handleInvalidateMembershipsLibraries = function(group, membershipsGraph, membersGraph, callback, _errs, _userIds) {
    _userIds = _userIds || _.chain(membersGraph.getNodes()).pluck('id').filter(PrincipalsUtil.isUser).value();
    if (_.isEmpty(_userIds)) {
        return callback(_errs, _userIds);
    }

    // Purge the memberships library for the next user
    var userId = _userIds.shift();
    LibraryAPI.Index.purge(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, userId, function(err) {
        if (err) {
            _errs = _errs || [];
            _errs.push(err);
        }

        return _handleInvalidateMembershipsLibraries(group, membershipsGraph, membersGraph, callback, _errs, _userIds);
    });
};

/*!
 * Register group delete and restore handlers that invalidate memberships libraries so they can
 * be reconstructed with or without the group
 */
PrincipalsDelete.registerGroupDeleteHandler('memberships-library', _handleInvalidateMembershipsLibraries);
PrincipalsDelete.registerGroupRestoreHandler('memberships-library', _handleInvalidateMembershipsLibraries);
