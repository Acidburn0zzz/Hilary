/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var sanitize = require('validator').sanitize;
var util = require('util');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var TZ = require('oae-util/lib/tz');

var Group = require('./model').Group;
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var User = require('./model').User;
var VISIBILITY_OPTIONS = require('./model').VISIBILITY_OPTIONS;

/**
 * Gets a principal.
 * In case the principalId is a userId, Redis will be checked first. If it could not be
 * found there or if Redis failed to respond to the request, Cassandra will be checked.
 *
 * @param  {Context}    ctx                 The current context
 * @param  {String}     principalId         The ID of the principal that should be retrieved.
 * @param  {Function}   callback            A callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {Group|User} callback.principal  The asked for principal.
 */
var getPrincipal = module.exports.getPrincipal = function(ctx, principalId, callback) {
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        } else if (!principal) {
            return callback({'code': 404, 'msg': 'Couldn\'t find principal: ' + principalId});
        }

        generatePictureURLs(ctx, principal);

        if (isUser(principalId)) {
            hideUserData(ctx, principal);
        }

        return callback(null, principal);
    });
};

/**
 * Gets a set of principals (user or groups). This method *will* return an error if some of the principals
 * don't exist.
 *
 * @param  {Context}   ctx                         The current context
 * @param  {String[]}  principalIds                The ID of the principal that should be retrieved.
 * @param  {Object}    callback.err                If an unexpected systemic error occurred, or if any of the given principals did not exist
 * @param  {String[]}  callback.err.existing       The ids of the principals that existed
 * @param  {String[]}  callback.err.missing        The ids of the principals that did not exist
 * @param  {Object}    callback.principals         Object representing the retrieved principals. The keys will be the principal ids and the values will be the principal basic profiles
 */
var getPrincipals = module.exports.getPrincipals = function(ctx, principalIds, callback) {
    PrincipalsDAO.getPrincipals(principalIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        var principalValues = _.values(principals);
        for (var i = 0; i < principalValues.length; i++) {
            var principal = principalValues[i];
            generatePictureURLs(ctx, principal);
            if (isUser(principal.id)) {
                hideUserData(ctx, principal);
            }
        }

        return callback(null, principals);
    });
};

/**
 * Determines whether or not the principalId represents a group.
 *
 * @param  {String}  principalId    An identifier
 * @return {Boolean}                Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(principalId) {
    return PrincipalsDAO.isGroup(principalId);
};

/**
 * Determines whether or not the principalId represents a user.
 *
 * @param  {String}  principalId    An identifier
 * @return {Boolean}                Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(principalId) {
    return PrincipalsDAO.isUser(principalId);
};

/**
 * Hides sensitive user information that the (possibly anonymous) user in context does not have access to see.
 *
 * @param {Context}     ctx     The current context
 * @param {User}        user    The user object to hide as necessary
 * @api private
 */
var hideUserData = module.exports.hideUserData = function(ctx, user) {
    var isAnon = !ctx.user();
    var isLoggedIn = TenantsUtil.isLoggedIn(ctx, user.tenant);
    var isTargetUser = (!isAnon && ctx.user().id === user.id);
    var isAdmin = (!isAnon && ctx.user().isAdmin && ctx.user().isAdmin(user.tenant));

    if (isAdmin || isTargetUser) {
        return user;
    }

    // Hide the sensitive profile information if needed
    if ((user.visibility === VISIBILITY_OPTIONS.LOGGEDIN && !isLoggedIn) ||
        (user.visibility === VISIBILITY_OPTIONS.PRIVATE && !isTargetUser)) {
        // the user does not have access to see the 'private' portion of this user's info
        user.displayName = user.publicAlias;
        user.hidden = true;
        delete user.publicAlias;
        delete user.timezone;
        delete user.locale;
        delete user.extra;
        delete user.smallPicture;
        delete user.smallPictureUri;
        delete user.mediumPicture;
        delete user.mediumPictureUri;
        delete user.largePicture;
        delete user.largePictureUri;
    } else {
        // they have access to see private but are not the target user, avoid exposing the public alias unnecessarily
        delete user.publicAlias;
    }
};

//////////////////////////////
// ACTIVITY UTILITY METHODS //
//////////////////////////////

/**
 * Create the persistent user entity that can be transformed into an activity entity for the UI.
 *
 * @param   {String}    userId      The ID of the user
 * @param   {User}      [user]      The user that supplies the data for the entity
 * @return  {Object}                An object containing the entity data that can be transformed into a UI user activity entity
 */
var createPersistentUserActivityEntity = module.exports.createPersistentUserActivityEntity = function(userId, user) {
    var persistentEntity = {'objectType': 'user', 'user': user};
    persistentEntity[ActivityConstants.properties.OAE_ID] = userId;
    return persistentEntity;
};

/**
 * Create a user activity entity that can be used in an activity stream.
 *
 * @param   {Tenant}            tenant      The tenant of the user
 * @param   {String}            userId      The id of the user
 * @param   {User}              [user]      The user object. If not specified, the generated entity with be abbreviated with just the information available
 * @return  {ActivityEntity}                The activity entity that represents the given user data
 */
var transformPersistentUserActivityEntity = module.exports.transformPersistentUserActivityEntity = function(ctx, userId, user) {
    var tenant = ctx.tenant();

    var httpHost = 'http://' + tenant.host;
    var globalId = httpHost + '/api/user/' + userId;

    var opts = {'ext': {}};
    opts.ext[ActivityConstants.properties.OAE_ID] = userId;

    if (user) {
        hideUserData(ctx, user);
        generatePictureURLs(ctx, user);

        opts.displayName = user.displayName;
        if (!user.hidden) {
            opts.url = httpHost + '/user/' + userId;

            if (user.smallPicture) {
                opts.ext[ActivityConstants.properties.OAE_THUMBNAIL] = new ActivityModel.ActivityMediaLink(user.smallPicture, PrincipalsConstants.picture.size.SMALL , PrincipalsConstants.picture.size.SMALL);
            }

            if (user.mediumPicture) {
                opts.image = new ActivityModel.ActivityMediaLink(user.mediumPicture, PrincipalsConstants.picture.size.MEDIUM , PrincipalsConstants.picture.size.MEDIUM);
            }
        }

        opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = user.visibility;
    }

    return new ActivityModel.ActivityEntity('user', globalId, opts);
};

/**
 * Create the persistent group entity that can be transformed into an activity entity for the UI.
 *
 * @param   {String}    groupId     The ID of the group
 * @param   {Group}     [group]     The group that supplies the data for the entity. If not specified, only the minimal data will be returned for transformation.
 * @return  {Object}                An object containing the entity data that can be transformed into a UI group activity entity
 */
var createPersistentGroupActivityEntity = module.exports.createPersistentGroupActivityEntity = function(groupId, group) {
    var persistentEntity = {'objectType': 'group', 'group': group};
    persistentEntity[ActivityConstants.properties.OAE_ID] = groupId;
    return persistentEntity;
};

/**
 * Create a group activity entity that can be used in an activity stream.
 *
 * @param   {Tenant}            tenant      The tenant of the group
 * @param   {String}            groupId     The id of the group
 * @param   {User}              [group]     The group object. If not specified, the generated entity with be abbreviated with just the information available
 * @return  {ActivityEntity}                The activity entity that represents the given group data
 */
var transformPersistentGroupActivityEntity = module.exports.transformPersistentGroupActivityEntity = function(ctx, groupId, group) {
    var tenant = ctx.tenant();

    var httpHost = 'http://' + tenant.host;
    var globalId = httpHost + '/api/group/' + groupId;

    var opts = {'ext': {}};
    opts.ext[ActivityConstants.properties.OAE_ID] = groupId;

    if (group) {
        generatePictureURLs(ctx, group);

        var isJoinable = (group.joinable && group.joinable !== 'no');

        // TODO: When Issue #284 is merged, this will change to group.displayName
        opts.displayName = group.name;
        opts.url = httpHost + '/group/' + groupId;

        if (group.smallPicture) {
            opts.ext[ActivityConstants.properties.OAE_THUMBNAIL] = new ActivityModel.ActivityMediaLink(group.smallPicture, PrincipalsConstants.picture.size.SMALL , PrincipalsConstants.picture.size.SMALL);
        }

        if (group.mediumPicture) {
            opts.image = new ActivityModel.ActivityMediaLink(group.mediumPicture, PrincipalsConstants.picture.size.MEDIUM , PrincipalsConstants.picture.size.MEDIUM);
        }

        // Extension properties
        opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = group.visibility;
        opts.ext[ActivityConstants.properties.OAE_JOINABLE] = (isJoinable) ? 'yes' : 'no';
    }

    return new ActivityModel.ActivityEntity('group', globalId, opts);
};

/**
 * Generates picture URLs for a principal. The urls will be signed with the current user his tenant alias.
 * This will only sign the small and medium picture uri!
 *
 * @param {Context}     ctx         The current context
 * @param {Group|User}  principal   The principal to generate the picture URLs for.
 */
var generatePictureURLs = function(ctx, principal) {
    if (principal.smallPictureUri) {
        principal.smallPicture = getSignedPictureUrl(ctx.tenant().alias, principal.smallPictureUri);
    }
    if (principal.mediumPictureUri) {
        principal.mediumPicture = getSignedPictureUrl(ctx.tenant().alias, principal.mediumPictureUri);
    }

    // To avoid signing the large picture each time, we only sign it if the actual principal requests it.
    // TODO: Fix this up for groups after demo.
    if (principal.largePictureUri && ctx.user() && ctx.user().id == principal.id) {
        principal.largePicture = getSignedPictureUrl(ctx.tenant().alias, principal.largePictureUri);
    }
};

/**
 * Generates a url on which the picture can be downloaded.
 * The download link will expire around the second day of the next month so it can be cached for a while.
 * The url will only be valid on the current tenant.
 *
 * @param  {String}     tenant  The tenant alias on which this signature is valid.
 * @param  {String}     uri     The URI of the picture.
 * @return {String}             An URL where the picture can be downloaded.
 */
var getSignedPictureUrl = module.exports.getSignedPictureUrl = function(tenant, uri) {
    var now = new Date();
    var expiresAt = new Date(now.getFullYear(), now.getMonth(), 32);
    var sig = Signature.createExpiresAtSignature(tenant, expiresAt, uri);
    return util.format('/api/download/signed?uri=%s&signature=%s&expires=%s', uri, sig.signature, sig.expires);
};
