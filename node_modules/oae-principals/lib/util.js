/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var sanitize = require('validator').sanitize;
var ShortId = require('shortid');

var ActivityConstants = require('oae-activity/lib/constants').ActivityConstants;
var ActivityModel = require('oae-activity/lib/model');
var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzUtil = require('oae-authz/lib/util');
var Config = require('oae-config').config('oae-principals');
var ContentUtil = require('oae-content/lib/internal/util');
var LibraryAPI = require('oae-library');
var OaeUtil = require('oae-util/lib/util');
var Signature = require('oae-util/lib/signature');
var TenantsUtil = require('oae-tenants/lib/util');
var TZ = require('oae-util/lib/tz');

var Group = require('./model').Group;
var PrincipalsConstants = require('oae-principals/lib/constants').PrincipalsConstants;
var PrincipalsDAO = require('./internal/dao');
var User = require('./model').User;

/**
 * Get a principal (user or group)
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     principalId         The ID of the principal that should be retrieved.
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Group|User} callback.principal  The asked for principal.
 */
var getPrincipal = module.exports.getPrincipal = function(ctx, principalId, callback) {
    getPrincipals(ctx, [principalId], function(err, principals) {
        if (err) {
            return callback(err);
        } else if (!principals[principalId]) {
            return callback({'code': 404, 'msg': 'Could not find principal with id ' + principalId});
        }

        return callback(null, principals[principalId]);
    });
};

/**
 * Get a set of principals (user or groups). This method *will* return an error if some of the principals
 * don't exist
 *
 * @param  {Context}        ctx                                 Standard context object containing the current user and the current tenant
 * @param  {String[]}       principalIds                        The ID of the principal that should be retrieved
 * @param  {Object}         callback.err                        An error that occurred, if any
 * @param  {Object}         callback.err.existingPrincipals     Object representing the principals that existed in storage. The keys will be the principal ids and the values will be the user-friendly principal basic profiles
 * @param  {String[]}       callback.err.missingPrincipalIds    The ids of the principals that did not exist
 * @param  {Object}         callback.principals                 Object representing the retrieved principals. The keys will be the principal ids and the values will be the principal basic profiles
 */
var getPrincipals = module.exports.getPrincipals = function(ctx, principalIds, callback) {
    PrincipalsDAO.getPrincipals(principalIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        }

        _transformPrincipals(ctx, principals);

        return callback(null, principals);
    });
};

/**
 * Create a unique id for a group
 *
 * @param  {String}     tenantAlias     The alias of the tenant for which to generate the group id
 * @return {String}                     The id for the group
 */
var createGroupId = module.exports.createGroupId = function(tenantAlias) {
    return AuthzUtil.toId(AuthzConstants.principalTypes.GROUP, tenantAlias, ShortId.generate());
};

/**
 * Determine whether or not the given string represents a group id.
 *
 * @param  {String}  groupId    A string that may or may not be a group id
 * @return {Boolean}            Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(groupId) {
    return PrincipalsDAO.isGroup(groupId);
};

/**
 * Determine whether or not the given string represents a user id.
 *
 * @param  {String}  userId     A string that may or may not be a user id
 * @return {Boolean}            Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(userId) {
    return PrincipalsDAO.isUser(userId);
};

/**
 * Hide sensitive user information that the (possibly anonymous) user in context does not have access to see.
 *
 * If the current user has no access to the user, then the following will be scrubbed:
 *
 *  1. The displayName will be replaced by the publicAlias
 *  2. The following fields will be deleted
 *      ** publicAlias
 *      ** locale
 *      ** smallPicture
 *      ** smallPictureUri
 *      ** mediumPicture
 *      ** mediumPictureUri
 *      ** largePicture
 *      ** largePictureUri
 *
 * If the user has access but is not the user themself, the publicAlias is scrubbed from the user.
 *
 * @param  {Context}     ctx     Standard context object containing the current user and the current tenant
 * @param  {User}        user    The user object to hide as necessary
 * @api private
 */
var hideUserData = module.exports.hideUserData = function(ctx, user) {
    var isAnon = !(ctx.user());
    var isLoggedIn = TenantsUtil.isLoggedIn(ctx, user.tenant.alias);
    var isTargetUser = (!isAnon && ctx.user().id === user.id);
    var isAdmin = (!isAnon && ctx.user().isAdmin && ctx.user().isAdmin(user.tenant.alias));

    if (isAdmin || isTargetUser) {
        return user;
    }

    // Hide the sensitive profile information if the user has limited access
    if ((user.visibility === AuthzConstants.visibility.LOGGEDIN && !isLoggedIn) ||
        (user.visibility === AuthzConstants.visibility.PRIVATE && !isTargetUser)) {

        user.displayName = user.publicAlias;
        user.picture = {};

        // The profile path should be removed from the user object as well. This will tell the UI
        // when to offer a link to the profile page and when not to
        delete user.profilePath;
    }

    // Always delete these guys if it is not the target user or admin
    delete user.acceptedTC;
    delete user.email;
    delete user.emailPreference;
    delete user.locale;
    delete user.notificationsUnread;
    delete user.notificationsLastRead;
    delete user.publicAlias;
};

/**
 * Given a user object, apply the given set of basic profile updates and return the updated user.
 *
 * @param  {User}      user         The user object on which to apply the updates
 * @param  {Object}    fieldUpdates An object of fieldKey -> value of the field updates to apply to the user object
 * @return {User}                   The updated user with all field updates applied
 */
var createUpdatedUser = module.exports.createUpdatedUser = function(user, fieldUpdates) {
    var newDisplayName = fieldUpdates.displayName || user.displayName;
    var newEmail = fieldUpdates.email || user.email;
    var newUser = new User(user.tenant.alias, user.id, newDisplayName, newEmail, {
        'visibility': fieldUpdates.visibility || user.visibility,
        'emailPreference': fieldUpdates.emailPreference || user.emailPreference,
        'locale': fieldUpdates.locale || user.locale,
        'publicAlias': fieldUpdates.publicAlias || user.publicAlias,
        'notificationsUnread': fieldUpdates.notificationsUnread || user.notificationsUnread,
        'notificationsLastRead': fieldUpdates.notificationsLastRead || user.notificationsLastRead,
        'acceptedTC': fieldUpdates.acceptedTC || user.acceptedTC,
        'isGlobalAdmin': user.isGlobalAdmin(),
        'isTenantAdmin': user.isTenantAdmin(user.tenant.alias)
    });

    return newUser;
};

//////////////////////////////
// ACTIVITY UTILITY METHODS //
//////////////////////////////

/**
 * Create the persistent user entity that can be transformed into an activity entity for the UI.
 *
 * @param  {String}    userId      The ID of the user
 * @param  {User}      [user]      The user that supplies the data for the entity
 * @return {Object}                An object containing the entity data that can be transformed into a UI user activity entity
 */
var createPersistentUserActivityEntity = module.exports.createPersistentUserActivityEntity = function(userId, user) {
    return new ActivityModel.ActivityEntity('user', userId, user.visibility, {'user': user});
};

/**
 * Transform a persisted user activity entity that can be used in an activity stream The returned activity entity will be
 * output in the `activitystrea.ms`-compliant data model
 *
 * For more details on the transformed entity model, @see ActivityAPI#registerActivityEntityType
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         userId              The id of the user
 * @param  {User}           [user]              The user object. If not specified, the generated entity with be abbreviated with just the information available
 * @return {ActivityEntity}                     The activity entity that represents the given user data
 */
var transformPersistentUserActivityEntity = module.exports.transformPersistentUserActivityEntity = function(ctx, userId, user) {
    var tenant = ctx.tenant();
    var baseUrl = TenantsUtil.getBaseUrl(tenant);
    var globalId = baseUrl + '/api/user/' + userId;

    var opts = {'ext': {}};
    opts.ext[ActivityConstants.properties.OAE_ID] = userId;

    if (user) {
        hideUserData(ctx, user);

        // Signed user profile picture URLs will last forever
        _generatePictureURLs(ctx, user, -1);

        opts.displayName = user.displayName;
        if (user.profilePath) {
            opts.url = baseUrl + user.profilePath;

            if (user.picture.small) {
                opts.ext[ActivityConstants.properties.OAE_THUMBNAIL] = new ActivityModel.ActivityMediaLink(user.picture.small, PrincipalsConstants.picture.size.SMALL , PrincipalsConstants.picture.size.SMALL);
            }

            if (user.picture.medium) {
                opts.image = new ActivityModel.ActivityMediaLink(user.picture.medium, PrincipalsConstants.picture.size.MEDIUM , PrincipalsConstants.picture.size.MEDIUM);
            }
        }

        opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = user.visibility;
        opts.ext[ActivityConstants.properties.OAE_PROFILEPATH] = user.profilePath;
    }

    return new ActivityModel.ActivityEntity('user', globalId, user.visibility, opts);
};

/**
 * Transform a persisted user activity entity that can be used in an activity stream. The user property will be taken from
 * the persisted entity, scrubbed and returned as the "transformed entity"
 *
 * @param  {Context}    ctx     Standard context object containing the current user and the current tenant
 * @param  {String}     userId  The id of the user
 * @param  {User}       [user]  The user object. If not specified, the generated entity with be abbreviated with just the information available
 * @return {User}               The scrubbed user object
 */
var transformPersistentUserActivityEntityToInternal = module.exports.transformPersistentUserActivityEntityToInternal = function(ctx, userId, user) {
    if (user) {
        // Signed user profile picture URLs will last forever
        hideUserData(ctx, user);
        _generatePictureURLs(ctx, user, -1);
        return user;
    } else {
        return {'id': userId};
    }
};

/**
 * Create the persistent group entity that can be transformed into an activity entity for the UI
 *
 * @param  {String}    groupId     The ID of the group
 * @param  {Group}     [group]     The group that supplies the data for the entity. If not specified, only the minimal data will be returned for transformation.
 * @return {Object}                An object containing the entity data that can be transformed into a UI group activity entity
 */
var createPersistentGroupActivityEntity = module.exports.createPersistentGroupActivityEntity = function(groupId, group) {
    return new ActivityModel.ActivityEntity('group', groupId, group.visibility, {'group': group});
};

/**
 * Transform a persisted group activity entity that can be used in an activity stream
 *
 * For more details on the transformed entity model, @see ActivityAPI#registerActivityEntityType
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}         groupId             The id of the group
 * @param  {Group}          [group]             The group object. If not specified, the generated entity with be abbreviated with just the information available
 * @return {ActivityEntity}                     The activity entity that represents the given group data
 */
var transformPersistentGroupActivityEntity = module.exports.transformPersistentGroupActivityEntity = function(ctx, groupId, group) {
    var tenant = ctx.tenant();
    var baseUrl = TenantsUtil.getBaseUrl(tenant);

    // Note that the globalId is used as a canonical reference and should not depend on whether or not
    // the tenant is using http or https
    var globalId = 'http://' + tenant.host + '/api/group/' + groupId;

    var opts = {'ext': {}};
    opts.ext[ActivityConstants.properties.OAE_ID] = groupId;

    if (group) {
        // Signed group picture URLs will last forever
        _generatePictureURLs(ctx, group, -1);

        opts.displayName = group.displayName;
        opts.url = baseUrl + group.profilePath;

        if (group.picture.small) {
            opts.ext[ActivityConstants.properties.OAE_THUMBNAIL] = new ActivityModel.ActivityMediaLink(group.picture.small, PrincipalsConstants.picture.size.SMALL , PrincipalsConstants.picture.size.SMALL);
        }

        if (group.picture.medium) {
            opts.image = new ActivityModel.ActivityMediaLink(group.picture.medium, PrincipalsConstants.picture.size.MEDIUM , PrincipalsConstants.picture.size.MEDIUM);
        }

        // Extension properties
        opts.ext[ActivityConstants.properties.OAE_VISIBILITY] = group.visibility;

        if (!group.deleted) {
            opts.ext[ActivityConstants.properties.OAE_PROFILEPATH] = group.profilePath;
        }

        opts.ext[ActivityConstants.properties.OAE_JOINABLE] = group.joinable;
    }

    return new ActivityModel.ActivityEntity('group', globalId, group.visibility, opts);
};

/**
 * Transform a persisted group activity entity that can be used in an activity stream. The group property will be
 * taken from the persisted entity, scrubbed and returned as the "transformed entity"
 *
 * For more details on the transformed entity model, @see ActivityAPI#registerActivityEntityType
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current tenant
 * @param  {String}     groupId             The id of the group
 * @param  {Group}      [group]             The group object. If not specified, the generated entity with be abbreviated with just the information available
 * @return {Group}                          The group object
 */
var transformPersistentGroupActivityEntityToInternal = module.exports.transformPersistentGroupActivityEntityToInternal = function(ctx, groupId, group) {
    if (group) {
        // Signed group picture URLs will last forever
        _generatePictureURLs(ctx, group, -1);
        return group;
    } else {
        return {'id': groupId};
    }
};


/**
 * Given an authz change on a group, update all the membership libraries that are involved
 *
 * @param  {Group}          group                   The group that was changed
 * @param  {Number}         [oldLastModified]       The timestamp when the group was previously changed. If this is left `null`, the group will not be moved to the top of the group membership libraries for the members of the group
 * @param  {String[]}       newMemberIds            The ids of the principals that were added to the group
 * @param  {String[]}       removedMemberIds        The ids of the principals that were removed from the group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 * @api private
 */
var touchMembershipLibraries = module.exports.touchMembershipLibraries = function(group, oldLastModified, newMemberIds, removedMemberIds, callback) {
    // Get the ancestors of this group. Since a user's membership library contains all indirect
    // group memberships, we need to insert/update/remove all indirect group ancestors
    _getAncestors(group, function(err, ancestorGroups) {
        if (err) {
            return callback(err);
        }

        // Create a set of groups that holds the group we changed and all its parents
        var changedGroup = _.extend({}, group, {'oldLastModified': oldLastModified});
        var groups = ancestorGroups.concat(changedGroup);

        // Insert the group (and its ancestors) into the membership libraries of the new members
        _insertMembershipsLibraries(groups, newMemberIds, function(err, explodedInsertedPrincipals) {
            if (err) {
                return callback(err);
            }

            // Remove the group (and its ancestors) from the membership libraries of the removed
            // principals
            _removeMembershipsLibraries(removedMemberIds, groups, function(err) {
                if (err) {
                    return callback(err);
                }

                // Update the membership libraries of all the other members of the changed group to
                // ensure it shows at the top of their membership library
                if (oldLastModified) {
                    return _updateMembershipsLibraries(changedGroup, explodedInsertedPrincipals, callback);
                } else {
                    return callback();
                }
            });
        });
    });
};

/**
 * Insert the given `groups` into the memberships libraries of `newMemberIds` AND
 * all the children of `newMemberIds`.
 *
 * @param  {Group}          groups                  The groups to insert into the membership libraries
 * @param  {String[]}       newMemberIds            The ids of the members that were added to the group
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {String[]}       callback.principals     The ids of the principals for which to update the membership libraries
 * @api private
 */
var _insertMembershipsLibraries = function(groups, newMemberIds, callback) {
    if (_.isEmpty(newMemberIds)) {
        return callback(null, []);
    }

    // Get all the children of the members we've added so we can insert the group
    // and its ancestors into their membership libraries
    _getAllChildren(newMemberIds, [], function(err, allChildren) {
        if (err) {
            return callback(err);
        }

        // The principals for which the groups will be inserted in their libraries
        var principalIds = allChildren.concat(newMemberIds);

        var entries = _.chain(groups)
            .map(function(group) {
                return _.map(principalIds, function(principalId) {
                    return {
                        'id': principalId,
                        'rank': group.lastModified,
                        'resource': group
                    };
                });
            })
            .flatten()
            .value();

        LibraryAPI.Index.insert(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, entries, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, allChildren);
        });
    });
};

/**
 * Update the group entries in the memberships libraries of the given member ids
 *
 * @param  {Group}          group                   The group to update in the libraries
 * @param  {String[]}       excludePrincipals       The principal ids for which the membership libraries should not be updated
 * @param  {Function}       callback                Standard callback function
 * @api private
 */
var _updateMembershipsLibraries = function(group, excludePrincipals, callback) {
    // Get the exploded members list of the group we've updated excluding any
    // principals we've dealth with earlier
    _getAllChildren([group.id], excludePrincipals, function(err, allChildren) {
        if (err) {
            return callback(err);
        }

        // The principals for which the groups will be updated in their libraries
        var principalIdsToUpdate = allChildren.concat(group.id);
        var entries = _.map(principalIdsToUpdate, function(principalId) {
            return {
                'id': principalId,
                'oldRank': group.oldLastModified,
                'newRank': group.lastModified,
                'resource': group
            };
        });


        // Update all the groups in the libraries of the updated members (and their children)
        LibraryAPI.Index.update(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, entries, function(err) {
            if (err) {
                log().error({
                    'err': err,
                    'group': group
                }, 'Unable to update a group in a principal\'s membership library');
            }

            return callback();
        });
    });
};

/**
 * Remove the group entries from the memberships libraries of the given member ids
 *
 * @param  {String[]}   removedMemberIds    The ids of the members for which the groups need to be removed from their membership libraries
 * @param  {Group[]}    groups              The groups that should be removed from the `removedMemberIds` their membership libraries
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _removeMembershipsLibraries = function(removedMemberIds, groups, callback) {
    if (_.isEmpty(removedMemberIds)) {
        return callback();
    }

    _getAllChildren(removedMemberIds, [], function(err, allChildren) {
        if (err) {
            return callback(err);
        }

        // The principals for which to remove the groups from their libraries
        var principalIds = allChildren.concat(removedMemberIds);

        // Gather all index removal entries to persist
        var entries = _.chain(groups)
            .map(function(group) {
                return _.map(principalIds, function(principalId) {
                    return {
                        'id': principalId,
                        'rank': group.oldLastModified || group.lastModified,
                        'resource': group
                    };
                });
            })
            .flatten()
            .value();

        // Remove the groups from the libraries of the removed members (and their children)
        LibraryAPI.Index.remove(PrincipalsConstants.library.MEMBERSHIPS_INDEX_NAME, entries, function(err) {
            if (err) {
                log().error({
                    'err': err,
                    'memberIds': removedMemberIds,
                    'groupIds': _.pluck(groups, 'id')
                }, 'Unable to remove groups from a principal\'s membership library');
            }

            return callback();
        });
    });
};

/**
 * Get a group's ancestors
 *
 * @param  {Group}          group               The group to retrieve the ancestors for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group[]}        callback.groups     The ancestor groups
 * @api private
 */
var _getAncestors = function(group, callback) {
    // Get all the ancestors of the group
    AuthzAPI.getPrincipalMembershipsGraph(group.id, function(err, graph) {
        if (err) {
            return callback(err);
        }

        // Extract the ids of all groups in the memberships list from the graph
        var membershipIds = _.chain(graph.getNodes()).pluck('id').without(group.id).value();

        // Get a light-weight group representation for each ancestor
        PrincipalsDAO.getPrincipals(membershipIds, ['principalId', 'tenantAlias', 'lastModified', 'visibility'], function(err, parentGroups) {
            if (err) {
                return callback(err);
            }

            parentGroups = _.values(parentGroups);
            return callback(null, parentGroups);
        });
    });
};

/**
 * Get all the children for a set of principals
 *
 * @param  {String[]}   principalIds        The ids of the principals to retrieve all children for
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {String[]}   callback.children   The ids of the principals that are a direct or indirect member of any of the given principal ids. The passed in principal ids will be included in this result set
 * @api private
 */
var _getAllChildren = function(principalIds, excludePrincipals, callback, _groupsToInvalidate, _allChildren) {
    _allChildren = _allChildren || [];
    _groupsToInvalidate = _groupsToInvalidate || _.filter(principalIds, AuthzUtil.isGroupId);

    // If there are no groups left to explode, we can remove the group from all the affected
    // member libraries
    if (_.isEmpty(_groupsToInvalidate)) {
        return callback(null, _allChildren);
    }

    // Get the next group to explode
    var groupId = _groupsToInvalidate.shift();

    // Get all of the members of the group, so they can be invalidated
    AuthzAPI.getAuthzMembers(groupId, null, 10000, function(err, members) {
        if (err) {
            return callback(err);
        }

        _.each(members, function(member) {
            // Groups need to be further exploded. In order to do this, we need to check whether or not the list
            // of groups that have already been invalidated and the list of groups that are queued up to be invalidated
            // don't contain this group, otherwise we'll invalidate the group twice.
            if (AuthzUtil.isGroupId(member.id) && !_.contains(_allChildren, member.id) && !_.contains(_groupsToInvalidate, member.id) && !_.contains(excludePrincipals, member.id)) {
                _groupsToInvalidate.push(member.id);
            }

            // The members can be invalidated
            if (!_.contains(_allChildren, member.id) && !_.contains(excludePrincipals, member.id)) {
                _allChildren.push(member.id);
            }
        });

        _getAllChildren(principalIds, excludePrincipals, callback, _groupsToInvalidate, _allChildren);
    });
};


/**
 * Given a set of principals, transform their model so the required UI-level information is
 * available
 *
 * @param  {Context}    ctx         Standard context object containing the current user and the current tenant
 * @param  {Object[]}   principals  The array of users and groups to transform
 * @api private
 */
var _transformPrincipals = function(ctx, principals) {
    _.each(principals, function(principal) {
        _generatePictureURLs(ctx, principal);
        if (isUser(principal.id)) {
            hideUserData(ctx, principal);
        }
    });
};

/**
 * Replace the URI properties with signed URL paths to actually download the files
 *
 * @param  {Context}        ctx         Standard context object containing the current user and the current tenant
 * @param  {Group|User}     principal   The principal for which to generate the picture URL paths
 * @param  {Number}         [duration]  The approximate time in seconds for which the generated picture URLs will be valid. Default: 1 week
 * @param  {Number}         [offset]    The minimum time in seconds for which the generated picture URLs will be valid. Default: 1 week
 * @api private
 */
var _generatePictureURLs = function(ctx, principal, duration, offset) {
    if (principal.picture.smallUri) {
        principal.picture.small = ContentUtil.getSignedDownloadUrl(ctx, principal.picture.smallUri, duration, offset);
        delete principal.picture.smallUri;
    }

    if (principal.picture.mediumUri) {
        principal.picture.medium = ContentUtil.getSignedDownloadUrl(ctx, principal.picture.mediumUri, duration, offset);
        delete principal.picture.mediumUri;
    }

    if (principal.picture.largeUri) {
        principal.picture.large = ContentUtil.getSignedDownloadUrl(ctx, principal.picture.largeUri, duration, offset);
        delete principal.picture.largeUri;
    }
};
