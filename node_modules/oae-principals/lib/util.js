/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzUtil = require('oae-authz/lib/util');

var Group = require('./model').Group;
var PrincipalsDAO = require('./internal/dao');
var User = require('./model').User;
var VISIBILITY_OPTIONS = require('./model').VISIBILITY_OPTIONS;

var tz = require('oae-util/lib/tz');

/**
 * Gets a principal from the DB and converts the returned data to the correct model (user or group).
 * 
 * @param  {Context}    ctx                 The current context
 * @param  {String}     principalId         The ID of the principal that should be retrieved.
 * @param  {Function}   callback            A callback method.
 * @param  {Object}     callback.err        An error object (if any)
 * @param  {User|Group} callback.principal  The asked for principal.
 */
var getPrincipal = module.exports.getPrincipal = function(ctx, principalId, callback) {
    PrincipalsDAO.getPrincipal(principalId, function(err, principal) {
        if (err) {
            return callback(err);
        } else if (!principal) {
            return callback({'code': 404, 'msg': "Couldn't find principal: " + principalId});
        }

        hidePrincipalData(ctx, principal);
        return callback(null, principal);
    });
};

/**
 * Gets a set of principals (user or groups). This method *will* throw an error if some of the principals
 * don't exist.
 *
 * @param  {Context}   ctx                         The current context
 * @param  {String[]}  principalIds                The ID of the principal that should be retrieved.
 * @param  {Function}  callback                    Standard callback function
 * @param  {Object}    callback.err                Error object containing the error message.
 * @param  {Object}    callback.principals         Object representing the retrieved principals. The keys will be the principal ids and the values will be the principal basic profiles
 */
var getPrincipals = module.exports.getPrincipals = function(ctx, principalIds, callback) {
    if (principalIds.length === 0) {
        return callback(null, {});
    }

    PrincipalsDAO.getPrincipals(principalIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        // aggregate the principalIds that did not map to principals and secure those that did, these will be returned as `null` in the hash
        var missingPrincipalIds = [];
        for (var principalId in principals) {
            if (!principals[principalId]) {
                missingPrincipalIds.push(principalId);
            } else {
                hidePrincipalData(ctx, principals[principalId]);
            }
        }

        if (missingPrincipalIds.length > 0) {
            return callback({'code': 400, 'msg': 'These principals could not be found: ' + missingPrincipalIds});
        }

        return callback(null, principals);
    });
};

/**
 * Check if a principal identifier is a group identifier.
 * 
 * @param  {String}  principalId    An identifier
 * @return {Boolean}                Whether or not the provided identifier is a group identifier.
 */
var isGroup = module.exports.isGroup = function(principalId) {
    return PrincipalsDAO.isGroup(principalId);
};

/**
 * Check if a principal identifier is a user identifier.
 * 
 * @param  {String}  principalId    An identifier
 * @return {Boolean}                Whether or not the provided identifier is a user identifier.
 */
var isUser = module.exports.isUser = function(principalId) {
    return PrincipalsDAO.isUser(principalId);
};

/**
 * Retrieves a principal from a row object. It performs all the visibility checks
 * and takes the current execution context into account.
 *
 * @param  {Context}       ctx  The current context
 * @param  {User|Group}         The User or Group object whose data to process and hide if necessary    
 * @return {User|Group}         A user or group object that is safe to return to the user in context
 * @api private
 */
var hidePrincipalData = function(ctx, principal) {
    if (PrincipalsDAO.isGroup(principal.id)) {
        // nothing gets hidden on group basic profiles
        return principal;
    } else {
        var user = principal;
        
        var isAnon = !ctx.user();
        var isTargetUser = (!isAnon && ctx.user().id === user.id);
        var isAdmin = (!isAnon && ctx.user().isAdmin && ctx.user().isAdmin(user.tenant));

        if (isAdmin || isTargetUser) {
            return user;
        }

        // Hide the sensitive profile information if needed
        if ((user.visibility === VISIBILITY_OPTIONS.LOGGEDIN && isAnon) ||
            (user.visibility === VISIBILITY_OPTIONS.PRIVATE && !isTargetUser)) {
            // the user does not have access to see the 'private' portion of this user's info
            user.displayName = user.publicAlias;
            delete user.publicAlias;
            delete user.timezone;
            delete user.locale;
        } else {
            // they have access to see private but are not the target user, avoid exposing the public alias unnecessarily
            delete user.publicAlias;
        }

        return user;
    }
};

