
var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var AuthzPermissions = require('oae-authz/lib/permissions');
var AuthzUtil = require('oae-authz/lib/util');
var EmitterAPI = require('oae-emitter');
var Invitation = require('oae-authz/lib/invitations/model').Invitation;
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-authz/lib/validator').Validator;

var ResourceConstants = require('oae-resource/lib/constants').ResourceConstants;


var ResourceActions = module.exports = new EmitterAPI.EventEmitter();

var create = module.exports.create = function(ctx, roles, createFn, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Only authenticated users can create a new resurce'}).isLoggedInUser(ctx);

    // Ensure all member ids are valid members
    var memberIds = _.keys(roles);
    _.each(memberIds, function(memberId) {
        if (!AuthzUtil.isPrincipalId(memberId)) {
            validator.check(memberId, {'code': 400, 'msg': 'Members must be either an email address or a valid princinpal id'}).isEmail();
        }
    });

    // Ensure there is at least one manager member in the list of roles
    var firstManagerRole = _.find(roles, function(role, memberId) {
        return (AuthzUtil.isPrincipalId(memberId) && role === 'manager');
    });
    validator.check(firstManagerRole, {'code': 400, 'msg': 'There must be at least one manager specified when creating a resource'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getTargetRoles(roles, function(err, principalRoles, emailRoles) {
        if (err) {
            return callback(err);
        }

        var targets = {'principalRoles': principalRoles, 'emailRoles': emailRoles};
        AuthzPermissions.canCreate(ctx, targets, function(err, members, emails) {
            if (err) {
                return callback(err);
            }

            createFn(function(err, resource) {
                if (err) {
                    return callback(err);
                }

                // Get all the results of the create function. There could be more than just the
                // main resource (e.g., content, revision) and we should retain them all
                var createFnResults = _.toArray(arguments).slice(1);

                // Apply the changes to the authz members, if any
                _applyMemberChanges(ctx, resource, members, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Apply the changes to the invitations, if any
                    _applyInvitationChanges(ctx, resource, emails, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Return to the caller, appending the members and emails changes to the
                        // create operation results
                        var args = _.union([null], createFnResults, [members, emails]);
                        return callback.apply(null, args);
                    });
                });
            });
        });
    });
};

var share = module.exports.share = function(ctx, resource, targetIds, role, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Only authenticated users can share a resurce'}).isLoggedInUser(ctx);
    validator.check(role, {'code': 400, 'msg': 'Must specify a valid role'}).isValidRole();
    validator.check(null, {'code': 400, 'msg': 'An invalid resource was provided'}).isResource(resource);

    var resourceAuthzId = null;
    var resourceId = null;
    if (resource) {
        resourceAuthzId = AuthzUtil.getAuthzId(resource);
        resourceId = resource.id;
    }

    _.each(targetIds, function(targetId) {
        if (!AuthzUtil.isPrincipalId(targetId)) {
            validator.check(targetId, {'code': 400, 'msg': 'Members must be either an email address or a valid princinpal id'}).isEmail();
        }
        validator.check(targetId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceAuthzId);
        validator.check(targetId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceId);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getTargets(targetIds, function(err, principals, emails) {
        if (err) {
            return callback(err);
        }

        var targets = {'principals': principals, 'emails': emails};
        AuthzPermissions.canShare(ctx, resource, targets, role, function(err, members, emails) {
            if (err) {
                return callback(err);
            }

            // Apply the changes to the authz members, if any
            _applyMemberChanges(ctx, resource, members, function(err) {
                if (err) {
                    return callback(err);
                }

                // Apply the changes to the invitations, if any
                _applyInvitationChanges(ctx, resource, emails, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, members, emails);
                });
            });
        });
    });
};

var setRoles = module.exports.setRoles = function(ctx, resource, roles, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Only authenticated users can share a resurce'}).isLoggedInUser(ctx);
    validator.check(null, {'code': 400, 'msg': 'An invalid resource was provided'}).isResource(resource);

    var resourceAuthzId = null;
    var resourceId = null;
    if (resource) {
        resourceAuthzId = AuthzUtil.getAuthzId(resource);
        resourceId = resource.id;
    }

    _.each(roles, function(role, memberId) {
        validator.check(role, {'code': 400, 'msg': 'An invalid role was provided'}).isValidRole();
        if (!AuthzUtil.isPrincipalId(memberId)) {
            validator.check(targetId, {'code': 400, 'msg': 'Members must be either an email address or a valid principal id'}).isEmail();
        }
        validator.check(memberId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceAuthzId);
        validator.check(memberId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceId);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getTargetRoles(roles, function(err, principalRoles, emailRoles) {
        if (err) {
            return callback(err);
        }

        var targets = {'principalRoles': principalRoles, 'emailRoles': emailRoles};
        AuthzPermissions.canSetRoles(ctx, resource, targets, function(err, members, emails) {
            if (err) {
                return callback(err);
            }


            // Apply the changes to the authz members, if any
            _applyMemberChanges(ctx, resource, members, function(err) {
                if (err) {
                    return callback(err);
                }

                // Apply the changes to the invitations, if any
                _applyInvitationChanges(ctx, resource, emails, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, members, emails);
                });
            });
        });
    });
};

var _getTargetRoles = function(roles, callback) {
    _getTargets(_.keys(roles), function(err, principals, emails) {
        if (err) {
            return callback(err);
        }

        // Wrap the principals into an array of objects that contains their desired role
        var principalRoles = _.map(principals, function(principal) {
            return {
                'principal': principal,
                'role': roles[principal.id]
            };
        });

        // Wrap the emails into an array of email strings that contains their desired invitation
        // role
        var emailRoles = _.map(emails, function(email) {
            return {
                'email': email,
                'role': roles[email]
            };
        });

        return callback(null, principalRoles, emailRoles);
    });
};

var _getTargets = function(targetIds, callback) {
    var principalIdsAndEmails = _.partition(targetIds, AuthzUtil.isPrincipalId);
    var principalIds = _.first(principalIdsAndEmails);
    var emails = _.last(principalIdsAndEmails);
    if (_.isEmpty(principalIds)) {
        return callback(null, [], emails);
    }

    PrincipalsDAO.getExistingPrincipals(principalIds, null, function(err, principalsById) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.values(principalsById), emails);
    });
};

var _applyMemberChanges = function(ctx, resource, members, callback) {
    if (_.isEmpty(members.changes)) {
        return callback();
    }

    var authzResourceId = AuthzUtil.getAuthzId(resource);
    return AuthzAPI.updateRoles(authzResourceId, members.changes, callback);
};

var _applyInvitationChanges = function(ctx, resource, emails, callback) {
    var addedEmailRoles = _.pick(emails.changes, emails.emails.added);
    var updatedEmailRoles = _.omit(emails.changes, emails.emails.added);
    OaeUtil.invokeIfNecessary(!_.isEmpty(updatedEmailRoles), AuthzInvitationsDAO.updateInvitationRoles, resource.id, updatedEmailRoles, function(err) {
        if (err) {
            return callback(err);
        }

        OaeUtil.invokeIfNecessary(!_.isEmpty(addedEmailRoles), AuthzInvitationsDAO.createInvitations, resource.id, addedEmailRoles, ctx.user().id, function(err, emailTokens) {
            if (err) {
                return callback(err);
            }

            return _emitInvitations(ctx, resource, addedEmailRoles, emailTokens, callback);
        });
    });
};

var _emitInvitations = function(ctx, resource, emailRoles, emailTokens, callback) {
    if (_.isEmpty(emailRoles)) {
        return callback();
    }

    var _done = _.chain(emailRoles).size().after(callback).value();
    _.chain(emailRoles)
        .map(function(role, email) {
            return new Invitation(resource, email, ctx.user(), role);
        })
        .each(function(invitation) {
            ResourceActions.emit(ResourceConstants.events.INVITED, ctx, invitation, emailTokens[invitation.email], function() {
                return _done();
            });
        })
        .value();
};
