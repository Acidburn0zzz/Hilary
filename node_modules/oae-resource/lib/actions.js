
var _ = require('underscore');

var AuthzAPI = require('oae-authz');
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var AuthzInvitationsDAO = require('oae-authz/lib/invitations/dao');
var AuthzPermissions = require('oae-authz/lib/permissions');
var AuthzUtil = require('oae-authz/lib/util');
var EmitterAPI = require('oae-emitter');
var Invitation = require('oae-authz/lib/invitations/model').Invitation;
var OaeUtil = require('oae-util/lib/util');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');
var PrincipalsUtil = require('oae-principals/lib/util');
var TenantsAPI = require('oae-tenants');
var Validator = require('oae-authz/lib/validator').Validator;

var ResourceConstants = require('oae-resource/lib/constants').ResourceConstants;

var log = require('oae-logger').logger('oae-resource-actions');

var ResourceActions = module.exports = new EmitterAPI.EventEmitter();

var create = module.exports.create = function(ctx, roles, createFn, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Only authenticated users can create a new resurce'}).isLoggedInUser(ctx);

    // Ensure all member ids are valid members
    var memberIds = _.keys(roles);
    _.each(memberIds, function(memberId) {
        if (!AuthzUtil.isPrincipalId(memberId)) {
            validator.check(memberId, {'code': 400, 'msg': 'Members must be either an email address or a valid principal id'}).isEmail();
        }
    });

    // Ensure there is at least one manager member in the list of roles
    var firstManagerRole = _.find(roles, function(role, memberId) {
        return (AuthzUtil.isPrincipalId(memberId) && role === 'manager');
    });
    validator.check(firstManagerRole, {'code': 400, 'msg': 'There must be at least one manager specified when creating a resource'}).isValidRole();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getTargetRoles(roles, function(err, principalRoles, emailRoles) {
        if (err) {
            return callback(err);
        }

        var targets = {'principalRoles': principalRoles, 'emailRoles': emailRoles};
        AuthzPermissions.canCreate(ctx, targets, function(err, members, emails) {
            if (err) {
                return callback(err);
            }

            createFn(function(err, resource) {
                if (err) {
                    return callback(err);
                }

                // Get all the results of the create function. There could be more than just the
                // main resource (e.g., content, revision) and we should retain them all
                var createFnResults = _.toArray(arguments).slice(1);

                // Apply the changes to the authz members, if any
                _applyMemberChanges(ctx, resource, members, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    // Apply the changes to the invitations, if any
                    _applyInvitationChanges(ctx, resource, emails, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        // Return to the caller, appending the members and emails changes to the
                        // create operation results
                        var args = _.union([null], createFnResults, [members, emails]);
                        return callback.apply(null, args);
                    });
                });
            });
        });
    });
};

var share = module.exports.share = function(ctx, resource, targetIds, role, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Only authenticated users can share a resurce'}).isLoggedInUser(ctx);
    validator.check(role, {'code': 400, 'msg': 'Must specify a valid role'}).isValidRole();
    validator.check(null, {'code': 400, 'msg': 'An invalid resource was provided'}).isResource(resource);
    validator.check(targetIds.length, {'code': 400, 'msg': 'At least one user to share with should be specified'}).min(1);

    var resourceAuthzId = null;
    var resourceId = null;
    if (resource) {
        resourceAuthzId = AuthzUtil.getAuthzId(resource);
        resourceId = resource.id;
    }

    _.each(targetIds, function(targetId) {
        if (!AuthzUtil.isPrincipalId(targetId)) {
            validator.check(targetId, {'code': 400, 'msg': 'Members must be either an email address or a valid principal id'}).isEmail();
        }
        validator.check(targetId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceAuthzId);
        validator.check(targetId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceId);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getTargets(targetIds, function(err, principals, emails) {
        if (err) {
            return callback(err);
        }

        var targets = {'principals': principals, 'emails': emails};
        AuthzPermissions.canShare(ctx, resource, targets, role, function(err, members, emails) {
            if (err) {
                return callback(err);
            }

            // Apply the changes to the authz members, if any
            _applyMemberChanges(ctx, resource, members, function(err) {
                if (err) {
                    return callback(err);
                }

                // Apply the changes to the invitations, if any
                _applyInvitationChanges(ctx, resource, emails, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, members, emails);
                });
            });
        });
    });
};

var setRoles = module.exports.setRoles = function(ctx, resource, roles, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Only authenticated users can share a resurce'}).isLoggedInUser(ctx);
    validator.check(null, {'code': 400, 'msg': 'An invalid resource was provided'}).isResource(resource);
    validator.check(_.keys(roles).length, {'code': 400, 'msg': 'At least one role update should be specified'}).min(1);

    var resourceAuthzId = null;
    var resourceId = null;
    if (resource) {
        resourceAuthzId = AuthzUtil.getAuthzId(resource);
        resourceId = resource.id;
    }

    _.each(roles, function(role, memberId) {
        validator.check(role, {'code': 400, 'msg': 'An invalid role was provided'}).isValidRoleChange();
        if (!AuthzUtil.isPrincipalId(memberId)) {
            validator.check(memberId, {'code': 400, 'msg': 'Members must be either an email address or a valid principal id'}).isEmail();
        }
        validator.check(memberId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceAuthzId);
        validator.check(memberId, {'code': 400, 'msg': 'You cannot share a resource with itself'}).not(resourceId);
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    _getTargetRoles(roles, function(err, principalRoles, emailRoles) {
        if (err) {
            return callback(err);
        }

        var targets = {'principalRoles': principalRoles, 'emailRoles': emailRoles};
        AuthzPermissions.canSetRoles(ctx, resource, targets, function(err, members, emails) {
            if (err) {
                return callback(err);
            }

            // Apply the changes to the authz members, if any
            _applyMemberChanges(ctx, resource, members, function(err) {
                if (err) {
                    return callback(err);
                }

                // Apply the changes to the invitations, if any
                _applyInvitationChanges(ctx, resource, emails, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, members, emails);
                });
            });
        });
    });
};

var acceptInvitation = module.exports.acceptInvitation = function(ctx, token, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can accept an invitation'}).isLoggedInUser(ctx);
    validator.check(token, {'code': 400, 'msg': 'An invitation token must be specified'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the email address that this token validates on behalf of
    AuthzInvitationsDAO.getEmailByToken(token, function(err, email) {
        if (err) {
            return callback(err);
        }

        // Get all the invitations that have been sent for this email address
        AuthzInvitationsDAO.getAllInvitationsByEmail(email, function(err, invitationHashes) {
            if (err) {
                return callback(err);
            }

            // Build the requested member roles changes to associate the user accepting these
            // invitations. There will be at most one role change per resource, as a user can only
            // be invited to a resource once
            var memberRolesByResourceId = {};
            _.each(invitationHashes, function(invitationHash) {
                var resourceId = invitationHash.resourceId;
                memberRolesByResourceId[resourceId] = memberRolesByResourceId[resourceId] || {};
                memberRolesByResourceId[resourceId][ctx.user().id] = invitationHash.role;
            });

            // Apply the changes to authz, while determining the actual net authz changes for the
            // user. For example, if they are accepting an invitation to another one of their email
            // addresses, and their account already has manager access to the resource, the role
            // change will be rejected because they shouldn't be demoted due to an invitation
            _applyAllMemberChanges(memberRolesByResourceId, function(err, changesByResourceId) {
                if (err) {
                    return callback(err);
                }

                changesByResourceId = _.mapObject(changesByResourceId, function(changes) {
                    // Convert the role changes object from one that contains just ids of the
                    // current user in context to one that contains the full principal object. Since
                    // we know there is only one change applied and it's never a removal, we can
                    // make assumptions about the added, updated and removed members
                    return {
                        'changes': changes.changes,
                        'roles': changes.roles,
                        'members': {
                            'added': (!_.isEmpty(changes.members.addedIds)) ? [ctx.user()] : [],
                            'updated': (!_.isEmpty(changes.members.updatedIds)) ? [ctx.user()] : [],
                            'removed': []
                        }
                    };
                });

                // Remove all invitations for the email
                AuthzInvitationsDAO.deleteInvitations(email, function(err) {
                    if (err) {
                        log().warn({
                            'err': err,
                            'email': email
                        }, 'Failed to delete invitations after an email invitation has been accepted');
                    }

                    // Fire the event for accepting an invitation. This allows resource modules to
                    // update search, activity, libraries, etc... regarding the changes that have
                    // been made
                    ResourceActions.emit(ResourceConstants.events.ACCEPTED_INVITATION, ctx, invitationHashes, changesByResourceId, function(errs, results) {

                        // If the user doesn't have a verified email, lets give them this one since
                        // we know it's legit
                        OaeUtil.invokeIfNecessary(!ctx.user().email, PrincipalsUtil.verifyEmailAddress, ctx, ctx.user(), email, function(err) {
                            if (err) {
                                // Whine in the logs, but for all intents and purposes we have
                                // accepted this invitation
                                log().warn({
                                    'err': err,
                                    'user': ctx.user(),
                                    'email': email
                                }, 'An error occurred while trying to auto-validate the email address of a user accepting an invitation');
                            }

                            // Provide only the base resource properties for the user accepting the
                            // invitation
                            var resources = _.chain(results)
                                .flatten()
                                .filter(function(resource) {
                                    return (!resource.deleted);
                                })
                                .map(function(resource) {
                                    return _.pick(resource, ['id', 'tenant', 'resourceType', 'displayName', 'visibility', 'joinable', 'profilePath'])
                                })
                                .value();

                            return callback(null, email, resources);
                        });
                    });
                });
            });
        });
    });
};

var _getTargetRoles = function(roles, callback) {
    _getTargets(_.keys(roles), function(err, principals, emails) {
        if (err) {
            return callback(err);
        }

        // Wrap the principals into an array of objects that contains their desired role
        var principalRoles = _.map(principals, function(principal) {
            return {
                'principal': principal,
                'role': roles[principal.id]
            };
        });

        // Wrap the emails into an array of email strings that contains their desired invitation
        // role
        var emailRoles = _.map(emails, function(email) {
            return {
                'email': email,
                'role': roles[email]
            };
        });

        return callback(null, principalRoles, emailRoles);
    });
};

var _getTargets = function(targetIds, callback) {
    var principalIdsAndEmails = _.partition(targetIds, AuthzUtil.isPrincipalId);
    var principalIds = _.first(principalIdsAndEmails);
    var emails = _.last(principalIdsAndEmails);
    if (_.isEmpty(principalIds)) {
        return callback(null, [], emails);
    }

    PrincipalsDAO.getExistingPrincipals(principalIds, null, function(err, principalsById) {
        if (err) {
            return callback(err);
        }

        return callback(null, _.values(principalsById), emails);
    });
};

var _applyAllMemberChanges = function(memberChangesByResourceId, callback) {
    if (_.isEmpty(memberChangesByResourceId)) {
        return callback(null, {});
    }

    var resourceChanges = {};
    var _done = _.chain(memberChangesByResourceId)
        .size()
        .after(function() {
            return callback(null, resourceChanges);
        })
        .value();

    _.each(memberChangesByResourceId, function(changes, resourceId) {
        // First determine what changes to actually apply. If someone accepts an invitation and they
        // already have manager role, an invitation that invited them as viewer should not demote
        // their role. Therefore, we only take into consideration promotions, similar to share
        AuthzAPI.computeMemberRolesAfterChanges(resourceId, changes, {'promoteOnly': true}, function(err, changes, roles, members) {
            if (err) {
                log().warn({'err': err}, 'An error occurred computing member role changes when an invitation was accepted');
                return _done();
            } else if (_.isEmpty(changes)) {
                // Record this as an empty change. We need to keep track of all the resources that
                // were available so we can redirect to them, even if there was no authz role change
                resourceChanges[resourceId] = {
                    'changes': changes,
                    'roles': roles,
                    'members': members
                };
                return _done();
            }

            // Perform the actual changes in the resource roles. When an invitation is created, it
            // is the authz id that is persisted as the resource id in the invitations schema.
            // Therefore, we can safely use this resource id to update the roles in the authz api
            AuthzAPI.updateRoles(resourceId, changes, function(err) {
                if (err) {
                    log().warn({'err': err}, 'An error occurred applying member role changes when an invitation was accepted');
                    return _done();
                }

                // Record this as a change that was made
                resourceChanges[resourceId] = {
                    'changes': changes,
                    'roles': roles,
                    'members': members
                };

                return _done();
            });
        });
    });
};

var _applyMemberChanges = function(ctx, resource, members, callback) {
    if (_.isEmpty(members.changes)) {
        return callback();
    }

    var authzResourceId = AuthzUtil.getAuthzId(resource);
    return AuthzAPI.updateRoles(authzResourceId, members.changes, callback);
};

var _applyInvitationChanges = function(ctx, resource, emails, callback) {
    var addedEmailRoles = _.pick(emails.changes, emails.emails.added);
    var updatedEmailRoles = _.omit(emails.changes, emails.emails.added);
    var authzResourceId = AuthzUtil.getAuthzId(resource);
    OaeUtil.invokeIfNecessary(!_.isEmpty(updatedEmailRoles), AuthzInvitationsDAO.updateInvitationRoles, authzResourceId, updatedEmailRoles, function(err) {
        if (err) {
            return callback(err);
        }

        OaeUtil.invokeIfNecessary(!_.isEmpty(addedEmailRoles), AuthzInvitationsDAO.createInvitations, authzResourceId, addedEmailRoles, ctx.user().id, function(err, emailTokens) {
            if (err) {
                return callback(err);
            }

            return _emitInvited(ctx, resource, addedEmailRoles, emailTokens, callback);
        });
    });
};

var _emitInvited = function(ctx, resource, emailRoles, emailTokens, callback) {
    if (_.isEmpty(emailRoles)) {
        return callback();
    }

    var invitations = _.map(emailRoles, function(role, email) {
        return new Invitation(resource, email, ctx.user(), role);
    });

    // Emit the invitations that were sent along with the email tokens that can be used to accept
    // them
    ResourceActions.emit(ResourceConstants.events.INVITED, ctx, invitations, emailTokens, function() {
        return callback();
    });
};
