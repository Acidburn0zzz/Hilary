var OAE = require('oae-util/lib/OAE');

/**
 * Enumerates the different types of principals that are recognized by the roles module.
 */
var PrincipalTypes = module.exports.PrincipalTypes = { USER: 'u', GROUP: 'g' };

/**
 * Enumerates the different types of objects that are recognized by the roles module.
 */
var ObjectTypes = module.exports.ObjectTypes = { CONTENT: 'content', GROUP: 'group' };

/**
 * A stateful context object that is used to execute role checks on a principal.
 *
 * @param {String} tenantId The ID of the tenant to which the principal belongs
 * @param {String} principalType The type of principal, as specified by `PrincipalTypes`
 * @param {String} principalId The local ID of the principal (i.e., not globally unique);
 * 
 * @return {Object} A securityContext object that may be used to execute role checks for the principal.
 */
var SecurityContext = module.exports.SecurityContext = function(tenantId, principalType, principalId) {

    var rowKey = principalType+':'+tenantId+':'+principalId;
    var that = {};

    /**
     * Determine the role of the principal on the specified object instance.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {Function} callback A function(role, err) specifying the role of the user. If the user has no role
     * or there is an `err`or performing the check, `role` will be `null`
     **/
    that.getRole = function(objectType, objectId, callback) {
        var columnName = getColumnName(objectType, objectId);
        var cql = 'select ? from Role where principal = ?';
        OAE.runQuery(cql, [columnName, rowKey], function(err, rows) {
            if (!err) {
                var value = rows[0].colHash[columnName];
                if (value) {
                    callback(value);
                } else {
                    callback(null);
                }
            } else {
                callback(null, err);
            }
        });
    }

    /**
     * Determines whether or not the principal has *any* role associated to the given object instance.
     *
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {Function} callback A function(hasAnyRole, err) specifying whether or not the user has a role
     */
    that.hasAnyRole = function(objectType, objectId, callback) {
        that.getRole(objectType, objectId, function(role, err) {
            if (!err) {
                callback(role !== null);
            } else {
                callback(false, err);
            }
        });
    }

    /**
     * Determines whether or not the principal has the specified role on the given object instance.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {String} roleId The role to check
     * @param {Function} callback A function(hasRole, err) specifying whether or not the user has the role
     */
    that.hasRole = function(objectType, objectId, roleId, callback) {
        that.getRole(objectType, objectId, function(role, err) {
            if (!err) {
                callback(role === roleId);
            } else {
                callback(false, err);
            }
        });
    }

    /**
     * Given an object type (as determined by `ObjectTypes`), return all `{object id} => {role}` entries that are
     * associated to the principal. The structure of the `entries` result looks like the following:
     * 
     * ```javascript
     * [
     *   {
     *      "id": "<contentId1>",
     *      "role": "<roleId1>"
     *    },
     *    {
     *      "id": "<contentId2>"
     *      "role": "<roleId2>"
     *    }
     * ]
     * ```
     * 
     * @param {String} objectType The object type, as specified by `ObjectTypes`, to search
     * @param {String} start The starting entry on which to begin returning results (used for paging). **This is not a number**. If `null`, then the results will simply begin from the start. If the `object id` is provided, then results will begin from that `object id`s location, exclusively.
     * @param {Number} limit The maximum number of entries to return (used for paging)
     * @param {Function} callback A function(entries, err), providing the list of role entries that match the search
     */
    that.getRolesForObjectType = function(objectType, start, limit, callback) {
        if (isNaN(limit)) {
            callback(null, {why: '"limit" parameter must be a number when searching for active roles'});
            return;
        }

        var firstColumn = 0;
        var columnPrefix = objectType+':';

        if (start === null) {
            start = columnPrefix;    
        } else {
            // the starting point should be ObjectType:ObjectId combo
            start = columnPrefix+start;

            // increment the limit if the user specified the start point, because we skip the first entry to get the EXCLUSIVE
            // page range
            limit++;
            firstColumn = 1;
        }

        // A '|' character is used as an assumption that it will always cause a slice to the end. This could become problematic
        // if we have characters that go outside the range of ASCII, but AFAICT there is no better way to page the column range through
        // CQL right now. Another option is to specify the empty string as the end range, which may always splice to the end (up to the
        // limit-- in this case, we would have to search and slice the resulting array in memory to remove elements of other object types.
        var end = columnPrefix+'|';

        var cql = 'select first '+limit+' ? .. ? from Role where principal = ?';
        OAE.runQuery(cql, [start, end, rowKey], function(err, rows) {
            if (!err) {
                var entries = [];
                for (var i = firstColumn; i < rows[0]._colCount; i++) {
                    // add the column to the entries list, the object id will have the ObjectType prefix stripped away from it
                    var col = rows[0].cols[i];
                    var objectId = col.name.substring(columnPrefix.length); 
                    entries.push({ 'id': objectId, 'role': col.value });
                }
                callback(entries);
            } else {
                callback(null, err);
            }
        });
    }

    /**
     * Assign the given principal a role on an object instance. If the user already has a role, it will simply be updated.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {String} roleId The role to assign to the principal
     * @param {Function} callback A function(err) specifying whether or not the operation was successful
     */
    that.addRole = function(objectType, objectId, roleId, callback) {
        var columnName = objectType+':'+objectId;
        var value = roleId;
        var cql = 'update Role set ? = ? where principal = ?';
        OAE.runQuery(cql, [columnName, value, rowKey], callback);
    }

    /**
     * Remove the role assignment of the given principal on an object instance. If the user did not have a role, this will
     * have no effect.
     * 
     * @param {String} objectType The type of object, as specified by `ObjectType`
     * @param {String} objectId The ID of the object instance
     * @param {Function} callback A function(err) specifying whether or not the operation was successful
     */
    that.removeRole = function(objectType, objectId, callback) {
        var columnName = objectType+':'+objectId;
        var cql = 'delete ? from Role where principal = ?';
        OAE.runQuery(cql, [columnName, rowKey ], callback);
    }

    // Determine the column name for the given object instance.
    function getColumnName(objectType, objectId) {
        return objectType+':'+objectId;
    }

    return that;
};

