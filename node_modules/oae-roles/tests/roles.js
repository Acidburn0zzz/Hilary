var OAE = require('oae-util/lib/OAE');
var api = require('oae-roles/lib/api');
var schema = require('oae-roles/lib/schema');
var PrincipalTypes = api.PrincipalTypes;
var ObjectTypes = api.ObjectTypes;

var KEYSPACE = 'oae';

module.exports.setUp = function(callback) {

    // TODO: Replace with a "refreshKeySpace" method from some utility method.

    // we don't know if the keyspace existed before. lets make sure it is cleared
    OAE.initializeKeySpace(function() {
        schema.dropSchema(function(err) {
            if (err) throw err;
            schema.ensureSchema(function(err) {
                if (err) throw err;
                callback();
            });
        });
    });
};

module.exports.tearDown = function(callback) {
  schema.dropSchema(function(err) {
    callback();
  });
}

module.exports.testTenantSeparation = function(test) {
    test.expect(8);

    var securityContextA = new api.SecurityContext('testTenantSeparationA', PrincipalTypes.USER, 'mrvisser');
    var securityContextB = new api.SecurityContext('testTenantSeparationB', PrincipalTypes.USER, 'mrvisser');

    securityContextA.addRole(ObjectTypes.CONTENT, 'testTenantSeparationContent', 'manager', function(err) {
        test.ok(!err);

        // verify tenant B user does not have a role on that content
        securityContextB.hasAnyRole(ObjectTypes.CONTENT, 'testTenantSeparationContent', function(hasAnyRole, err) {
            test.ok(!err);
            test.ok(!hasAnyRole);

            // add 'viewer' for security context B
            securityContextB.addRole(ObjectTypes.CONTENT, 'testTenantSeparationContent', 'viewer', function(err) {
                test.ok(!err);

                // ensure user from tenant A is still manager, not viewer
                securityContextA.hasRole(ObjectTypes.CONTENT, 'testTenantSeparationContent', 'manager', function(hasRole, err) {
                    test.ok(!err);
                    test.ok(hasRole);

                    // ensure user from context B is a viewer, not manager
                    securityContextB.hasRole(ObjectTypes.CONTENT, 'testTenantSeparationContent', 'viewer', function(hasRole, err) {
                        test.ok(!err);
                        test.ok(hasRole);
                        test.done();
                    });
                });
            });
        });
    });
};

module.exports.testHasRole = function(test) {
    test.expect(6);

    var securityContext = new api.SecurityContext('testHasRole', PrincipalTypes.USER, 'mrvisser');

    // add the 'manager' role
    securityContext.addRole(ObjectTypes.CONTENT, 'testHasRoleContent', 'manager', function(err) {
        test.ok(!err);

        // verify that hasRole reports that the user has the manager role
        securityContext.hasRole(ObjectTypes.CONTENT, 'testHasRoleContent', 'manager', function(hasRole, err) {
            test.ok(!err);
            test.ok(hasRole);

            // remove the role from the user
            securityContext.removeRole(ObjectTypes.CONTENT, 'testHasRoleContent', function(err) {
                test.ok(!err);

                // verify that the user no longer has the role
                securityContext.hasRole(ObjectTypes.CONTENT, 'testHasRoleContent', 'manager', function(hasRole, err) {
                    test.ok(!err);
                    test.ok(!hasRole);
                    test.done();
                });
            });
        });
    });
};

module.exports.testHasAnyRole = function(test) {
    test.expect(6);

    var securityContext = new api.SecurityContext('testHasAnyRole', PrincipalTypes.USER, 'mrvisser');

    // add the 'manager' role
    securityContext.addRole(ObjectTypes.CONTENT, 'testHasAnyRoleContent', 'manager', function(err) {
        test.ok(!err);

        // verify that hasRole reports that the user has the manager role
        securityContext.hasAnyRole(ObjectTypes.CONTENT, 'testHasAnyRoleContent', function(hasAnyRole, err) {
            test.ok(!err);
            test.ok(hasAnyRole);

            // remove the role from the user
            securityContext.removeRole(ObjectTypes.CONTENT, 'testHasAnyRoleContent', function(err) {
                test.ok(!err);

                // verify that the user no longer has the role
                securityContext.hasRole(ObjectTypes.CONTENT, 'testHasAnyRoleContent', 'manager', function(hasAnyRole, err) {
                    test.ok(!err);
                    test.ok(!hasAnyRole);
                    test.done();
                });
            });
        });
    });
};

module.exports.testGetRolesForObjectType = function(test) {
    test.expect(9);

    var baseViewerContentId = 'contentIView';
    var baseManagerContentId = 'contentIManage';
    var securityContext = new api.SecurityContext('testGetRolesForObjectType', PrincipalTypes.USER, 'mrvisser');
    loadContentRoles(securityContext, baseViewerContentId, 300, 'viewer', function() {
        loadContentRoles(securityContext, baseManagerContentId, 300, 'manager', function() {

            // an aggregate to hold a unique set of all keys. Used to ensure we get all the elements back
            var aggregate = {};

            // grab the first 250
            securityContext.getRolesForObjectType(ObjectTypes.CONTENT, null, 250, function(entries250_1, err) {
                test.ok(!err);
                test.equal(entries250_1.length, 250);
                
                // get the next 250
                securityContext.getRolesForObjectType(ObjectTypes.CONTENT, entries250_1[249].id, 250, function(entries250_2, err) {
                    test.ok(!err);
                    test.equal(entries250_2.length, 250);
                    test.notEqual(entries250_1[249].id, entries250_2[0].id, 'The paging should be exclusive, but this test shows it was inclusive');

                    // get the rest, with overflow
                    securityContext.getRolesForObjectType(ObjectTypes.CONTENT, entries250_2[249].id, 250, function(entries100, err) {
                        test.ok(!err);
                        test.equal(entries100.length, 100);
                        test.notEqual(entries250_2[249].id, entries100[0].id, 'The paging should be exclusive, but this test shows it was inclusive');

                        // now make sure we read 600 unique entries from cassandra
                        for (var i = 0; i < 250; i++) {
                            aggregate[entries250_1[i].id] = true;
                            aggregate[entries250_2[i].id] = true;

                            if (i < 100)
                                aggregate[entries100[i].id] = true;
                        }

                        test.equal(Object.keys(aggregate).length, 600);
                        test.done();
                    });
                });

            });
        });
    });
};

function loadContentRoles(securityContext, baseContentId, numContentItems, role, callback) {
    if (numContentItems === 0) {
        callback();
        return;
    }

    securityContext.addRole(ObjectTypes.CONTENT, baseContentId+'-'+numContentItems, role, function(err) {
        if (err) throw err;
        loadContentRoles(securityContext, baseContentId, numContentItems-1, role, callback);
    });
}