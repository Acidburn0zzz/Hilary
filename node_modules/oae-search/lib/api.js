/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');
var log = require('oae-logger').logger('oae-search');
var MQ = require('oae-util/lib/mq');
var Telemetry = require('oae-telemetry').telemetry('search');

var client = require('./internal/elasticsearch');
var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchUtil = require('oae-search/lib/util');

// specifies whether or not we should allow the index to be manually refreshed by anyone
var allowAnonRefreshIndex = false;
var boundIndexWorkers = false;

var documentTransformers = {
    /*!
     * A default document transformer that simply returns the raw search result.
     * @see registerDocumentTransformer
     */
    '*': function(ctx, docs, callback) {
        callback(null, docs);
    }
};
var documentProducers = {};
var searches = {};

/**
 * Refresh the search configuration with the given options.
 *
 * @param   {String}    index                   The index to use
 * @param   {Object}    serverOpts              The server opts with which to configure the client
 * @param   {Boolean}   allowAnonRefreshIndex   Whether or not the API should allow any user to manually refresh the index, If `false`, only global administrator can do this
 * @param   {Boolean}   processIndexJobs        Whether or not this node should process indexing jobs sent through the task queue
 * @param   {Function}  callback                Invoked when configuration has been refreshed
 */
var refreshSearchConfiguration = module.exports.refreshSearchConfiguration = function(indexName, serverOpts, _allowAnonRefreshIndex, processIndexJobs, callback) {
    allowAnonRefreshIndex = _allowAnonRefreshIndex;
    client.refreshSearchConfiguration(indexName, serverOpts);

    if (processIndexJobs && !boundIndexWorkers) {
        boundIndexWorkers = true;
        MQ.bind(SearchConstants.mq.TASK_INDEX_DOCUMENT, _handleIndexDocumentTask, function() {
            MQ.bind(SearchConstants.mq.TASK_DELETE_DOCUMENT, _handleDeleteDocumentTask, callback);
        });
    } else if (!processIndexJobs && boundIndexWorkers) {
        boundIndexWorkers = false;
        MQ.unbind(SearchConstants.mq.TASK_INDEX_DOCUMENT, function() {
            MQ.unbind(SearchConstants.mq.TASK_DELETE_DOCUMENT, callback);
        });
    } else {
        // if we get here, there was no state change in handling indexing, so we don't need to do anything.
        callback();
    }
};

/**
 * Register a transformer with the search API that will transform search documents into a model that can be returned to the
 * UI for the user. There can only be one transformer per resource type. The document transformers are given the search documents
 * after they have been retrieved from ElasticSearch. Once transformed, the final search results are sent back to the client.
 *
 * @param   {String}    typeName                    The type of document this transformer acts upon
 * @param   {Function}  transformer                 The function that will transform an array of search documents into an array of view objects
 * @param   {Context}   transformer.ctx             The context of the currently authenticated user
 * @param   {Object}    transformer.docs            The raw search documents, keyed by document _id, that were returned in the search
 * @param   {Function}  transformer.callback        The callback function the transformer should execute to indicate it has completed processing
 * @param   {Object}    transformer.callback.err    An error that occurred while transforming the docs, if any
 * @param   {Object}    transformer.callback.docs   The view model, keyed by document _id, that were translated from the hash of search documents
 * @throws  {Error}                                 An error that is thrown if there is already a transformer registered for the given type
 */
var registerDocumentTransformer = module.exports.registerDocumentTransformer = function(typeName, transformer) {
    if (documentTransformers[typeName]) {
        throw new Error('Document transformer for type ' + typeName + ' already exists.');
    }
    documentTransformers[typeName] = transformer;
};

/**
 * Register a producer with the search API that will produce search documents to be added to the search index. There can only be one
 * producer per resource type. When a new indexing task is submitted for a resource that is of `typeName` resource type, then this
 * producer will have an opportunity to produce documents to be indexed.
 *
 * @param   {String}    typeName                The resource type that this indexer indexes
 * @param   {Function}  producer                A function that will produce documents to be indexed
 * @param   {Object[]}  producer.resourceData   An array of objects that represent the data that drives the producer. The format of the actual data object will generally be different for different resource types
 * @param   {Function}  producer.callback       The callback function that should be invoked when the indexer has produced the documents
 * @param   {Object}    producer.callback.err   An error that occurred while creating the documents, if any
 * @param   {Object[]}  producer.callback.docs  The documents to be indexed
 * @throws  {Error}                             An error that is thrown if there is already a producer registered for the given type
 */
var registerDocumentProducer = module.exports.registerDocumentProducer = function(typeName, producer) {
    if (documentProducers[typeName]) {
        throw new Error('Document producer for type ' + typeName + ' already exists.');
    }
    documentProducers[typeName] = producer;
};

/**
 * Register a search with the Search API that will process search input and produce a query to run against elastic search. Once the query
 * is created by the search registered here, the search will be sent to ElasticSearch and and all results will be passed through the
 * document transformers. See `registerDocumentTransformer` for more information.
 *
 * @param   {String}    typeName                        The name of the search. Once registered, this search can be invoked by using this `typeName` in the `search` method.
 * @param   {Function}  queryBuilder                    The search function that will be invoked when a search is performed. This function is responsible for generating a query as per the ElasticSearch Query DSL and returning it in the callback.
 * @param   {Context}   queryBuilder.ctx                The context of the search being performed
 * @param   {Object}    queryBuilder.opts               The search opts that are specific to the search
 * @param   {Function}  queryBuilder.callback           The callback function that should be invoked when the search has created the query
 * @param   {Object}    queryBuilder.callback.err       An error that occurred while creating the query. Pass an error parameter to indicate an error occurred, if it was successful, this parameter should be left `null`
 * @param   {Object}    queryBuilder.callback.queryData The Query DSL object representing the query, as per the ElasticSearch documentation
 * @throws  {Error}                                     An error that is thrown if there is already a search registered by the given name
 */
var registerSearch = module.exports.registerSearch = function(typeName, queryBuilder) {
    if (searches[typeName]) {
        throw new Error('Search type ' + typeName + ' already exists.');
    }
    searches[typeName] = queryBuilder;
};

/**
 * Perform a search of a given type.
 *
 * @param {Context}     ctx             The current context of the request
 * @param {String}      searchType      The type of search to perform (e.g., 'general')
 * @param {Object}      opts            A hash describing the search parameters
 * @param {Function}    callback        Invoked when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 * @param {Object}      callback.result The search result object
 */
var search = module.exports.search = function(ctx, searchType, opts, callback) {
    var registeredSearch = searches[searchType];
    if (registeredSearch) {
        // invoke the search plugin to get the query object
        registeredSearch(ctx, opts, function(err, queryData) {
            if (err) {
                return callback(err);
            }

            // perform the search with the query data
            client.search(queryData, null, function(err, results) {
                if (err) {
                    return callback(err);
                }

                SearchUtil.transformSearchResults(ctx, documentTransformers, results, callback);
            });
        });
    } else {
        return callback({'code': 400, 'msg': 'Search "' + searchType + '" is not a valid search type.'});
    }
};

/**
 * Refresh the current index so that all its documents are available for querying.
 *
 * @param {Context}     ctx             The context of the current request
 * @param {Function}    callback        Invoked when the process completes
 * @param {Object}      callback.err    An error that occurred, if any
 */
var refresh = module.exports.refresh = function(ctx, callback) {
    if (allowAnonRefreshIndex || (ctx.user() && ctx.user().isGlobalAdmin())) {
        client.refresh(callback);
    } else {
        return callback({'code': 401, 'msg': 'You are not authorized to refresh the index.'});
    }
};

/**
 * When bound to an MQ delete document task, this method will delete the resource from the search engine.
 *
 * @param   {Object}    data            The task data
 * @param   {String}    data.id         The _id of the document to delete
 * @param   {Function}  callback        Invoked when indexing has completed
 * @param   {Object}    callback.err    An error that occurred, if any
 */
var _handleDeleteDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search document delete task.');
        }
    };

    client.delete(SearchConstants.resourceMappingName, data.id, callback);
}

/**
 * When bound to am MQ index document task, this method will index the resource document(s) as described by the
 * task data.
 *
 * @param   {Object}    data                The task data
 * @param   {String}    data.resourceType   The type of the resource being indexed
 * @param   {Object[]}  data.resources      An array of resources that are to be indexed. This should be in the format depended on in the resource type's custom document producer
 * @param   {Function}  callback            Invoked when indexing has completed
 * @param   {Object}    callback.err        An error that occurred, if any
 */
var _handleIndexDocumentTask = function(data, callback) {
    callback = callback || function(err) {
        if (err) {
            log().error({'err': err, 'data': data}, 'Error handling search indexing task.');
        }
    };

    var resourceType = data.resourceType;
    var resources = data.resources;

    var documentProducer = documentProducers[resourceType];
    if (documentProducer) {
        documentProducer(resources, function(err, docs) {
            if (err) {
                log().error({'err': err, 'data': data}, 'Error processing task data into search documents.');
            }

            // ensure we've applied the proper _type to all documents
            docs = _.map(docs, function(doc) {
                return _.extend(doc, {
                    '_type': SearchConstants.resourceMappingName,
                    'resourceType': resourceType
                });
            });

            if (docs.length > 1) {
                client.bulk(SearchConstants.resourceMappingName, docs, function(err) {
                    if (!err) {
                        log().info('Successfully indexed %s documents.', docs.length);
                    }
                    return callback(err);
                });
            } else if (docs.length === 1) {
                client.index(SearchConstants.resourceMappingName, docs[0], null, callback);
            }
        });
    } else {
        log().warn('Ignoring %s documents of type "%s", which does not have an associated document producer.', resources.length, resourceType);
    }
};
