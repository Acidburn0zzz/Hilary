/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var _ = require('underscore');

var SearchConstants = require('oae-search/lib/constants').SearchConstants;
var SearchModel = require('oae-search/lib/model');

/**
 * Get the standard search parameters from the given request.
 * 
 * @param   {Request}   req     The express Request object from which to extract the parameters.
 * @return  {Object}            The parameters extracted from the request that are relevant for search.
 */
var getSearchParams = module.exports.getSearchParams = function(req) {
    if (!req || !req.query) {
        return {};
    }

    return {
        'q': req.query.q,
        'from': req.query.from,
        'limit': req.query.limit,
        'sort': req.query.sort
    };
};

/**
 * Determine if the given parameter is a valid query parameter. If so, simply return the `val`, otherwise, return `defaultVal`.
 *
 * @param   {String}  val           The value to check
 * @param   {String}  [defaultVal]  The value to return if `val` is not valid. Defaults to `SearchConstants.query.ALL`
 * @return  {String}                `val` if it is valid. `defaultVal` otherwise.
 */
var getQueryParam = module.exports.getQueryParam = function(val, defaultVal) {
    defaultVal = defaultVal || SearchConstants.query.ALL
    return val || defaultVal;
};

/**
 * Determine if the given parameter is a valid resource type parameter. If so, simply return the `val`, otherwise, return `defaultVal`.
 *
 * @param   {String}  val           The value to check
 * @param   {String}  [defaultVal]  The value to return if `val` is not valid. Defaults to `SearchConstants.general.RESOURCE_TYPE_ALL`
 * @return  {String}                `val` if it is valid. `defaultVal` otherwise.
 */
var getResourceTypeParam = module.exports.getResourceTypeParam = function(val, defaultVal) {
    defaultVal = defaultVal || SearchConstants.general.RESOURCE_TYPE_ALL;
    return val || defaultVal;
};

/**
 * Determine if the given parameter is a valid sort parameter. If so, simply return the `val`, otherwise, return `defaultVal`.
 *
 * @param   {String}  val           The value to check
 * @param   {String}  [defaultVal]  The value to return if `val` is not valid. Defaults to `SearchConstants.sort.ASC`
 * @return  {String}                `val` if it is valid. `defaultVal` otherwise.
 */
var getSortParam = module.exports.getSortParam = function(val, defaultVal) {
    defaultVal = defaultVal || SearchConstants.sort.ASC;
    return (val && _.contains(SearchConstants.sort.OPTIONS, val)) ? val : defaultVal;
};

/**
 * Create a basic document transformer that will map an enumerated set of property names to the transformed
 * document result.
 *
 * @param   {String[]}  properties  The properties to map from a raw search document to the transformed result
 * @return  {Object}                The transformed result document
 */
var createPropertyDocumentTransformer = module.exports.createPropertyDocumentTransformer = function(properties) {
    return function(ctx, searchType, docs, transformerCallback) {
        var transformedDocs = {};
        _.values(docs).forEach(function(doc) {
            var transformedDoc = { '_id': doc._id };

            // add all the properties to the transformed doc
            properties.forEach(function(property) {
                transformedDoc[property] = doc._source[property];
            });

            transformedDocs[doc._id] = transformedDoc;
        });

        return transformerCallback(null, transformedDocs);
    };
};

/**
 * Transform the raw search `results` from ElasticSearch into a `SearchResult` that can be returned to the client.
 *
 * @param   {Context}       ctx                 The context of the current request
 * @param   {Object}        transformers        An object keyed by the resource type, and the value is the transformer object that can transform a set of search documents into client-viewable documents
 * @param   {Object}        results             The search results sent back from ElasticSearch
 * @param   {Function}      callback            Invoked when the process completes
 * @param   {Object}        callback.err        An error that occurred, if any
 * @param   {SearchResult}  callback.results    The search results that can be sent to the client
 */
var transformSearchResults = module.exports.transformSearchResults = function(ctx, transformers, results, callback) {
   var hits = results.hits;
    if (!hits || !hits.hits || !hits.hits.length) {
        return callback(null, new SearchModel.SearchResult(0, []));
    } else {

        // aggregate all the documents to be keyed by type
        var total = hits.total;
        var docsByType = {};
        var docIdOrdering = {};
        var hits = hits.hits;
        for (var i = 0; i < hits.length; i++) {
            var doc = hits[i];
            var id = doc._id;
            var type = doc._type;

            // if transformer does not exist, pass it through the default "raw" transformer
            if (!transformers[type]) {
                type = '*';
            }

            if (!docsByType[type]) {
                docsByType[type] = {};
            }
            docsByType[type][id] = doc;
            docIdOrdering[id] = i;
        }

        // run all the documents through the document transformers for their particular type
        var transformersToRun = _.keys(docsByType).length;
        var transformersComplete = 0;
        var transformErr = null;
        var transformedDocs = {};
        var _monitorTransformers = function(err, docs) {
            if (transformErr) {
                // nothing to do, we've already returned because of an error.
            } else if (err) {
                transformErr = err;
                return callback(transformErr);
            } else {

                // merge the docs from this iteration
                _.extend(transformedDocs, docs);

                transformersComplete++;
                if (transformersComplete >= transformersToRun) {

                    // we're done all transformations, reorder the docs and send back the response
                    var orderedDocs = _orderDocs(transformedDocs, docIdOrdering);
                    return callback(null, new SearchModel.SearchResult(total, orderedDocs));
                }
            }
        }

        // execute all transformers asynchronously from one another. _monitorTransformers will keep track fo their completion.
        for (var type in docsByType) {
            transformers[type](ctx, docsByType[type], _monitorTransformers);
        }
    }
};

/**
 * Converts a query and (optionally) a filter into an appropriate ElasticSearch Query DSL object.
 *
 * @param   {Object}    query   The ElasticSearch query representation.
 * @param   {Object}    filter  The ElasticSearch filter to apply. If `null`, then the resulting object will
 *                              simply not be a filtered query.
 * @param   {Object}    opts    An arbitrary set of additional options that contain top-level ES Query DSL parameters (e.g., limit, limit, ...)
 * @return  {Object}            A valid ElasticSearch Query object that can be sent as a query.
 */
var createQuery = module.exports.createQuery = function(query, filter, opts) {
    if (filter) {
        // if we have filters, we need to create a 'filtered' query
        var data = {
            'query': {
                'filtered': {
                    'query': query,
                    'filter': filter
                }
            }
        };
    } else {
        // if it's just a query, we wrap it in a standard query.
        var data = {
            'query': query
        };
    }

    return _.extend(data, opts);
};

/**
 * Create an ElasticSearch 'OR' filter, wrapped around multiple other filters.
 *
 * @param   {Object}  args*     The filter objects to "OR" together
 * @return  {Object}            An ElasticSearch "OR" filter.
 */
var filterOr = module.exports.filterOr = function() {
    if (arguments.length === 0) {
        return null;
    }

    return { 'or': _.compact(arguments) };
};

/**
 * Create an ElasticSearch 'AND' filter, wrapped around multiple other filters.
 *
 * @param   {Object}  args*     The filter objects to "AND" together
 * @return  {Object}            An ElasticSearch "AND" filter.
 */
var filterAnd = module.exports.filterAnd = function() {
    if (arguments.length === 0) {
        return null;
    }

    return { 'and': _.compact(arguments) };
};

/**
 * Create an ElasticSearch 'terms' filter, wrapped around an array of values
 *
 * @param   {String}    field   The name of the field this term filters
 * @param   {String[]}  values  The values to filter on
 * @return  {Object}            An ElasticSearch 'terms' filter.
 */
var filterTerms = module.exports.filterTerms = function(field, values) {
    if (!values || values.length === 0) {
        return null;
    }

    var filter = {'terms': {}};
    filter.terms[field] = values;
    return filter;
};

/**
 * Create an ElasticSearch 'term' filter, wrapped around a value
 *
 * @param   {String}    field   The name of the field this term filters
 * @param   {String}    value   The value to match
 * @return  {Object}            An ElasticSearch 'term' filter.
 */
var filterTerm = module.exports.filterTerm = function(field, value) {
    if (!value) {
        return null;
    }

    var filter = {'term': {}};
    filter.term[field] = value;
    return filter;
};

/**
 * Created a full-text query object (just the query portion, not filter) for ElasticSearch from the provided
 * user input. This ensures that the query will be a safe keyword search that supports both "everything" (e.g., *)
 * and user-input search terms.
 */
var createQueryStringQuery = module.exports.createQueryStringQuery = function(field, q) {
    if (!q || q === SearchConstants.query.ALL) {
        // we're searching everything, use query_string syntax
        return {
            'query_string': {
                'default_field': field,
                'query': SearchConstants.query.ALL
            }
        };
    } else {
        // we're searching for a keyword, use a safe match query instead of query_string
        var match = {};
        match[field] = {
            'query': q,
            'operator': 'and'
        };

        return { 'match': match };
    }
};

/**
 * Order the docs in the given hash according to the given orderSpec.
 *
 * @param   {Object}    docsHash    A hash of search documents, keyed by the document id.
 * @param   {Object}    orderSpec   A hash keyed by the search document id, and the value is the number indicating its position in the result
 * @return  {Object[]}              An array of the search documents in the `docsHash`, in the order specified by the `orderSpec`
 * @api private
 */
var _orderDocs = function(docsHash, orderSpec) {
    var docs = _.values(docsHash);
    docs.sort(function(one, other) {
        return orderSpec[one._id] - orderSpec[other._id];
    });
    return docs;
};
