/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');

var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-telemetry');
var OaeUtil = require('oae-util/lib/util');
var Redis = require('oae-util/lib/redis');

var telemetryConfig = null;

// Will hold the local histogram (duration) data
var stats = null;
var publisher = null;
var publishIntervalId = null;

/**
 * Initializes the Telemetry API so that it can start accepting and publishing metrics to an
 * analysis backend.
 *
 * @param  {Object}     [telemetryConfig]   The object containing the configuration properties. See the `config.telemetry` object in the base `./config.js` for more information
 */
var init = module.exports.init = function(_telemetryConfig) {
    _applyTelemetryConfig(_telemetryConfig);
    _resetHistograms();
    clearTimeout(publishIntervalId);
    if (telemetryConfig.enabled && telemetryConfig.publisher) {
        publishIntervalId = setInterval(_publishTelemetryData, telemetryConfig.publishInterval * 1000);
        publisher = require('./publishers/' + telemetryConfig.publisher);
        publisher.init(telemetryConfig);
    }
};

/**
 * Allows other modules to perform telemetry tasks.
 * ex:
 *
 *     var Telemetry = require('oae-telemetry').telemetry('cassandra');
 *         Telemetry.incr('write');
 *
 * @param  {String} module The module.
 */
var telemetry = module.exports.telemetry = function(module) {
    return new Telemetry(module);
};

/**
 * The Telemetry object.
 *
 * @param  {String} module A module to namespace counts in.
 * @api private
 */
var Telemetry = function(module) {

    // Holds the exported methods of the object
    var that = {};

    /**
     * Increment the count for this Telemetry item.
     *
     * @param  {String}     name            The name of the item to increment
     * @param  {Number}     [count]         If specified, the metric will be incremented this many times. Defaults to 1
     * @param  {Function}   [callback]      Invoked when the count has been incremented
     * @param  {Object}     [callback.err]  An error that occurred, if any
     */
    that.incr = function(name, count, callback) {
        count = OaeUtil.getNumberParam(count, 1, 1);
        callback = callback || function(err) {
            if (err) {
                return log().error({'err': err}, 'Error incrementing count in redis');
            }
        };

        // Since this is used in some low-level areas, it is possible that the Redis client isn't fully initialized before we
        // try and use it. In those cases, we'll simply bypass incrementing until we're fully initialized
        if (Redis.getClient()) {
            Redis.getClient().hincrby(_getTelemetryCountHashKey(), _getTelemetryCountKey(module, name), count, callback);
        } else {
            return callback();
        }
    };

    /**
     * Adds a value that is suitable for histogram parsing.
     *
     * @param  {String}  name    The name to append a value on.
     * @param  {Number}  value   The value that should be added.
     */
    that.append = function(name, value) {
        stats.histograms[module] = stats.histograms[module] || {};
        stats.histograms[module][name] = stats.histograms[module][name] || [];
        stats.histograms[module][name].push(value);
    };

    /**
     * Appends a timing value for histogram parsing that is a duration (in ms) from the provided `from` time.
     *
     * @param  {String}  name    The name to append the timing value on
     * @param  {Number}  from    The millis from which the duration should be based.
     */
    that.appendDuration = function(name, from) {
        that.append(name, _duration(from));
    };

    return that;
};

// The telemetry object that will be used to time HTTP requests.
var serverTelemetry = telemetry('server');

/**
 * This method can be used by middleware to count and/or time requests.
 * The property `telemetryUrl` on the request object will be checked to
 * see if any timing/count should occur. If null or undefined only the counter
 * for the total number of requests of that particular HTTP method will be increased.
 * If it is defined (by an API endpoint), his method will:
 *  * increase the amount of requests for that URI by 1.
 *  * increase the amount of requests for that HTTP method by 1.
 *  * measure the time it took for a response to be generated.
 *
 * @param  {Request}    req     The request.
 * @param  {Response}   res     The response
 */
module.exports.request = function(req, res) {
    if (telemetryConfig.enabled) {
        // Increase the amount of `method` requests.
        serverTelemetry.incr(req.method);

        // Do some time measuring.
        var start = Date.now();
        res.on('header', function(header){
            if (req.telemetryUrl) {
                // Record the count and response time for the request
                serverTelemetry.incr(req.method + '.' + req.telemetryUrl + '.count');
                serverTelemetry.append(req.method + '.' +  req.telemetryUrl + '.time', _duration(start));
            }
        });
    }
};

/**
 * Reset all of the telemetry data. This includes both the local histograms and the global counts.
 *
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var reset = module.exports.reset = function(callback) {
    _resetHistograms();
    Redis.getClient().del(_getTelemetryCountHashKey(), callback);
};

/**
 * Get the current set of telemetry data.
 *
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object}     callback.data   The current telemetry data
 */
var getTelemetryData = module.exports.getTelemetryData = function(callback) {
    _getCounts(function(err, counts) {
        if (err) {
            return callback(err);
        }

        return callback(null, _mergeHistograms(counts));
    });
};

/**
 * Publish the telemetry data to the telemetry back-end.
 * @api private
 */
var _publishTelemetryData = function() {
    // Only get the counts if we successfully acquire a lock for them
    _lockAndGetCounts(function(counts) {
        var data = _mergeHistograms(counts);

        // Reset the histograms for the next collection interval
        _resetHistograms();

        publisher.publish(data);
    });
};

/**
 * Get the count metrics from redis if it is time to do so. Since many machines can be collecting stats at a time, this
 * method employs a lock to ensure only one machine within the publishing interval will collect and publish. It does this by
 * using a lock timeout.
 *
 * @param  {Function}   callback            Invoked when the counts have been collected, or it has been determined we will not be responsible for collecting them
 * @param  {Object}     [callback.counts]   The counts data, a hash of key -> value in the raw manner that they were stored in redis. If not specified, it means either we failed to get the counts or it was not time to do so. If there was an error, it will be logged internally.
 * @api private
 */
var _lockAndGetCounts = function(callback) {
    // Try and fetch the lock for the duration of the publishing interval
    Locking.acquire(_getTelemetryCountLock(), telemetryConfig.publishInterval, function(err, token) {
        if (err) {
            log().error({'err': err}, 'Error acquiring lock to publish telemetry counts');
            return callback();
        } else if (!token) {
            // We didn't acquire the lock, so don't bother with the counts
            return callback();
        }

        // Fetch the full counts hash in redis
        _getCounts(function(err, counts) {
            if (err) {
                log().error({'err': err}, 'Error querying telemetry counts from redis');
                return callback();
            }

            // We return without releasing the lock, because the expiry of the lock managers the collection interval, so that if another application
            // server tries to collect 1 second after this, they will fail to get the lock
            return callback(counts);
        });
    });
};

/**
 * Get the telemetry counts from redis.
 *
 * @param  {Function}   callback        Invoked when the process completes
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Object}     callback.counts The raw counts, keyed by the provided count key and the value is the current value of the counts
 * @api private
 */
var _getCounts = function(callback) {
    Redis.getClient().hgetall(_getTelemetryCountHashKey(), callback);
};

/**
* Merge the given count data with the current histogram data.
*
* @param  {Object}  counts  The counts object fetched from redis
* @return {Object}          The counts data merged with the telemetry data
* @api private
*/
var _mergeHistograms = function(counts) {
    var mergedData = {};

    // Collect the count metrics if necessary
    if (counts) {
        _.each(counts, function(value, key) {
            var parts = _getTelemetryCountKeyParts(key);
            mergedData[parts.module] = mergedData[parts.module] || {};
            mergedData[parts.module][parts.name] = value;
        });
    }

    // Overlay the meaningful histogram data
    _.each(stats.histograms, function(nameValue, module) {
        _.each(nameValue, function(value, name) {
            if (value && !_.isEmpty(value)) {
                mergedData[module] = mergedData[module] || {};
                mergedData[module][name] = value;
            }
        });
    });

    return mergedData;
};

/**
 * Apply the user-provided telemetry configuration object to the effective configuration of the API
 *
 * @param  {Object}     [telemetryConfig]   The object containing the configuration properties. See the `config.telemetry` object in the base `./config.js` for more information
 * @api private
 */
var _applyTelemetryConfig = function(_telemetryConfig) {
    telemetryConfig = _.extend({}, _telemetryConfig);
    telemetryConfig.enabled = (telemetryConfig.enabled === true);
    telemetryConfig.publishInterval = OaeUtil.getNumberParam(telemetryConfig.publishInterval, 60, 1);
};

/**
 * Reset the in-memory histogram stats for the next collection interval
 * @api private
 */
var _resetHistograms = function() {
    stats = {'histograms': {}};
};

/**
 * Get the duration (in ms) that has expired from the `from` millis.
 *
 * @param  {Number} from   The number of milliseconds to substract from the current time.
 * @return {Number}        How many milliseconds have elapsed since the `from` time until now.
 * @api private
 */
var _duration = function(from) {
    return Date.now() - from;
};

/**
 * @return {String}     The key for the lock that unlocks access to publish the redis telemetry data
 * @api private
 */
var _getTelemetryCountLock = function() {
    return 'oae-telemetry:counts:lock';
};

/**
 * @return {String}     The key for the redis hash that holds all of the telemetry count information
 * @api private
 */
var _getTelemetryCountHashKey = function() {
    return 'oae-telemetry:counts:data';
};

/**
 * @return {String}     The hash key for metric associated to this module and name.
 * @api private
 */
var _getTelemetryCountKey = function(module, name) {
    return util.format('%s:%s', module, name);
};

/**
 * @return {Object}     The object from which a telemetry count key was generated using #_getTelemetryCountKey(module, name)
 * @api private
 */
var _getTelemetryCountKeyParts = function(telemetryCountKey) {
    var split = telemetryCountKey.split(':');
    return {
        'module': split.shift(),
        'name': split.join(':')
    };
};
