/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var express = require('express');
var fs = require('fs');
var http = require('http');
var redis = require('redis');
var util = require('util');

var OAE = require('oae-util/lib/oae');
var IO = require('oae-util/lib/io');
var log = require('oae-logger').logger('oae-tenants');
var Cassandra = require('oae-util/lib/cassandra');
var Pubsub = require('oae-util/lib/pubsub');
var Server = require('oae-util/lib/server');
var Validator = require('oae-util/lib/validator').Validator;

var model = require('./model');
var Config = require('../../../config').config;

var globalServer = false;
var runningServers = {};


Pubsub.on('oae-tenants', function (message) {
    // Commands are of the form:
    //     start 2001
    //     stop 2001
    var args = message.split(' ');
    var cmd = args.shift();
    if (cmd === 'start') {
        var port = args.shift();
        getTenantByPort(port, function(err, tenant) {
            if (err) {
                return log().error({err: err}, 'There was an error retrieving the tenant to start on port %d', port);
            }
            _startTenant(tenant, function(err, disabled) {
                if (err) {
                    log().error({err: err}, 'Could not start tenant on port %d', port);
                } else {
                    if (disabled) {
                        log().info({tenant: tenant.alias}, 'Tenant on port %d started (disabled)', port);
                    } else {
                        log().info({tenant: tenant.alias}, 'Tenant on port %d started.', port);
                    }
                }
            });
        });
    } else if (cmd === 'stop') {
        var port = args.shift();
        getTenantByPort(port, function(err, tenant) {
            if (err) {
                return log().error({err: err}, 'There was an error retrieving the tenant to stop on port %d', port);
            }
            _stopTenant(tenant, function(err) {
                if (err) {
                    log().error({err: err, tenant: tenant.alias}, 'Error stopping tenant on port %d', port);
                } else {
                    log().info({tenant: tenant.alias}, 'Tenant on port %d stopped.', port);
                }
            });
        });
    } else {
        log().warn({redisMessage: message}, 'Received a message but did not know what to do with it.');
    }
});

/**
 * TODO
 */
var initializeTenantMiddleware = module.exports.initializeTenantMiddleware = function(callback) {
    // This middleware adds the tenant to each request on the global admin server.
    OAE.globalAdminServer.use(function(req, res, next) {
        req.tenant = {
            'isGlobalAdminServer': true
        };
        return next();
    });

    // This middleware adds the tenant to each request on the global admin server.
    OAE.tenantServer.use(function(req, res, next) {
        req.tenant = runningServers[req.headers.host];
        if (!req.tenant) {
            return next(new Error('An unknown tenant has been specified'));
        }

        // Check whether or not the tenant has been disabled
        if (req.tenant.disabled) {
            // If we're disabled, there is no point in keeping connections open.
            res.setHeader('Connection', 'Close');
            return res.send(503, 'This server is currently disabled. Please check back later.');
        }
        next();
    });

    // Get all tenants and cache them by their host
    getAllTenants(function(err, tenants) {
        if (err) {
            return callback(err);
        }
        
        for (var t = 0; t < tenants.length; t++) {
            runningServers[tenants[t].host] = tenants[t];
        }
        callback();
    });
};

/**
 * Publishes a message that a new tenant should be started.
 * Note that the actual server startup will happen asynchronous from this method.
 *
 * @param  {Tenant}     tenant          The tenant object representing the tenant to be started
 * @param  {Function}   callback        A callback method
 * @param  {Object}     callback.err    An error object (if any)
 */
module.exports.startTenant = function(tenant, callback) {
    Pubsub.publish('oae-tenants', 'start ' + tenant.alias, callback);
};

/**
 * Start a new tenant by listening on the provided ports.
 *
 * @param  {Tenant}     tenant                      The tenant object representing the tenant to be started
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object (if any)
 * @param  {Boolean}    callback.disabled           Whether or not this tenant is disabled.
 * @api private
 */
var _startTenant = function(tenant, callback) {
    callback = callback || function() {};
    if (tenant) {
        if (runningServers[tenant.host]) {
            // We already created the server object.
            // Enable the tenant
            runningServers[tenant.host].disabled = !tenant.active;
            callback(false, !tenant.active);
        } else {
            // Keep all the servers in memory so we can access them later.
            runningServers[tenant.host] = tenant;
            runningServers[tenant.host].disabled = !tenant.active;
        }
    } else {
        callback({'code': 400, 'msg': 'No tenant was provided.'});
    }
};

/**
 * Stops a running tenant.
 *
 * @param   {Tenant}    tenant          The tenant object representing the tenant to be stopped
 * @param   {Function}  callback        Standard callback function
 * @param   {Object}    callback.err    An error object (if any.)
 * @api private
 */
var _stopTenant = function(tenant, callback) {
    if (tenant && runningServers[tenant.host]) {
        // Disable that server
        runningServers[tenant.host].disabled = true;
        callback();
    } else {
        callback({'code': 404, 'msg': 'No server found on that port.'});
    }
};

/**
 * Disable or enable a tenant
 * 
 * @param  {Context}      ctx             The current context
 * @param  {String[]}     aliases         An array of aliases representing the tenants that should be stopped.
 * @param  {Boolean}      disabled        True if the tenant needs to be disabled
 * @param  {[Function]}   callback        Callback function executed when request is completed.
 * @param  {Object}       callback.err    An error object (if any.)
 */
var disableTenants = module.exports.disableTenants = function(ctx, aliases, disabled, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot disable or enable tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!util.isArray(aliases)) {
        aliases = [aliases];
    }

    // Store the activity flag in cassandra.
    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ? WHERE alias = ?',
            'parameters': [!disabled, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }

        // Broadcast the message accross the cluster
        // so we can start/stop the tenants.
        var cmd = disabled ? 'stop' : 'start';
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', cmd + ' ' + aliases[i], callback);
        }
    });
};

/**
 * Rather than physically deleting a tenant, we just disable it for now.
 *
 * @param  {Context}   ctx             The current context
 * @param  {String[]}  aliases         An array of aliases representing the tenants that should be deleted.
 * @param  {Function}  callback        Callback function executed when request is completed.
 * @param  {Object}    callback.err    An error object (if any.)
 */
var deleteTenants = module.exports.deleteTenants = function(ctx, aliases, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot delete tenants'});
    }

    if (!aliases) {
        return callback({'code': 400, 'msg': 'Please provide a ports array'});
    }
    if (!util.isArray(aliases)) {
        aliases = [aliases];
    }

    var queries = [];
    for (var i = 0; i < aliases.length; i++) {
        queries.push({
            'query': 'UPDATE Tenant SET active = ?, deleted = ? WHERE alias = ?',
            'parameters': [false, true, aliases[i]]
        });
    }
    Cassandra.runBatchQuery(queries, 'QUORUM', function(err) {
        if (err) {
            return callback(err);
        }
        // Broadcast the message accross the cluster
        // so we can stop the tenants.
        for (var i = 0; i < aliases.length; i++) {
            Pubsub.publish('oae-tenants', 'stop ' + aliases[i], callback);
        }
    });
};

/**
 * Get all the tenants in the datastore.
 * @param  {Function}  callback            Standard callback function
 * @param  {Object}    callback.err        Error object containing the error message
 * @param  {Tenant[]}  callback.tenants    Array of all the existing tenants
 */
var getAllTenants = module.exports.getAllTenants = function(callback) {
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM', false, function(err, rows) {
        if (err) {
            return callback(err);
        }

        var tenants = [];
        for (var i = 0; i < rows.length; i++) {
            var tenant = mapToTenant(rows[i], false);
            if (!tenant.deleted) {
                tenants.push(tenant);
            }
        }
        callback(null, tenants);
    });
};

/**
 * Get the unique tenant by their alias.
 *
 * @param  {String}    alias               The alias assigned to the tenant
 * @param  {Function}  callback            A function(err, tenant) specifying the tenant requested
 * @param  {Object}    callback.err        Error object containing the error message and error code
 * @param  {Tenant}    callback.tenant     The tenant object that uses the provided alias
 */
var getTenantByAlias = module.exports.getTenantByAlias = function(alias, callback) {
    Cassandra.runQuery('SELECT * FROM Tenant USING CONSISTENCY QUORUM WHERE alias = ?', [alias], function(err, rows) {
        if (err) {
            return callback(err);
        }

        if (rows[0].count > 1) {
            var tenant = mapToTenant(rows[0]);
            callback(null, tenant);
        } else {
            callback({'code': 404, 'msg': 'There is no tenant with alias ' + alias});
        }
    });
};

/**
 * Create a tenant using the provided information.
 *
 * @param  {Context}    ctx             The current context
 * @param  {String}     alias           The unique alias assigned to the tenant
 * @param  {String}     name            A descriptive short name for the tenant
 * @param  {String}     host         The host on which this tenant is proxying (ie: oae.cam.ac.uk or oae.gatech.edu)
 * @param  {Function}   callback        A function(err, tenant) specifying the tenant information that was persisted.
 * @param  {Object}     callback.err    An error object (if any)
 * @param  {Tenant}     callback.tenant The tenant that was persisted.
 */
var createTenant = module.exports.createTenant = function(ctx, alias, name, host, callback) {
    callback = callback || function() {};

    if (!ctx.user() || !ctx.user().isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot create tenants'});
    }

    var validator = new Validator();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'The tenant alias should not contain a colon'}).notContains(':');
    validator.check(name, {'code': 400, 'msg': 'Missing name'}).notEmpty();
    validator.check(host, {'code': 400, 'msg': 'Missing base url'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getTenantByAlias(alias, function(err, tenant) {
        if (!tenant) {
            tenant = new model.Tenant(alias, name, host, true, false);
            // no tenant by this alias or port exist, create one
            Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET name = ?, host = ?, active = ? WHERE alias = ?',
                [tenant.name, host, tenant.active, tenant.alias], function(err) {
                if (err) {
                    return callback(err);
                }
                // Send a message to all the app servers in the cluster that they
                // should start up the tenant.
                module.exports.startTenant(tenant, function(err) {
                    // Let the configuration module know that a new tenant has been created and configuration needs to be fetched
                    Pubsub.publish('oae-config', tenant.alias + ' created');
                    if (err) {
                        return callback(err);
                    }
                    callback(null, tenant);
                });
            });
        } else {
            callback({'code': 400, 'msg': 'A tenant with the alias ' + alias + ' already exists'});
        }
    });
};

/**
 * Updates the basic information of a tenant
 * 
 * @param  {Context}   ctx            The current context.
 * @param  {String}    alias          The alias of the tenant we want to update
 * @param  {String}    name           The updated name for the tenant
 * @param  {Function}  callback       A function(err) executed after the tenant has been updated
 * @param  {Object}    callback.err   An error object (if any)
 */
var updateTenant = module.exports.updateTenant = function(ctx, alias, name, callback) {
    if (!ctx.user() || !ctx.user().isAdmin(ctx.user().tenant)) {
        return callback({'code': 401, 'msg': 'Unauthorized users cannot update tenants'});
    }

    var validator = new Validator();
    validator.check(name, {'code': 400, 'msg': 'Missing name'}).notEmpty();
    validator.check(alias, {'code': 400, 'msg': 'Missing alias'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    Cassandra.runQuery('UPDATE Tenant USING CONSISTENCY QUORUM SET name = ? WHERE alias = ?', [name, alias], callback);
};

/**
 * Map a cassandra row element to a tenant object.
 *
 * @param  {Row}      row            The row to be mapped
 * @param  {Boolean}  returnDeleted  ignored?
 * @return {Tenant}                  A tenant corresponding to the row
 */
var mapToTenant = function(row, returnDeleted) {
    var hash = Cassandra.rowToHash(row);
    return new model.Tenant(hash.alias, hash.name, hash.host, hash.active, hash.deleted);
};
