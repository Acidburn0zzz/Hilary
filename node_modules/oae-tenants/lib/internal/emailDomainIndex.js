/*!
 * Copyright 2015 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');

var EmailDomainIndex = module.exports = function() {
    var index = {};

    var _find = function(emailDomain) {
        if (!emailDomain) {
            return [];
        }

        var chain = _.chain(index);
        _.each(_split(emailDomain), function(part) {
            chain = chain.oaeGet(part);
        });
        return _findStringLeaves(chain.value());
    };

    var _set = function(alias, emailDomain) {
        if (!emailDomain) {
            return;
        }

        var existing = _find(emailDomain);
        if (!_.isEmpty(existing)) {
            return _.first(existing);
        }

        var segment = index;
        var parts = _split(emailDomain);
        _.each(parts.slice(0, -1), function(part) {
            if (_.isString(segment)) {
                // If we already found a leaf node, bail. This is a conflict
                return;
            }

            segment[part] = segment[part] || {};
            segment = segment[part];
        });

        if (_.isString(segment)) {
            // If we found a leaf node, we can't set anything as we'll overwrite an existing entry
            return segment;
        }

        // If we didn't find a leaf node, we've instantiated all the index segments up to the
        // leaf alias, so set it on the index
        segment[_.last(parts)] = alias;

        // Return false, indicating we successfully set without finding a conflict
        return false;
    };

    var _match = function(emailDomain) {
        if (!emailDomain) {
            return null;
        }

        var result = index;
        _.each(_split(emailDomain), function(part) {
            if (_.isString(result)) {
                // If the result is a tenant alias string, we have found a tenant
                return;
            } else if (!result) {
                // If there is no more result, we have exhausted the tree
                return;
            }

            result = result[part];
        });

        return (_.isString(result)) ? result : null;
    };

    var _conflict = function(alias, emailDomain) {
        // If there is an existing match for this email domain that is not this tenant alias, we
        // return with the alias that it conflicts with. We cannot proceed with the update
        var match = _match(emailDomain);
        if (match && match !== alias) {
            return match;
        }

        // If there are existing tenants with email domains that ours would match with (e.g.,
        // the domain is `cam.ac.uk` and there exists a `caret.cam.ac.uk`), then we cannot
        // proceed as it will be a conflict
        var existing = _.without(_find(emailDomain), alias);
        if (!_.isEmpty(existing)) {
            return _.first(existing);
        }

        // Otherwise, there is no conflict
        return false;
    };

    var _delete = function(oldEmailDomain) {
        if (!oldEmailDomain) {
            return;
        }

        var parts = _split(oldEmailDomain);
        var segment = index;
        _.each(parts.slice(0, -1), function(part) {
            if (!segment) {
                return;
            }

            segment = segment[part];
        });

        if (segment) {
            delete segment[_.last(parts)];
        }
    };

    return {
        'conflict': function(alias, emailDomain) {
            return _conflict(alias, emailDomain);
        },
        'match': function(emailDomain) {
            return _match(emailDomain);
        },
        'update': function(alias, emailDomain, oldEmailDomain) {
            // Do nothing if there is no change to the email domain
            if (emailDomain === oldEmailDomain) {
                return;
            }

            // First ensure there are no conflicts
            var conflict = _conflict(alias, emailDomain);
            if (conflict) {
                return conflict;
            }

            // We have ruled out potential conflicts. Go ahead with the update
            _delete(oldEmailDomain);
            _set(alias, emailDomain);
        }
    }
};

var _findStringLeaves = function(obj, _leaves) {
    _leaves = _leaves || [];
    if (!obj) {
        return _leaves;
    } else if (_.isString(obj)) {
        _leaves.push(obj);
        return _leaves;
    }

    // Recursively find the leaves of the object
    _.each(obj, function(val) {
        _findStringLeaves(val, _leaves);
    });

    return _leaves;
}

var _split = function(emailDomain) {
    return emailDomain.split('.').reverse();
};
