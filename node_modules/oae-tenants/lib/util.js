/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var AuthzUtil = require('oae-authz/lib/util');
var PrincipalsUtil = require('oae-principals/lib/util');
var Server = require('oae-util/lib/server');
var TenantsConfig = require('oae-config').config('oae-tenants');

var TenantsAPI = require('./api');

/**
 * Determine whether or not the given context represents a session that is authenticated to the specified tenant.
 *
 * @param  {Context}   ctx                 The context of the user request
 * @param  {String}    tenantAlias         The alias of the tenant to check
 * @return {Boolean}                       Whether or not the user in context (if any) is authenticated to the specified alias
 */
var isLoggedIn = module.exports.isLoggedIn = function(ctx, tenantAlias) {
    var isAnon = !ctx.user();
    var isGlobalAdmin = !isAnon && ctx.user().isGlobalAdmin && ctx.user().isGlobalAdmin();
    return (!isAnon && (isGlobalAdmin || ctx.user().tenant.alias === tenantAlias));
};

/**
 * Determine whether or not the tenant identified by the given tenant alias is private.
 *
 * @param  {String}    tenantAlias         The alias of the tenant to check
 * @return {Boolean}                       `true` if the tenant is private. `false` otherwise
 */
var isPrivate = module.exports.isPrivate = function(tenantAlias) {
    return TenantsConfig.getValue(tenantAlias, 'tenantprivacy', 'tenantprivate') !== false;
};

/**
 * Get all the tenant aliases with which the provided tenant can interact. In other words, for all tenants aliases that are
 * returned in this array, `TenantsUtil.canInteract(tenantAlias, resultingTenant)` should return true with the given tenant.
 *
 * @param  {String}    tenantAlias     The tenant with which all resulting tenants should be able to interact
 * @return {String[]}                  An array of tenant aliases with which the given tenant may interact.
 */
var getAllTenantsForInteraction = module.exports.getAllTenantsForInteraction = function(tenantAlias) {
    // A private tenant cannot interact with other tenants
    if (isPrivate(tenantAlias)) {
        return [];
    }

    // This tenant can interact with all public tenants
    var publicAliases = [];
    var allAliases = TenantsAPI.getRunningTenantAliases();
    for (var i = 0; i < allAliases.length; i++) {
        var alias = allAliases[i];
        if (!isPrivate(alias)) {
            publicAliases.push(alias);
        }
    }

    return publicAliases;
};

/**
 * Determine whether or not two tenant's privacy settings allow that they can interact with eachother. This
 * feeds off of the tenant privacy settings such that if a tenant is private, one cannot grant access to content
 * or groups to users or groups outside the tenant boundaries. The boundary is made so that two different tenants
 * cannot interact if *either* of them are private. Obviously, this will return true if the tenants are the same.
 *
 * @param  {String}    tenantAliasOne      The alias of one tenant to compare
 * @param  {String}    tenantAliasOther    The alias of the other tenant to compare
 * @return {Boolean}                       `true` if the tenant boundaries should allow these two tenants to interact with one another. `false` otherwise
 */
var canInteract = module.exports.canInteract = function(tenantAliasOne, tenantAliasOther) {

    // This is very weird, be safe
    if (!tenantAliasOne || !tenantAliasOther) {
        return false;
    }

    // If the tenants are the same, we can always interact
    if (tenantAliasOne === tenantAliasOther) {
        return true;
    }

    // If either tenant is private, then there is no ability to interact
    return (!isPrivate(tenantAliasOne) && !isPrivate(tenantAliasOther));
};

/**
 * Checks for tenant boundary violations between:
 *   * an actor and the resource he's trying to do something with.
 *   * an actor and the target principals he's trying to do something with.
 *
 * The visibility settings for each user will also be checked in case they
 * are external users.
 *
 * @param  {Context}    ctx                             The context of the current request
 * @param  {String}     resourceTenantAlias             The tenant alias of the resource the user is performaning an action upon.
 * @param  {String[]}   principalIds                    The principalIds with which the user wishes to interact
 * @param  {Function}   callback                        Invoked when the process completes
 * @param  {Object}     callback.err                    An error that occurred, if any
 * @param  {Boolean}    callback.hasViolations          `false` if the user in context is allowed to perform this operation. `true` otherwise
 * @param  {String[]}   [callback.illegalPrincipalIds]  If the check failed because of a tenant boundary violation, this will be an array of principalIds that were in violation
 */
var resolveTenantBoundaryViolations = module.exports.resolveTenantBoundaryViolations = function(ctx, resourceTenantAlias, principalIds, callback) {
    var actorTenantAlias = ctx.user().tenant.alias;

    // First test the easy stuff:
    //  * A direct violation between actorTenantAlias and resourceTenantAlias
    if (!canInteract(actorTenantAlias, resourceTenantAlias)) {
        return callback(null, true);
    }

    //  * A direct violation between actorTenantAlias and principalIds[i].tenant
    var illegalPrincipalIds =  _.filter(principalIds, function(principalId) {
        var principalTenantAlias = AuthzUtil.getPrincipalFromId(principalId).tenantAlias;
        // The principalId is invalid if the violates boundaries between the user or the tenant
        return (!canInteract(actorTenantAlias, principalTenantAlias) || !canInteract(actorTenantAlias, principalTenantAlias));
    });
    if (illegalPrincipalIds.length > 0) {
        return callback(null, true, illegalPrincipalIds);
    }

    // Now, if any of the specified principalIds are part of an other tenant then the actor,
    // we'll need to check their visibility.
    var externalPrincipals = _.filter(principalIds, function(principalId) {
        var targetTenant = AuthzUtil.getResourceFromId(principalId).tenantAlias;
        return actorTenantAlias !== targetTenant;
    });
    if (externalPrincipals.length > 0) {
        PrincipalsUtil.getPrincipals(ctx, externalPrincipals, function(err, principals) {
            if (err) {
                return callback(err);
            }

            var nonPublicUsers = _.filter(principals, function(principal) { return principal.visibility !== 'public'; });
            var hasViolations = (nonPublicUsers.length > 0);
            var illegalPrincipalIds = (hasViolations) ? _.map(nonPublicUsers, function(user) { return user.id; }) : null;
            callback(null, hasViolations, illegalPrincipalIds);
        });
    } else {
        // Otherwise we're good
        callback(null, false);
    }
};

/**
 * Returns the base URL (including protocol) for the tenant.
 *
 * @param  {Tenant} tenant The tenant for which to retrieve the base URL.
 * @return {String}        The base URL for the specified tenant.
 */
var getBaseUrl = module.exports.getBaseUrl = function(tenant) {
    var protocol = (Server.useHttps()) ? 'https' : 'http';
    return protocol + '://' + tenant.host;
};
