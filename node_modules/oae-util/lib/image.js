/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var Canvas = require('canvas');
var Path = require('path');
var temp = require('temp');

var log = require('oae-logger').logger('Image');
var Validator = require('oae-util/lib/validator').Validator;


/**
 * Crops and resizes an image.
 *
 * @param {String}      path                    The path on disk of the image to crop.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the square that needs to be cropped out.
 * @param {Number[]}    sizes                   An array of image sizes. An image will be generated for each size. You only need to specify the width for each size as this method only generates squared images.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.files          An object where each entry holds a resized file. The keys are the requested sizes.
 */
var cropAndResize = module.exports.cropAndResize = function(path, selectedArea, sizes, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
    }
    validator.check(sizes, {'code': 400, 'msg': 'The desired sizes array is missing'}).notNull();
    if (sizes) {
        validator.check(sizes.length, {'code': 400, 'msg': 'The desired sizes array is empty'}).min(1);
        for (var i = 0; i < sizes.length; i++) {
            validator.check(sizes[i], {'code': 400, 'msg': 'The size needs to be a valid integer larger than 0'}).isInt();
            validator.check(sizes[i], {'code': 400, 'msg': 'The size needs to be a valid integer larger than 0'}).min(0);
        }
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Crop the image.
    _cropImage(path, selectedArea, function(err, croppedFile) {
        if (err) {
            return callback(err);
        }

        var files = {};
        var resized = 0;
        var called = false;

        // Use a foreach so that the callback function of resizeImage has the size on the stack.
        sizes.forEach(function(size) {

            // Resize the image.
            _resizeImage(croppedFile.path, {'width': size, 'height': size}, function(err, file) {
                resized++;
                if (err && !called) {
                    called = true;
                    return callback(err);
                }

                files[size] = file;
                if (resized === sizes.length && !called) {
                    called = true;

                    // Remove the cropped one before we call the callback.
                    fs.unlink(croppedFile.path, function(err) {
                        if (err) {
                            called = true;
                            return callback({'code': 500, 'msg': err});
                        }
                        callback(null, files);
                    });
                }
            });
        });
    });
};

/**
 * Crops a part out of an image.
 *
 * @param {String}      path                    The path on disk of the file that needs to be cropped.
 * @param {Object}      selectedArea            The area that needs to be cropped out.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.file           A file object with some metadata of the cropped file.
 * @param {Object}      callback.file.path      The path where the file has been written to.
 * @param {Object}      callback.file.name      The name of the file
 * @param {Object}      callback.file.size      The size of the cropped image (in bytes).
 */
var cropImage = module.exports.cropImage = function(path, selectedArea, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _cropImage(path, selectedArea, callback);
};

/**
 * Internal method that performs the actual cropping.
 * This does no validation of the parameters.
 *
 * @param {String}      path                    The path on disk of the file that needs to be cropped.
 * @param {Object}      selectedArea            The area that needs to be cropped out.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.file           A file object with some metadata of the cropped file.
 * @param {Object}      callback.file.path      The path where the file has been written to.
 * @param {Object}      callback.file.name      The name of the file
 * @param {Object}      callback.file.size      The size of the cropped image (in bytes).
 * @api private
 */
var _cropImage = function(path, selectedArea, callback) {
    // Make sure that the pic is big enough.
    var tempPath = temp.path({'suffix': '.png'});
    var img = new Canvas.Image();

    img.onerror = function(err){
        log().error({'err': err}, 'Error when cropping an image.');
        return callback({'code': 500, 'msg': 'Error when cropping the image.'});
    };

    // When the image is loaded we can retrieve the width/height, perform some sanity checks and start cropping.
    img.onload = function() {
        var width = img.width;
        var height = img.height;
        // A user can crop out a 1x1 pixel,
        // cropping outside the image is not allowed though.
        if (selectedArea.x + 1 >= img.width
            || selectedArea.y + 1 >= img.height
            || selectedArea.width > (img.width - selectedArea.x)
            || selectedArea.width > (img.height - selectedArea.y)) {
            return callback({'code': 400, 'msg': 'You cannot crop outside of the image.'});
        }

        // Crop it.
        var x = selectedArea.x;
        var y = selectedArea.y;
        var w = selectedArea.width;
        var h = selectedArea.width;
        var canvas = new Canvas(w, h);
        var ctx = canvas.getContext('2d');
        ctx.drawImage(img, x, y, w, h, 0, 0, w, h);

        // Output the png buffer and write it to disk.
        canvas.toBuffer(function(err, buf){
            fs.writeFile(tempPath, buf, function(err) {
                if (err) {
                    log().error({'err': err}, 'Error when cropping an image.');
                    return callback({'code': 500, 'msg': 'Error when cropping the image.'});
                }

                // Get the filesize of the resized image.
                fs.stat(tempPath, function(err, stat) {
                    if (err) {
                        fs.unlink(tempPath);
                        log().error({'err': err}, 'Could not get the file system information about %s', tempPath);
                        return callback({'code': 500, 'msg': 'Could not get information about the cropped file.'});
                    }
                    var file = {
                        'path': tempPath,
                        'size': stat.size,
                        'name': Path.basename(tempPath)
                    };
                    callback(null, file);
                });
            });
        });
    };

    // Load it.
    img.src = path;
};

/**
 * Resizes an image to the specified size.
 *
 * @param {String}      path                    The path on disk of the file that needs to be resized.
 * @param {Object}      size                    The new size of the image.
 * @param {Number}      size.width              The width that the image should be resized to.
 * @param {Number}      size.height             The height that the image should be resized to.
 * @param {Function}    callback                Standard callback method.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.file           A file object with some metadata of the resized file.
 * @param {Object}      callback.file.path      The path where the file has been written to.
 * @param {Object}      callback.file.name      The name of the file
 * @param {Object}      callback.file.size      The size of the resized image (in bytes).
 */
var resizeImage = module.exports.resizeImage = function(path, size, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to resize is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The size must be specified'}).isObject(size);
    if (size) {
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).min(0);
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).min(0);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _resizeImage(path, size, callback);
};

/**
 * Internal method that resizes an image to the specified size.
 * This performs no validation.
 *
 * @param {String}      path                    The path on disk of the file that needs to be resized.
 * @param {Object}      size                    The new size of the image.
 * @param {Number}      size.width              The width that the image should be resized to.
 * @param {Number}      size.height             The height that the image should be resized to.
 * @param {Function}    callback                Standard callback method.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.file           A file object with some metadata of the resized file.
 * @param {Object}      callback.file.path      The path where the file has been written to.
 * @param {Object}      callback.file.name      The name of the file
 * @param {Object}      callback.file.size      The size of the resized image (in bytes).
 * @api private
 */
var _resizeImage = function(path, size, callback) {
    var suffix = size.width + 'x' + size.height + '.png';
    var tempPath = temp.path({'suffix': suffix});

    var img = new Canvas.Image();
    img.onerror = function(err){
        log().error({'err': err}, 'Error when resizing an image.');
        return callback({'code': 500, 'msg': 'Error when resizing the image.'});
    };

    img.onload = function(){
        var canvas = new Canvas(size.width, size.height);
        var ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, size.width, size.height);
        canvas.toBuffer(function(err, buf){
            fs.writeFile(tempPath, buf, function(err) {
                if (err) {
                    fs.unlink(tempPath);
                    log().error({'err': err}, 'Could not write the resized file to %s', tempPath);
                    return callback({'code': 500, 'msg': 'Could write the resized file.'});
                }
                fs.stat(tempPath, function(err, stat) {
                    if (err) {
                        fs.unlink(tempPath);
                        log().error({'err': err}, 'Could not get the file system information about %s', tempPath);
                        return callback({'code': 500, 'msg': 'Could not get information about the resized file.'});
                    }
                    var file = {
                        'path': tempPath,
                        'size': stat.size,
                        'name': Path.basename(tempPath)
                    };
                    callback(null, file);
                });
            });
        });
    };

    // Load the big file.
    img.src = path;
};
