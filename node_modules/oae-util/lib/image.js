/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var gm = require('gm');
var Path = require('path');
var temp = require('temp');

var log = require('oae-logger').logger('Image');
var Validator = require('oae-util/lib/validator').Validator;


/**
 * Crops and resizes an image.
 *
 * @param {String}      path                    The path on disk of the image to crop.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the square that needs to be cropped out.
 * @param {Number[]}    sizes                   An array of image sizes. An image will be generated for each size. You only need to specify the width for each size as this method only generates squared images.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {File[]}      callback.files          An array of files, each representing a resized image. The width and height are stored on the File object for identification.
 */
var cropAndResize = module.exports.cropAndResize = function(path, selectedArea, sizes, callback) {
    // Crop the image.
    cropImage(path, selectedArea, function(err, croppedFile) {
        if (err) {
            return callback(err);
        }

        var files = [];
        var called = false;

        /**
         * Gets called each time an image has been resized.
         * The callback gets executed when all the images have been resized or when the first error occurs.
         *
         * @param  {Object}   err   Standard error object.
         * @param  {String}   file  The file where the resized image has been written to.
         */
        var resizeDone = function(err, file) {
            if (err && !called) {
                called = true;
                return callback(err);
            }

            files.push(file);
            if (files.length === sizes.length) {
                 // Remove the cropped one.
                fs.unlink(croppedFile.path, function(err) {
                    if (err) {
                        return callback({'code': 500, 'msg': err});
                    }
                    callback(null, files);
                });
            }
        };

        for (var i = 0; i < sizes.length; i++) {
            resizeImage(croppedFile.path, {'width': sizes[i], 'height': sizes[i]}, resizeDone);
        }
    });
};

/**
 * Crops a part out of an image.
 *
 * @param {String}      path                    The path on disk of the file that needs to be cropped.
 * @param {Object}      selectedArea            The area that needs to be cropped out.
 * @param {Number}      selectedArea.x          The x coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.y          The y coordinate of the topleft corner to start cropping
 * @param {Number}      selectedArea.width      The width of the box that needs to be cropped out.
 * @param {Number}      selectedArea.height     The height of the box that needs to be cropped out.
 * @param {Function}    callback                Standard callback function.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.file           A file object with some metadata of the cropped file.
 * @param {Object}      callback.file.path      The path where the file has been written to.
 * @param {Object}      callback.file.name      The name of the file
 * @param {Object}      callback.file.size      The size of the cropped image (in bytes).
 * @param {Object}      callback.file.width     The width of the cropped image.
 * @api private
 */
var cropImage = module.exports.cropImage = function(path, selectedArea, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to crop is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The coordinates for the area you wish to crop must be specified'}).isObject(selectedArea);
    if (selectedArea) {
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.x, {'code': 400, 'msg': 'The x-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).isInt();
        validator.check(selectedArea.y, {'code': 400, 'msg': 'The y-coordinate needs to be a valid integer'}).min(0);
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).isInt();
        validator.check(selectedArea.width, {'code': 400, 'msg': 'The width value must be an integer larger than 0'}).min(1);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Pipe it trough imagemagick.
    var imageMagick = gm.subClass({ 'imageMagick': true });
    // Make sure that the pic is big enough.
    imageMagick(path).size(function (err, size) {
        if (err) {
            return callback({'code': 500, 'msg': err});
        }
        // A user can crop out a 1x1 pixel,
        // cropping outside the image is not allowed though.
        if (selectedArea.x + 1 >= size.width
            || selectedArea.y + 1 >= size.height
            || selectedArea.width > (size.width - selectedArea.x)
            || selectedArea.width > (size.height - selectedArea.y)) {
            return callback({'code': 400, 'msg': 'You cannot crop outside of the image.'});
        }

        // Crop it and write it to a temporary file.
        var tempPath = temp.path({'suffix': '.png'});
        imageMagick(path)
        .noProfile()
        .crop(selectedArea.width, selectedArea.width, selectedArea.x, selectedArea.y)
        .noProfile()
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not crop the image %s', path);
                return callback({'code': 500, 'msg': err});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath);
                    return callback({'code': 500, 'msg': err});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': Path.basename(tempPath),
                    'width': selectedArea.width
                };
                callback(null, file);
            });
        });
    });
};

/**
 * Resizes an image to the specified size.
 *
 * @param {String}      path                    The path on disk of the file that needs to be resized.
 * @param {Object}      size                    The new size of the image.
 * @param {Number}      size.width              The width that the image should be resized to.
 * @param {Number}      size.height             The height that the image should be resized to.
 * @param {Function}    callback                Standard callback method.
 * @param {Object}      callback.err            An error object (if any.)
 * @param {Object}      callback.file           A file object with some metadata of the resized file.
 * @param {Object}      callback.file.path      The path where the file has been written to.
 * @param {Object}      callback.file.name      The name of the file
 * @param {Object}      callback.file.size      The size of the resized image (in bytes).
 * @param {Object}      callback.file.width     The width of the resized image.
 * @param {Object}      callback.file.height    The height of the resized image.
 */
var resizeImage = module.exports.resizeImage = function(path, size, callback) {
    var validator = new Validator();
    validator.check(path, {'code': 400, 'msg': 'A path to the image that you want to resize is missing'}).notNull();
    validator.check(null, {'code': 400, 'msg': 'The size must be specified'}).isObject(size);
    if (size) {
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.width, {'code': 400, 'msg': 'The width needs to be a valid integer larger than 0'}).min(0);
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).isInt();
        validator.check(size.height, {'code': 400, 'msg': 'The height needs to be a valid integer larger than 0'}).min(0);
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    var suffix = size.width + 'x' + size.height + '.png';
    var tempPath = temp.path({'suffix': suffix});
    var imageMagick = gm.subClass({ 'imageMagick': true });
    imageMagick(path)
        .resize(size.width, size.height)
        .write(tempPath, function(err) {
            if (err) {
                fs.unlink(tempPath);
                log().error({'err': err}, 'Could not resize the image %s', path);
                return callback({'code': 500, 'msg': err});
            }
            fs.stat(tempPath, function(err, stat) {
                if (err) {
                    fs.unlink(tempPath);
                    return callback({'code': 500, 'msg': err});
                }
                var file = {
                    'path': tempPath,
                    'size': stat.size,
                    'name': Path.basename(tempPath),
                    'width': size.width,
                    'height': size.height
                };
                callback(null, file);
            });
        });
};
