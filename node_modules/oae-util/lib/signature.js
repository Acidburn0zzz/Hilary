/*!
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var Crypto = require('crypto');
var fs = require('fs');

var log = require('oae-logger').logger('signature');

var Validator = require('oae-util/lib/validator').Validator;

var signKey = null;

/**
 * Initialize the Signature module with the signature key
 * @param   {Object}    keys    The object that holds all the keys in the system.
 * @param   {String}    signing The key that can be used to securely sign messages.
 */
var init = module.exports.init = function(signingConfig) {
    signKey = signingConfig.key;

    if (signKey === 'The default signing key, please change me.') {
        // TODO: This will most likely end-up in bootstrap.log, which might be overlooked, console.log?
        var warningMessage = 'You are using the default key to sign URLs, this is *NOT* secure and should be changed immediately.\n';
        warningMessage += 'The system will continue to function, but it is strongly recommended that you change your key.\n';
        log().warn(warningMessage);
    }
};

/**
 * Sign a string with our key.
 *
 * @param  {String}  tenantAlias    The alias that identifies which tenant this message originates from.
 * @param  {String}  body           The string to sign.
 * @return {String}                 A signature.
 */
var sign = module.exports.sign = function(tenantAlias, body) {
    var msg = tenantAlias + '#' + body;
    var hmac = Crypto.createHmac('sha1', signKey);
    hmac.update(msg);
    return hmac.digest('hex');
};

/**
 * Verify that the passed in signature matches the body.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {String}     body            The body that was originally signed.
 * @param  {String}     signature       The signature that was passed in by the user.
 * @return {Boolean}                    Whether or not the body was untampered with
 */
var verify = module.exports.verify = function(tenantAlias, body, signature) {
    var msg = tenantAlias + '#' + body;
    var hmac = Crypto.createHmac('sha1', signKey);
    hmac.update(msg);
    return hmac.digest('hex') === signature;
};

/**
 * Creates a signature that is valid for `expires` amount of minutes.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Number}     expires         The number of milliseconds this signature is valid.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and a `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiringSignature = module.exports.createExpiringSignature = function(tenantAlias, expires, body) {
    var ts = Date.now() + expires;
    var msg = ts + '#' + body;
    var signature = sign(tenantAlias, msg);
    return {
        'signature': signature,
        'expires' : ts
    };
};



/**
 * Creates a rolling signature. This is useful for creating URLs that are cacheable for a certain period of time.
 * Note: This will *NOT* create a signature that expires in <value> <units>!
 * Assume that is Thu Jan 24 2013 12:04:50 in the examples.
 * Examples:
 *   Create a signature that expires next year, with an offset of a day.
 *   $ createRollingSignature('cam', 'year', 1, 'day', 1, 'a body')
 *   > Thu Jan 02 2014 00:00:01 GMT+0000 (GMT)
 *
 *   Create a signature that expires next day with an offset of 15 minutes
 *   $ createRollingSignature('cam', 'day', 1, 'minute', 15, 'a body')
 *   > Fri Jan 25 2013 00:15:01 GMT+0000 (GMT)
 *
 *   Create a signature that expires in the the next block of 15 minutes with an offset of 1 minute.
 *   $ createRollingSignature('cam', 'day', 1, 'minute', 15, 'a body')
 *   > Thu Jan 24 2013 12:16:01 GMT+0000 (GMT)
 *   As it is 12:04 at this time, this block ends at 12:15. Adding an offset gives us 12:16
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {String}     unit            One of 'year', 'month', 'second', 'day', 'hour' or 'minute'.
 * @param  {Number}     value           The maximum amount in units that the signature should be valid.
 * @param  {String}     [offsetUnit]    One of 'year', 'month', 'second', 'day', 'hour' or 'minute'.
 * @param  {Number}     [offsetValue]  The amount in `offsetUnit`s that should be added to the signature.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and a `expires` key which holds the timestamp when the signature will expire.
 */
var createRollingSignature = module.exports.createRollingSignature = function(tenantAlias, unit, value, offsetUnit, offsetValue, body) {
    var now = new Date();
    var expiresAt = new Date(now.getFullYear(), 0, 1, 0, 0, 1);

    if (unit === 'year') {
        expiresAt.setFullYear(now.getFullYear() + value);
    } else if (unit === 'month') {
        expiresAt.setMonth(now.getMonth() + value);
    } else if (unit === 'day') {
        expiresAt.setMonth(now.getMonth());
        expiresAt.setDate(now.getDate() + value);
    } else if (unit === 'hour') {
        expiresAt.setMonth(now.getMonth());
        expiresAt.setDate(now.getDate());
        expiresAt.setHours(now.getHours() + value);
    } else if (unit === 'minute') {
        expiresAt.setMonth(now.getMonth());
        expiresAt.setDate(now.getDate());
        expiresAt.setHours(now.getHours());
        var minutes = Math.floor(now.getMinutes() / value) * value + value;
        expiresAt.setMinutes(minutes);
    }


    // OFFSET
    if (offsetUnit && offsetValue) {
        if (offsetUnit === 'year') {
            expiresAt.setFullYear(expiresAt.getFullYear() + offsetValue);
        } else if (offsetUnit === 'month') {
            expiresAt.setMonth(expiresAt.getMonth() + offsetValue);
        } else if (offsetUnit === 'day') {
            expiresAt.setDate(expiresAt.getDate() + offsetValue);
        } else if (offsetUnit === 'hour') {
            expiresAt.setHours(expiresAt.getHours() + offsetValue);
        } else if (offsetUnit === 'minute') {
            expiresAt.setMinutes(expiresAt.getMinutes() + offsetValue);
        }
    }

    return createExpiresAtSignature(tenantAlias, expiresAt, body);
};

/**
 * Verifies if the signature matches a given body.
 * The `expires` value will be taken into account and checked against the current time.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {Number}     expires         A timestamp in ms when this signature expires.
 * @param  {String}     body            The body that the signature was placed on.
 * @param  {String}     signature       The signature as generated by `createExpiringSignature`.
 * @return {Boolean}                    Whether or not the signature is valid.
 */
var verifyExpiringSignature = module.exports.verifyExpiringSignature = function(tenantAlias, expires, body, signature) {
    // Check the expiry date.
    if (Date.now() > expires) {
        return false;
    }

    // Check the signature.
    var msg = expires + '#' + body;
    return verify(tenantAlias, msg, signature);
};



/**
 * Creates a signature that is valid till the `expiresAt` date.
 *
 * @param  {String}     tenantAlias     The alias that identifies which tenant this message originates from.
 * @param  {Date}       expiresAt       The date when the signature should expire.
 * @param  {String}     body            The body that needs signing
 * @return {Object}                     An object with a `signature` key that holds the signature and an `expires` key which holds the timestamp when the signature will expire.
 */
var createExpiresAtSignature = module.exports.createExpiresAtSignature = function(tenantAlias, expiresAt, body) {
    var msg = expiresAt.getTime() + '#' + body;
    var signature = sign(tenantAlias, msg);
    return {
        'signature': signature,
        'expires' : expiresAt.getTime()
    };
};

/**
 * Check whether or not a signature is valid.
 *
 * @param  {String} tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {String} body            The body that was used to generate the signature.
 * @see verify
 */
Validator.prototype.verifySignature = function(tenantAlias, body) {
    if (!this.str || !verify(tenantAlias, body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};

/**
 * Check whether or not an expiring signature is valid.
 *
 * @param  {String} tenantAlias     The alias that identifies which tenant the message originated from.
 * @param  {Number} expires         The timestamp in ms when the signature expires.
 * @param  {String} body            The body that was used to generate the signature.
 * @see verifyExpiringSignature
 */
Validator.prototype.verifyExpiringSignature = function(tenantAlias, expires, body) {
    if (!this.str || !verifyExpiringSignature(tenantAlias, expires, body, this.str)) {
        this.error(this.msg || 'Invalid signature');
    }
    return this;
};
